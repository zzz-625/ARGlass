; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\hid_transfer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\hid_transfer.d --feedback=.\obj\NANO100B_ISP_HID_flag.fed --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include -I..\..\..\..\Library\StdDriver\inc -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\hid_transfer.crf ..\hid_transfer.c]
                          THUMB

                          AREA ||i.EP2_Handler||, CODE, READONLY, ALIGN=2

                  EP2_Handler PROC
;;;126    extern __align(4) uint8_t response_buff[64];
;;;127    void EP2_Handler(void)  /* Interrupt IN handler */
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129        uint8_t *ptr;
;;;130        ptr = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP2));
000002  4c06              LDR      r4,|L1.28|
000004  6820              LDR      r0,[r4,#0]
000006  4905              LDR      r1,|L1.28|
;;;131        /* Prepare the data for next HID IN transfer */
;;;132        USBD_MemCopy(ptr, response_buff, EP2_MAX_PKT_SIZE);
000008  2240              MOVS     r2,#0x40
00000a  31c0              ADDS     r1,r1,#0xc0           ;130
00000c  1840              ADDS     r0,r0,r1              ;130
00000e  4904              LDR      r1,|L1.32|
000010  f7fffffe          BL       USBD_MemCopy
;;;133        USBD_SET_PAYLOAD_LEN(EP2, EP2_MAX_PKT_SIZE);
000014  2040              MOVS     r0,#0x40
000016  6060              STR      r0,[r4,#4]
;;;134    }
000018  bd10              POP      {r4,pc}
;;;135    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40060040
                  |L1.32|
                          DCD      response_buff

                          AREA ||i.EP3_Handler||, CODE, READONLY, ALIGN=2

                  EP3_Handler PROC
;;;135    
;;;136    void EP3_Handler(void)  /* Interrupt OUT handler */
000000  b510              PUSH     {r4,lr}
;;;137    {
;;;138        uint8_t *ptr;
;;;139        /* Interrupt OUT */
;;;140        ptr = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP3));
000002  4c07              LDR      r4,|L2.32|
000004  6920              LDR      r0,[r4,#0x10]
000006  4906              LDR      r1,|L2.32|
;;;141        USBD_MemCopy(usb_rcvbuf, ptr, EP3_MAX_PKT_SIZE);
000008  2240              MOVS     r2,#0x40
00000a  31c0              ADDS     r1,r1,#0xc0           ;140
00000c  1841              ADDS     r1,r0,r1              ;140
00000e  4805              LDR      r0,|L2.36|
000010  f7fffffe          BL       USBD_MemCopy
;;;142        bUsbDataReady = TRUE;
000014  4904              LDR      r1,|L2.40|
000016  2001              MOVS     r0,#1
000018  7008              STRB     r0,[r1,#0]
;;;143        USBD_SET_PAYLOAD_LEN(EP3, EP3_MAX_PKT_SIZE);
00001a  2040              MOVS     r0,#0x40
00001c  6160              STR      r0,[r4,#0x14]
;;;144    }
00001e  bd10              POP      {r4,pc}
;;;145    
                          ENDP

                  |L2.32|
                          DCD      0x40060040
                  |L2.36|
                          DCD      ||.bss||
                  |L2.40|
                          DCD      ||area_number.12||

                          AREA ||i.HID_ClassRequest||, CODE, READONLY, ALIGN=2

                  HID_ClassRequest PROC
;;;179    
;;;180    void HID_ClassRequest(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;181    {
;;;182        uint8_t buf[8];
;;;183        USBD_GetSetupPacket(buf);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       USBD_GetSetupPacket
;;;184    
;;;185        if (buf[0] & 0x80) { /* request data transfer direction */
000008  4668              MOV      r0,sp
00000a  7800              LDRB     r0,[r0,#0]
00000c  0600              LSLS     r0,r0,#24
00000e  d408              BMI      |L3.34|
;;;186            // Device to host
;;;187            switch (buf[1]) {
;;;188                case GET_REPORT:
;;;189    
;;;190    //             {
;;;191    //                 break;
;;;192    //             }
;;;193                case GET_IDLE:
;;;194    
;;;195    //             {
;;;196    //                 break;
;;;197    //             }
;;;198                case GET_PROTOCOL:
;;;199    
;;;200    //            {
;;;201    //                break;
;;;202    //            }
;;;203                default: {
;;;204                    /* Setup error, stall the device */
;;;205                    USBD_SetStall(0);
;;;206                    break;
;;;207                }
;;;208            }
;;;209        } else {
;;;210            // Host to device
;;;211            switch (buf[1]) {
000010  4668              MOV      r0,sp
000012  7840              LDRB     r0,[r0,#1]
000014  2300              MOVS     r3,#0
;;;212                case SET_REPORT: {
;;;213                    if (buf[3] == 3) {
;;;214                        /* Request Type = Feature */
;;;215                        USBD_SET_DATA1(EP1);
000016  490c              LDR      r1,|L3.72|
000018  2280              MOVS     r2,#0x80
00001a  2809              CMP      r0,#9                 ;211
00001c  d005              BEQ      |L3.42|
00001e  280a              CMP      r0,#0xa               ;211
000020  d00c              BEQ      |L3.60|
                  |L3.34|
;;;216                        USBD_SET_PAYLOAD_LEN(EP1, 0);
;;;217                    }
;;;218    
;;;219                    break;
;;;220                }
;;;221    
;;;222                case SET_IDLE: {
;;;223                    /* Status stage */
;;;224                    USBD_SET_DATA1(EP0);
;;;225                    USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;226                    break;
;;;227                }
;;;228    
;;;229                case SET_PROTOCOL:
;;;230    
;;;231    //             {
;;;232    //                 break;
;;;233    //             }
;;;234                default: {
;;;235                    // Stall
;;;236                    /* Setup error, stall the device */
;;;237                    USBD_SetStall(0);
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       USBD_SetStall
                  |L3.40|
;;;238                    break;
;;;239                }
;;;240            }
;;;241        }
;;;242    }
000028  bd1c              POP      {r2-r4,pc}
                  |L3.42|
00002a  4668              MOV      r0,sp                 ;213
00002c  78c0              LDRB     r0,[r0,#3]            ;213
00002e  2803              CMP      r0,#3                 ;213
000030  d1fa              BNE      |L3.40|
000032  6b88              LDR      r0,[r1,#0x38]         ;215
000034  4310              ORRS     r0,r0,r2              ;215
000036  6388              STR      r0,[r1,#0x38]         ;215
000038  634b              STR      r3,[r1,#0x34]         ;216
00003a  bd1c              POP      {r2-r4,pc}
                  |L3.60|
00003c  6a88              LDR      r0,[r1,#0x28]         ;224
00003e  4310              ORRS     r0,r0,r2              ;224
000040  6288              STR      r0,[r1,#0x28]         ;224
000042  624b              STR      r3,[r1,#0x24]         ;225
000044  bd1c              POP      {r2-r4,pc}
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      0x40060000

                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;152      */
;;;153    void HID_Init(void)
000000  480c              LDR      r0,|L4.52|
;;;154    {
;;;155        /* Init setup packet buffer */
;;;156        /* Buffer range for setup packet -> [0 ~ 0x7] */
;;;157        USBD->BUFSEG = SETUP_BUF_BASE;
000002  2100              MOVS     r1,#0
000004  6181              STR      r1,[r0,#0x18]
;;;158        /*****************************************************/
;;;159        /* EP0 ==> control IN endpoint, address 0 */
;;;160        USBD_CONFIG_EP(EP0, USBD_CFG_CSTALL | USBD_CFG_EPMODE_IN | 0);
000006  21ff              MOVS     r1,#0xff
000008  3141              ADDS     r1,r1,#0x41
00000a  6281              STR      r1,[r0,#0x28]
;;;161        /* Buffer range for EP0 */
;;;162        USBD_SET_EP_BUF_ADDR(EP0, EP0_BUF_BASE);
00000c  2108              MOVS     r1,#8
00000e  6201              STR      r1,[r0,#0x20]
;;;163        /* EP1 ==> control OUT endpoint, address 0 */
;;;164        USBD_CONFIG_EP(EP1, USBD_CFG_CSTALL | USBD_CFG_EPMODE_OUT | 0);
000010  22ff              MOVS     r2,#0xff
000012  3221              ADDS     r2,r2,#0x21
000014  6382              STR      r2,[r0,#0x38]
;;;165        /* Buffer range for EP1 */
;;;166        USBD_SET_EP_BUF_ADDR(EP1, EP1_BUF_BASE);
000016  6301              STR      r1,[r0,#0x30]
;;;167        /*****************************************************/
;;;168        /* EP2 ==> Interrupt IN endpoint, address 1 */
;;;169        USBD_CONFIG_EP(EP2, USBD_CFG_EPMODE_IN | INT_IN_EP_NUM);
000018  4806              LDR      r0,|L4.52|
00001a  2141              MOVS     r1,#0x41
00001c  3040              ADDS     r0,r0,#0x40
00001e  6081              STR      r1,[r0,#8]
;;;170        /* Buffer range for EP2 */
;;;171        USBD_SET_EP_BUF_ADDR(EP2, EP2_BUF_BASE);
000020  2110              MOVS     r1,#0x10
000022  6001              STR      r1,[r0,#0]
;;;172        /* EP3 ==> Interrupt OUT endpoint, address 2 */
;;;173        USBD_CONFIG_EP(EP3, USBD_CFG_EPMODE_OUT | INT_OUT_EP_NUM);
000024  2122              MOVS     r1,#0x22
000026  6181              STR      r1,[r0,#0x18]
;;;174        /* Buffer range for EP3 */
;;;175        USBD_SET_EP_BUF_ADDR(EP3, EP3_BUF_BASE);
000028  2150              MOVS     r1,#0x50
00002a  6101              STR      r1,[r0,#0x10]
;;;176        /* trigger to receive OUT data */
;;;177        USBD_SET_PAYLOAD_LEN(EP3, EP3_MAX_PKT_SIZE);
00002c  2140              MOVS     r1,#0x40
00002e  6141              STR      r1,[r0,#0x14]
;;;178    }
000030  4770              BX       lr
;;;179    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x40060000

                          AREA ||i.USBD_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_IRQHandler PROC
;;;20     
;;;21     void USBD_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;22     {
;;;23         uint32_t u32IntSts = USBD_GET_INT_FLAG();
000002  4d34              LDR      r5,|L5.212|
000004  68ec              LDR      r4,[r5,#0xc]
;;;24         uint32_t u32State = USBD_GET_BUS_STATE();
000006  6868              LDR      r0,[r5,#4]
;;;25     
;;;26     //------------------------------------------------------------------
;;;27         if (u32IntSts & USBD_INTSTS_FLDET) {
;;;28             // Floating detect
;;;29             USBD_CLR_INT_FLAG(USBD_INTSTS_FLDET);
;;;30     
;;;31             if (USBD_IS_ATTACHED()) {
;;;32                 /* USB Plug In */
;;;33                 USBD_ENABLE_USB();
000008  270f              MOVS     r7,#0xf
00000a  0706              LSLS     r6,r0,#28             ;24
00000c  0f36              LSRS     r6,r6,#28             ;24
00000e  0760              LSLS     r0,r4,#29             ;27
000010  2800              CMP      r0,#0                 ;27
000012  da0a              BGE      |L5.42|
000014  2004              MOVS     r0,#4                 ;29
000016  60e8              STR      r0,[r5,#0xc]          ;29
000018  6868              LDR      r0,[r5,#4]            ;31
00001a  06c0              LSLS     r0,r0,#27             ;31
;;;34             } else {
;;;35                 /* USB Un-plug */
;;;36                 USBD_DISABLE_USB();
00001c  6828              LDR      r0,[r5,#0]
00001e  d501              BPL      |L5.36|
000020  4338              ORRS     r0,r0,r7              ;33
000022  e001              B        |L5.40|
                  |L5.36|
000024  0840              LSRS     r0,r0,#1
000026  0040              LSLS     r0,r0,#1
                  |L5.40|
000028  6028              STR      r0,[r5,#0]            ;33
                  |L5.42|
;;;37             }
;;;38         }
;;;39     
;;;40     //------------------------------------------------------------------
;;;41         if (u32IntSts & USBD_INTSTS_BUS) {
00002a  07e0              LSLS     r0,r4,#31
00002c  d013              BEQ      |L5.86|
;;;42             /* Clear event flag */
;;;43             USBD_CLR_INT_FLAG(USBD_INTSTS_BUS);
00002e  2001              MOVS     r0,#1
000030  60e8              STR      r0,[r5,#0xc]
;;;44     
;;;45             if (u32State & USBD_STATE_USBRST) {
000032  07f0              LSLS     r0,r6,#31
000034  d004              BEQ      |L5.64|
;;;46                 /* Bus reset */
;;;47                 USBD_ENABLE_USB();
000036  6828              LDR      r0,[r5,#0]
000038  4338              ORRS     r0,r0,r7
00003a  6028              STR      r0,[r5,#0]
;;;48                 USBD_SwReset();
00003c  f7fffffe          BL       USBD_SwReset
                  |L5.64|
;;;49             }
;;;50     
;;;51             if (u32State & USBD_STATE_SUSPEND) {
000040  07b0              LSLS     r0,r6,#30
000042  d503              BPL      |L5.76|
;;;52                 /* Enable USB but disable PHY */
;;;53                 USBD_DISABLE_PHY();
000044  6828              LDR      r0,[r5,#0]
000046  2102              MOVS     r1,#2
000048  4388              BICS     r0,r0,r1
00004a  6028              STR      r0,[r5,#0]
                  |L5.76|
;;;54             }
;;;55     
;;;56             if (u32State & USBD_STATE_RESUME) {
00004c  0770              LSLS     r0,r6,#29
00004e  d502              BPL      |L5.86|
;;;57                 /* Enable USB and enable PHY */
;;;58                 USBD_ENABLE_USB();
000050  6828              LDR      r0,[r5,#0]
000052  4338              ORRS     r0,r0,r7
000054  6028              STR      r0,[r5,#0]
                  |L5.86|
;;;59             }
;;;60         }
;;;61     
;;;62     //------------------------------------------------------------------
;;;63         if (u32IntSts & USBD_INTSTS_USB) {
000056  07a0              LSLS     r0,r4,#30
000058  d53b              BPL      |L5.210|
;;;64             // USB event
;;;65             if (u32IntSts & USBD_INTSTS_SETUP) {
00005a  2c00              CMP      r4,#0
00005c  da0b              BGE      |L5.118|
;;;66                 // Setup packet
;;;67                 /* Clear event flag */
;;;68                 USBD_CLR_INT_FLAG(USBD_INTSTS_SETUP);
00005e  2001              MOVS     r0,#1
000060  07c0              LSLS     r0,r0,#31
000062  60e8              STR      r0,[r5,#0xc]
;;;69                 /* Clear the data IN/OUT ready flag of control end-points */
;;;70                 USBD_STOP_TRANSACTION(EP0);
000064  6aa9              LDR      r1,[r5,#0x28]
000066  0c00              LSRS     r0,r0,#16
000068  4301              ORRS     r1,r1,r0
00006a  62a9              STR      r1,[r5,#0x28]
;;;71                 USBD_STOP_TRANSACTION(EP1);
00006c  6ba9              LDR      r1,[r5,#0x38]
00006e  4301              ORRS     r1,r1,r0
000070  63a9              STR      r1,[r5,#0x38]
;;;72                 USBD_ProcessSetupPacket();
000072  f7fffffe          BL       USBD_ProcessSetupPacket
                  |L5.118|
;;;73             }
;;;74     
;;;75             // EP events
;;;76             if (u32IntSts & USBD_INTSTS_EP0) {
000076  03e0              LSLS     r0,r4,#15
000078  d504              BPL      |L5.132|
;;;77                 /* Clear event flag */
;;;78                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP0);
00007a  2001              MOVS     r0,#1
00007c  0400              LSLS     r0,r0,#16
00007e  60e8              STR      r0,[r5,#0xc]
;;;79                 // control IN
;;;80                 USBD_CtrlIn();
000080  f7fffffe          BL       USBD_CtrlIn
                  |L5.132|
;;;81             }
;;;82     
;;;83             if (u32IntSts & USBD_INTSTS_EP1) {
000084  03a0              LSLS     r0,r4,#14
000086  d504              BPL      |L5.146|
;;;84                 /* Clear event flag */
;;;85                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP1);
000088  2001              MOVS     r0,#1
00008a  0440              LSLS     r0,r0,#17
00008c  60e8              STR      r0,[r5,#0xc]
;;;86                 // control OUT
;;;87                 USBD_CtrlOut();
00008e  f7fffffe          BL       USBD_CtrlOut
                  |L5.146|
;;;88             }
;;;89     
;;;90             if (u32IntSts & USBD_INTSTS_EP2) {
000092  0360              LSLS     r0,r4,#13
000094  d502              BPL      |L5.156|
;;;91                 /* Clear event flag */
;;;92                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP2);
000096  2001              MOVS     r0,#1
000098  0480              LSLS     r0,r0,#18
00009a  60e8              STR      r0,[r5,#0xc]
                  |L5.156|
;;;93                 // Interrupt IN
;;;94     //          EP2_Handler();
;;;95             }
;;;96     
;;;97             if (u32IntSts & USBD_INTSTS_EP3) {
00009c  0320              LSLS     r0,r4,#12
00009e  d504              BPL      |L5.170|
;;;98                 /* Clear event flag */
;;;99                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP3);
0000a0  2001              MOVS     r0,#1
0000a2  04c0              LSLS     r0,r0,#19
0000a4  60e8              STR      r0,[r5,#0xc]
;;;100                // Interrupt OUT
;;;101                EP3_Handler();
0000a6  f7fffffe          BL       EP3_Handler
                  |L5.170|
;;;102            }
;;;103    
;;;104            if (u32IntSts & USBD_INTSTS_EP4) {
0000aa  02e0              LSLS     r0,r4,#11
0000ac  d502              BPL      |L5.180|
;;;105                /* Clear event flag */
;;;106                USBD_CLR_INT_FLAG(USBD_INTSTS_EP4);
0000ae  2001              MOVS     r0,#1
0000b0  0500              LSLS     r0,r0,#20
0000b2  60e8              STR      r0,[r5,#0xc]
                  |L5.180|
;;;107            }
;;;108    
;;;109            if (u32IntSts & USBD_INTSTS_EP5) {
0000b4  02a0              LSLS     r0,r4,#10
0000b6  d502              BPL      |L5.190|
;;;110                /* Clear event flag */
;;;111                USBD_CLR_INT_FLAG(USBD_INTSTS_EP5);
0000b8  2001              MOVS     r0,#1
0000ba  0540              LSLS     r0,r0,#21
0000bc  60e8              STR      r0,[r5,#0xc]
                  |L5.190|
;;;112            }
;;;113    
;;;114            if (u32IntSts & USBD_INTSTS_EP6) {
0000be  0260              LSLS     r0,r4,#9
0000c0  d502              BPL      |L5.200|
;;;115                /* Clear event flag */
;;;116                USBD_CLR_INT_FLAG(USBD_INTSTS_EP6);
0000c2  2001              MOVS     r0,#1
0000c4  0580              LSLS     r0,r0,#22
0000c6  60e8              STR      r0,[r5,#0xc]
                  |L5.200|
;;;117            }
;;;118    
;;;119            if (u32IntSts & USBD_INTSTS_EP7) {
0000c8  0220              LSLS     r0,r4,#8
0000ca  d502              BPL      |L5.210|
;;;120                /* Clear event flag */
;;;121                USBD_CLR_INT_FLAG(USBD_INTSTS_EP7);
0000cc  2001              MOVS     r0,#1
0000ce  05c0              LSLS     r0,r0,#23
0000d0  60e8              STR      r0,[r5,#0xc]
                  |L5.210|
;;;122            }
;;;123        }
;;;124    }
0000d2  bdf8              POP      {r3-r7,pc}
;;;125    
                          ENDP

                  |L5.212|
                          DCD      0x40060000

                          AREA ||i.USBD_MemCopy||, CODE, READONLY, ALIGN=1

                  USBD_MemCopy PROC
;;;392      */
;;;393    static __INLINE void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
000000  e003              B        |L6.10|
                  |L6.2|
;;;394    {
;;;395        while (size--) *dest++ = *src++;
000002  780b              LDRB     r3,[r1,#0]
000004  7003              STRB     r3,[r0,#0]
000006  1c40              ADDS     r0,r0,#1
000008  1c49              ADDS     r1,r1,#1
                  |L6.10|
00000a  1e52              SUBS     r2,r2,#1
00000c  d2f9              BCS      |L6.2|
;;;396    }
00000e  4770              BX       lr
;;;397    
                          ENDP


                          AREA ||i.USBD_SetStall||, CODE, READONLY, ALIGN=2

                  USBD_SetStall PROC
;;;406     */
;;;407    static __INLINE void USBD_SetStall(uint8_t epnum)
000000  b530              PUSH     {r4,r5,lr}
;;;408    {
;;;409        uint32_t u32CfgAddr;
;;;410        uint32_t u32Cfg;
;;;411        int i;
;;;412    
;;;413        for (i=0; i<USBD_MAX_EP; i++)
;;;414        {
;;;415            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
000002  4c09              LDR      r4,|L7.40|
000004  2100              MOVS     r1,#0                 ;413
                  |L7.6|
000006  010a              LSLS     r2,r1,#4
000008  1913              ADDS     r3,r2,r4
;;;416            u32Cfg = *((__IO uint32_t *) (u32CfgAddr));
00000a  681a              LDR      r2,[r3,#0]
;;;417    
;;;418            if((u32Cfg & 0xf) == epnum)
00000c  0715              LSLS     r5,r2,#28
00000e  0f2d              LSRS     r5,r5,#28
000010  4285              CMP      r5,r0
000012  d104              BNE      |L7.30|
;;;419            {
;;;420                *((__IO uint32_t *) (u32CfgAddr)) = (u32Cfg | USBD_CFG_SSTALL);
000014  2001              MOVS     r0,#1
000016  0240              LSLS     r0,r0,#9
000018  4302              ORRS     r2,r2,r0
00001a  601a              STR      r2,[r3,#0]
;;;421                break;
;;;422            }
;;;423        }
;;;424    }
00001c  bd30              POP      {r4,r5,pc}
                  |L7.30|
00001e  1c49              ADDS     r1,r1,#1
000020  2908              CMP      r1,#8                 ;413
000022  dbf0              BLT      |L7.6|
000024  bd30              POP      {r4,r5,pc}
;;;425    
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40060028

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  usb_rcvbuf
                          %        64

                          AREA ||.data||, DATA, ALIGN=0

                  g_u8EP2Ready
000000  00                DCB      0x00

                          AREA ||area_number.12||, DATA, ALIGN=0

                          EXPORTAS ||area_number.12||, ||.data||
                  bUsbDataReady
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\hid_transfer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_hid_transfer_c_6dbc9832____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_hid_transfer_c_6dbc9832____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_hid_transfer_c_6dbc9832____REVSH|
#line 402
|__asm___14_hid_transfer_c_6dbc9832____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
