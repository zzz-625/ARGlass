L 1 "..\ISP_USER.c"
N/******************************************************************************
N * @file     ISP_USER.c
N * @brief    ISP sample source file
N * @version  0x27
N * @date     31, December, 2014
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#include <stdio.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 11 "..\ISP_USER.c" 2
N#include "string.h"
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 12 "..\ISP_USER.c" 2
N#include "ISP_USER.h"
L 1 "..\ISP_USER.h" 1
N#ifndef ISP_USER_H
N#define ISP_USER_H
N
N#define FW_VERSION                  0x31
N
N#include "FMC_USER.h"
L 1 "..\FMC_USER.h" 1
N#ifndef FMC_USER_H
N#define FMC_USER_H
N
N#include "targetdev.h"
L 1 "..\targetdev.h" 1
N
N#include "Nano100Series.h"
L 1 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 1
N/**************************************************************************//**
N * @file     Nano100Series.h
N * @version  V1.00
N * $Revision: 79 $
N * $Date: 15/06/22 5:34p $
N * @brief    Nano100 series peripheral access layer header file.
N *           This file contains all the peripheral register's definitions,
N *           bits definitions and memory mapping for NuMicro Nano100 series MCU.
N *
N * @note
N * Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N/**
N   \mainpage NuMicro NANO100BN Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of Nano100BN Series MCU device driver
N   *
N   * <b>Disclaimer</b>
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or
N   * operation, including without limitation any and all warranties of merchantability, fitness
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Important Notice</b>
N   *
N   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
N   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
N   * property damage. Such applications are deemed, "Insecure Usage".
N   *
N   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
N   * atomic energy control instruments, airplane or spaceship instruments, the control or
N   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
N   * instruments, all types of safety devices, and other applications intended to support or
N   * sustain life.
N   *
N   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
N   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
N   * the damages and liabilities thus incurred by Nuvoton.
N   *
N   * Please note that all data and specifications are subject to change without notice. All the
N   * trademarks of products and companies mentioned in this datasheet belong to their respective
N   * owners.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2014~2018 Nuvoton Technology Corp. All rights reserved.
N   */
N#ifndef __NANO100SERIES_H__
N#define __NANO100SERIES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup NANO100_Definitions NANO100 Definitions
N  This file defines all structures and symbols for Nano100:
N    - interrupt numbers
N    - registers and bit fields
N    - peripheral base address
N    - peripheral ID
N    - Peripheral definitions
N  @{
N*/
N
N/******************************************************************************/
N/*                Processor and Core Peripherals                              */
N/******************************************************************************/
N/** @addtogroup NANO100_CMSIS Device CMSIS Definitions
N  Configuration of the Cortex-M0 Processor and Core Peripherals
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
Ntypedef enum IRQn
N{
N    /******  Cortex-M0 Processor Exceptions Numbers *****************************************/
N
N    NonMaskableInt_IRQn   = -14,    /*!< 2 Non Maskable Interrupt                           */
N    HardFault_IRQn        = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                   */
N    SVCall_IRQn           = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                     */
N    PendSV_IRQn           = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                     */
N    SysTick_IRQn          = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                 */
N
N    /******  Nano100 specific Interrupt Numbers ***********************************************/
N    BOD_IRQn              = 0,      /*!< Brownout low voltage detected interrupt                   */
N    WDT_IRQn              = 1,      /*!< Watch Dog Timer interrupt                                 */
N    EINT0_IRQn            = 2,      /*!< External signal interrupt from PB.14 pin                  */
N    EINT1_IRQn            = 3,      /*!< External signal interrupt from PB.15 pin                  */
N    GPABC_IRQn            = 4,      /*!< External signal interrupt from PA[15:0]/PB[13:0]/PC[15:0] */
N    GPDEF_IRQn            = 5,      /*!< External interrupt from PD[15:0]/PE[15:0]/PF[15:0]        */
N    PWM0_IRQn             = 6,      /*!< PWM 0 interrupt                                           */
N    PWM1_IRQn             = 7,      /*!< PWM 1 interrupt                                           */
N    TMR0_IRQn             = 8,      /*!< Timer 0 interrupt                                         */
N    TMR1_IRQn             = 9,      /*!< Timer 1 interrupt                                         */
N    TMR2_IRQn             = 10,     /*!< Timer 2 interrupt                                         */
N    TMR3_IRQn             = 11,     /*!< Timer 3 interrupt                                         */
N    UART0_IRQn            = 12,     /*!< UART0 interrupt                                           */
N    UART1_IRQn            = 13,     /*!< UART1 interrupt                                           */
N    SPI0_IRQn             = 14,     /*!< SPI0 interrupt                                            */
N    SPI1_IRQn             = 15,     /*!< SPI1 interrupt                                            */
N    SPI2_IRQn             = 16,     /*!< SPI2 interrupt                                            */
N    HIRC_IRQn             = 17,     /*!< HIRC interrupt                                            */
N    I2C0_IRQn             = 18,     /*!< I2C0 interrupt                                            */
N    I2C1_IRQn             = 19,     /*!< I2C1 interrupt                                            */
N    SC2_IRQn              = 20,     /*!< Smart Card 2 interrupt                                    */
N    SC0_IRQn              = 21,     /*!< Smart Card 0 interrupt                                    */
N    SC1_IRQn              = 22,     /*!< Smart Card 1 interrupt                                    */
N    USBD_IRQn             = 23,     /*!< USB FS Device interrupt                                   */
N    LCD_IRQn              = 25,     /*!< LCD interrupt                                             */
N    PDMA_IRQn             = 26,     /*!< PDMA interrupt                                            */
N    I2S_IRQn              = 27,     /*!< I2S interrupt                                             */
N    PDWU_IRQn             = 28,     /*!< Power Down Wake up interrupt                              */
N    ADC_IRQn              = 29,     /*!< ADC interrupt                                             */
N    DAC_IRQn              = 30,     /*!< DAC interrupt                                             */
N    RTC_IRQn              = 31      /*!< Real time clock interrupt                                 */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __CM0_REV                0x0201    /*!< Core Revision r2p1                               */
N#define __NVIC_PRIO_BITS         2         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig   0         /*!< Set to 1 if different SysTick Config is used     */
N#define __MPU_PRESENT            0         /*!< MPU present or not                               */
N#define __FPU_PRESENT            0         /*!< FPU present or not                               */
N
N/*@}*/ /* end of group NANO100_CMSIS */
N
N
N#include "core_cm0.h"                       /* Cortex-M0 processor and core peripherals           */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 45 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\..\..\..\Library\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060750 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x00U) == 0x04U) || ((0x00U) == 0x07U)
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return(result);
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x00U) >= 0x04U)   
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "..\..\..\..\Library\CMSIS\Include\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 164 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060750 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 165 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 142 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "system_Nano100Series.h"           /* Nano100 Series System include file                  */
L 1 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\system_Nano100Series.h" 1
N/**************************************************************************//**
N * @file     system_Nano100Series.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/01/07 7:35p $
N * @brief    Nano100 series system clock definition file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N
N#ifndef __SYSTEM_NANO100SERIES_H__
N#define __SYSTEM_NANO100SERIES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N
N#define __HXT         (12000000UL)
N#define __LXT         (32768UL)
N#define __HIRC12M     (12000000UL)
N#define __LIRC        (10000UL)
N#define __HIRC        __HIRC12M
N#define __HSI         (__HIRC12M)      /* Factory Default is internal 12MHz */
N
N
Nextern uint32_t SystemCoreClock;        /*!< System Clock Frequency (Core Clock) */
Nextern uint32_t CyclesPerUs;            /*!< Cycles per micro second */
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  None
N * @return None
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from CPU registers.
N */
N
Nextern void SystemCoreClockUpdate (void);
Nextern uint32_t SysGet_PLLClockFreq(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  //__SYSTEM_NANO100SERIES_H__
N
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 143 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include <stdint.h>
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup NANO100_Peripherals NANO100 Peripherals
N  NANO100 Device Specific Peripheral registers structures
N  @{
N*/
N
N#if defined ( __CC_ARM  )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * RESULT0, RESULT1.. RESULT17
N     * ===================================================================================================
N     * Offset: 0x00 ~0x44 A/D Data Register 0~17
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |RSLT      |A/D Conversion Result
N     * |        |          |This field contains 12 bits conversion results.
N     * |[16]    |VALID     |Data Valid Flag
N     * |        |          |It is a mirror of VALID bit in ADC_RESULTx
N     * |[17]    |OVERRUN   |Over Run Flag
N     * |        |          |It is a mirror to OVERRUN bit in ADC_RESULTx
N    */
N    __I  uint32_t RESULT[18];
X    volatile const  uint32_t RESULT[18];
N
N
N    /**
N     * CR
N     * ===================================================================================================
N     * Offset: 0x48  A/D Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADEN      |A/D Converter Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Before starting A/D conversion, this bit should be set to 1.
N     * |        |          |Clear it to 0 to disable A/D converter analog circuit power consumption.
N     * |[1]     |ADIE      |A/D Interrupt Enable
N     * |        |          |0 = A/D interrupt function Disabled.
N     * |        |          |1 = A/D interrupt function Enabled.
N     * |        |          |A/D conversion end interrupt request is generated if ADIE bit is set to 1.
N     * |[3:2]   |ADMD      |A/D Converter Operation Mode
N     * |        |          |00 = Single conversion
N     * |        |          |01 = Reserved
N     * |        |          |10 = Single-cycle scan
N     * |        |          |11 = Continuous scan
N     * |[5:4]   |TRGS      |Hardware Trigger Source
N     * |        |          |This field must keep 00
N     * |        |          |Software should disable TRGE and ADST before change TRGS.
N     * |        |          |In hardware trigger mode, the ADST bit is set by the external trigger from STADC, However software has the highest priority to set or cleared ADST bit at any time.
N     * |[7:6]   |TRGCOND   |External Trigger Condition
N     * |        |          |These two bits decide external pin STADC trigger event is level or edge.
N     * |        |          |The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state.
N     * |        |          |00 = Low level
N     * |        |          |01 = High level
N     * |        |          |10 = Falling edge
N     * |        |          |11 = Rising edge
N     * |[8]     |TRGE      |External Trigger Enable
N     * |        |          |Enable or disable triggering of A/D conversion by external STADC pin.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[9]     |PTEN      |PDMA Transfer Enable
N     * |        |          |0 = PDMA data transfer Disabled.
N     * |        |          |1 = PDMA data transfer in ADC_RESULT 0~17 Enabled.
N     * |        |          |When A/D conversion is completed, the converted data is loaded into ADC_RESULT 0~10, software can enable this bit to generate a PDMA data transfer request.
N     * |        |          |When PTEN=1, software must set ADIE=0 to disable interrupt.
N     * |        |          |PDMA can access ADC_RESULT 0-17 registers by block or single transfer mode.
N     * |[10]    |DIFF      |Differential Mode Selection
N     * |        |          |0 = ADC is operated in single-ended mode.
N     * |        |          |1 = ADC is operated in differential mode.
N     * |        |          |The A/D analog input ADC_CH0/ADC_CH1 consists of a differential pair.
N     * |        |          |So as ADC_CH2/ADC_CH3, ADC_CH4/ADC_CH5, ADC_CH6/ADC_CH7, ADC_CH8/ADC_CH9 and ADC_CH10/ADC_CH11.
N     * |        |          |The even channel defines as plus analog input voltage (Vplus) and the odd channel defines as minus analog input voltage (Vminus).
N     * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus, where Vplus is the analog input; Vminus is the inverted analog input.
N     * |        |          |In differential input mode, only the even number of the two corresponding channels needs to be enabled in CHEN (ADCHER[11:0]).
N     * |        |          |The conversion result will be placed to the corresponding data register of the enabled channel.
N     * |        |          |Note: Calibration should calibrated each time when switching between single-ended and differential mode
N     * |[11]    |ADST      |A/D Conversion Start
N     * |        |          |0 = Conversion stopped and A/D converter enter idle state.
N     * |        |          |1 = Conversion starts.
N     * |        |          |ADST bit can be set to 1 from two sources: software write and external pin STADC.
N     * |        |          |ADST is cleared to 0 by hardware automatically at the end of single mode and single-cycle scan mode on specified channels.
N     * |        |          |In continuous scan mode, A/D conversion is continuously performed sequentially unless software writes 0 to this bit or chip reset.
N     * |        |          |Note: After ADC conversion done, SW needs to wait at least one ADC clock before to set this bit high again.
N     * |[13:12] |TMSEL     |Select A/D Enable Time-Out Source
N     * |        |          |00 = TMR0
N     * |        |          |01 = TMR1
N     * |        |          |10 = TMR2
N     * |        |          |11 = TMR3
N     * |[15]    |TMTRGMOD  |Timer Event Trigger ADC Conversion
N     * |        |          |0 = This function Disabled.
N     * |        |          |1 = ADC Enabled by TIMER OUT event. Setting TMSEL to select timer event from timer0~3
N     * |[17:16] |REFSEL    |Reference Voltage Source Selection
N     * |        |          |00 = Reserved
N     * |        |          |01 = Select Int_VREF as reference voltage
N     * |        |          |10 = Select VREF as reference voltage
N     * |        |          |11 = Reserved
N     * |[19:18] |RESSEL    |Resolution Selection
N     * |        |          |00 = 6 bits
N     * |        |          |01 = 8 bits
N     * |        |          |10 = 10 bits
N     * |        |          |11 = 12 bits
N     * |[31:24] |TMPDMACNT |PDMA Count
N     * |        |          |When each timer event occur PDMA will transfer TMPDMACNT +1 ADC result in the amount of this register setting
N     * |        |          |Note: The total amount of PDMA transferring data should be set in PDMA byte count register.
N     * |        |          |When PDMA finish is set, ADC will not be enabled and start transfer even though the timer event occurred.
N    */
N    __IO uint32_t CR;
X    volatile uint32_t CR;
N
N    /**
N     * CHEN
N     * ===================================================================================================
N     * Offset: 0x4C  A/D Channel Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHEN0     |Analog Input Channel 0 Enable (Convert Input Voltage From PA.0 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |If more than one channel in single mode is enabled by software, the least channel is converted and other enabled channels will be ignored.
N     * |[1]     |CHEN1     |Analog Input Channel 1 Enable(Convert Input Voltage From PA.1 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[2]     |CHEN2     |Analog Input Channel 2 Enable (Convert Input Voltage From PA.2 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[3]     |CHEN3     |Analog Input Channel 3 Enable(Convert Input Voltage From PA.3 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[4]     |CHEN4     |Analog Input Channel 4 Enable (Convert Input Voltage From PA.4 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[5]     |CHEN5     |Analog Input Channel 5 Enable (Convert Input Voltage From PA.5 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[6]     |CHEN6     |Analog Input Channel 6 Enable (Convert Input Voltage From PA.6 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[7]     |CHEN7     |Analog Input Channel 7 Enable (Convert Input Voltage From PA.7 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[8]     |CHEN8     |Analog Input Channel 8 Enable For DAC0 (Convert Input Voltage From PD.0 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[9]     |CHEN9     |Analog Input Channel 9 Enable For DAC1 (Convert Input Voltage From PD.1 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[10]    |CHEN10    |Analog Input Channel 10 Enable (Convert Input Voltage From PD.2 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[11]    |CHEN11    |Analog Input Channel 11 Enable(Convert Input Voltage From PD.3 )
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[12]    |CHEN12    |Analog Input Channel 12 Enable (Convert DAC0 Output Voltage)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[13]    |CHEN13    |Analog Input Channel 13 Enable (Convert DAC1 Output Voltage)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[14]    |CHEN14    |Analog Input Channel 14 Enable (Convert VTEMP)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[15]    |CHEN15    |Analog Input Channel 15 Enable (Convert Int_VREF)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[16]    |CHEN16    |Analog Input Channel 16 Enable (Convert AVDD)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[17]    |CHEN17    |Analog Input Channel 17 Enable (Convert AVSS)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N    */
N    __IO uint32_t CHEN;
X    volatile uint32_t CHEN;
N
N    /**
N     * CMPR0
N     * ===================================================================================================
N     * Offset: 0x50  A/D Compare Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CMPEN     |Compare Enable
N     * |        |          |0 = Compare Disabled.
N     * |        |          |1 = Compare Enabled.
N     * |        |          |Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADC_RESULTx register.
N     * |        |          |When this bit is set to 1, and CMPMATCNT is 0, the CMPF will be set once the match is hit
N     * |[1]     |CMPIE     |Compare Interrupt Enable
N     * |        |          |0 = Compare function interrupt Disabled.
N     * |        |          |1 = Compare function interrupt Enabled.
N     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF bit will be asserted, in the meanwhile, if CMPIE is set to 1, a compare interrupt request is generated.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase one.
N     * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase by one.
N     * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.
N     * |[7:3]   |CMPCH     |Compare Channel Selection
N     * |        |          |This field selects the channel whose conversion result is selected to be compared.
N     * |[11:8]  |CMPMATCNT |Compare Match Count
N     * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1.
N     * |        |          |When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.
N     * |[27:16] |CMPD      |Comparison Data
N     * |        |          |The 12 bits data is used to compare with conversion result of specified channel.
N     * |        |          |Software can use it to monitor the external analog input pin voltage variation in scan mode without imposing a load on software.
N    */
N    __IO uint32_t CMPR0;
X    volatile uint32_t CMPR0;
N
N    /**
N     * CMPR1
N     * ===================================================================================================
N     * Offset: 0x54  A/D Compare Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CMPEN     |Compare Enable
N     * |        |          |0 = Compare Disabled.
N     * |        |          |1 = Compare Enabled.
N     * |        |          |Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADC_RESULTx register.
N     * |        |          |When this bit is set to 1, and CMPMATCNT is 0, the CMPF will be set once the match is hit
N     * |[1]     |CMPIE     |Compare Interrupt Enable
N     * |        |          |0 = Compare function interrupt Disabled.
N     * |        |          |1 = Compare function interrupt Enabled.
N     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF bit will be asserted, in the meanwhile, if CMPIE is set to 1, a compare interrupt request is generated.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase one.
N     * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPRx[27:16]), the internal match counter will increase by one.
N     * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.
N     * |[7:3]   |CMPCH     |Compare Channel Selection
N     * |        |          |This field selects the channel whose conversion result is selected to be compared.
N     * |[11:8]  |CMPMATCNT |Compare Match Count
N     * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1.
N     * |        |          |When the internal counter reaches the value to (CMPMATCNT +1), the CMPF bit will be set.
N     * |[27:16] |CMPD      |Comparison Data
N     * |        |          |The 12 bits data is used to compare with conversion result of specified channel.
N     * |        |          |Software can use it to monitor the external analog input pin voltage variation in scan mode without imposing a load on software.
N    */
N    __IO uint32_t CMPR1;
X    volatile uint32_t CMPR1;
N
N    /**
N     * SR
N     * ===================================================================================================
N     * Offset: 0x58  A/D Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADF       |A/D Conversion End Flag
N     * |        |          |A status flag that indicates the end of A/D conversion.
N     * |        |          |ADF is set to 1 at these two conditions:
N     * |        |          |When A/D conversion ends in single mode
N     * |        |          |When A/D conversion ends on all specified channels in scan mode.
N     * |        |          |This flag can be cleared by writing 1 to it.
N     * |[1]     |CMPF0     |Compare Flag
N     * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1.
N     * |        |          |And it is cleared by writing 1 to self.
N     * |        |          |0 = Conversion result in ADC_RESULTx does not meet ADCMPR0setting.
N     * |        |          |1 = Conversion result in ADC_RESULTx meets ADCMPR0setting.
N     * |        |          |This flag can be cleared by writing 1 to it.
N     * |        |          |Note: When this flag is set, the matching counter will be reset to 0,and continue to count when user write 1 to clear CMPF0
N     * |[2]     |CMPF1     |Compare Flag
N     * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1.
N     * |        |          |And it is cleared by writing 1 to self.
N     * |        |          |0 = Conversion result in ADC_RESULTx does not meet ADCMPR1 setting.
N     * |        |          |1 = Conversion result in ADC_RESULTx meets ADCMPR1 setting.
N     * |        |          |This flag can be cleared by writing 1 to it.
N     * |        |          |Note: when this flag is set, the matching counter will be reset to 0,and continue to count when user write 1 to clear CMPF1
N     * |[3]     |BUSY      |BUSY/IDLE
N     * |        |          |0 = A/D converter is in idle state.
N     * |        |          |1 = A/D converter is busy at conversion.
N     * |        |          |This bit is a mirror of ADST bit in ADCR. That is to say if ADST = 1,then BUSY is 1 and vice versa.
N     * |        |          |It is read only.
N     * |[8:4]   |CHANNEL   |Current Conversion Channel
N     * |        |          |This filed reflects current conversion channel when BUSY=1.
N     * |        |          |When BUSY=0, it shows the next channel to be converted.
N     * |        |          |It is read only.
N     * |[16]    |INITRDY   |ADC Power-Up Sequence Completed
N     * |        |          |0 = ADC not powered up after system reset.
N     * |        |          |1 = ADC has been powered up since the last system reset.
N     * |        |          |Note: This bit will be set after system reset occurred and automatically cleared by power-up event.
N    */
N    __IO uint32_t SR;
X    volatile uint32_t SR;
N    uint32_t RESERVE0[1];
N
N
N    /**
N     * PDMA
N     * ===================================================================================================
N     * Offset: 0x60  A/D PDMA current transfer data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |AD_PDMA   |ADC PDMA Current Transfer Data Register
N     * |        |          |When PDMA transferring, read this register can monitor current PDMA transfer data.
N     * |        |          |This is a read only register.
N    */
N    __I  uint32_t PDMA;
X    volatile const  uint32_t PDMA;
N
N    /**
N     * PWRCTL
N     * ===================================================================================================
N     * Offset: 0x64  ADC Power Management Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWUPRDY   |ADC Power-Up Sequence Completed And Ready For Conversion
N     * |        |          |0 = ADC is not ready for conversion; may be in power down state or in the progress of power up.
N     * |        |          |1 = ADC is ready for conversion.
N     * |[1]     |PWDCALEN  |Power Up Calibration Function Enable
N     * |        |          |1 = Power up with calibration.
N     * |        |          |0 = Power up without calibration.
N     * |        |          |Note: This bit work together with CALFBKSEL set 1
N     * |[3:2]   |PWDMOD    |Power-Down Mode
N     * |        |          |00 = Power down
N     * |        |          |01 = Reserved
N     * |        |          |10 = Standby mode
N     * |        |          |11 = Reserved
N     * |        |          |Note: Different PWDMOD has different power down/up sequence, in order to avoid ADC powering up with wrong sequence; user must keep PWMOD consistent each time in powe down and power up
N    */
N    __IO uint32_t PWRCTL;
X    volatile uint32_t PWRCTL;
N
N    /**
N     * CALCTL
N     * ===================================================================================================
N     * Offset: 0x68  ADC Calibration  Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CALEN     |Calibration Function Enable
N     * |        |          |Enable this bit to turn on the calibration function block.
N     * |        |          |0 = Disable
N     * |        |          |1 = Enabled.
N     * |[1]     |CALSTART  |Calibration Functional Block Start
N     * |        |          |0 = Stops calibration functional block.
N     * |        |          |1 = Starts calibration functional block.
N     * |        |          |Note: This bit is set by SW and clear by HW; don't write 1 to this bit while CALEN = 0.
N     * |[2]     |CALDONE   |Calibrate Functional Block Complete
N     * |        |          |0 = Not yet.
N     * |        |          |1 = Selected functional block complete.
N     * |[3]     |CALSEL    |Select Calibration Functional Block
N     * |        |          |0 = Load calibration functional block.
N     * |        |          |1 = Calibration functional block.
N    */
N    __IO uint32_t CALCTL;
X    volatile uint32_t CALCTL;
N
N    /**
N     * CALWORD
N     * ===================================================================================================
N     * Offset: 0x6C  A/D calibration  load word register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6:0]   |CALWORD   |Calibration Word Register
N     * |        |          |Write to this register with the previous calibration word before load calibration action
N     * |        |          |Read this register after calibration done
N     * |        |          |Note: The calibration block contains two parts "CALIBRATION" and "LOAD CALIBRATION"; if the calibration block is config as "CALIBRATION"; then this register represent the result of calibration when calibration is completed; if config as "LOAD CALIBRATION" ; config this register before loading calibration action, after loading calibration complete, the loaded calibration word will apply to the ADC;while in loading calibration function the loaded value will not be equal to the original CALWORD until calibration is done.
N    */
N    __IO uint32_t CALWORD;
X    volatile uint32_t CALWORD;
N
N    /**
N     * SMPLCNT0
N     * ===================================================================================================
N     * Offset: 0x70  ADC Channel Sampling Time  Counter Register Group 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |CH0SAMPCNT|Channel 0 Sampling Counter
N     * |        |          |0000 = 0 ADC clock
N     * |        |          |0001 = 1 ADC clock
N     * |        |          |0010 = 2 ADC clocks
N     * |        |          |0011 = 4 ADC clocks
N     * |        |          |0100 = 8 ADC clocks
N     * |        |          |0101 = 16 ADC clocks
N     * |        |          |0110 = 32 ADC clocks
N     * |        |          |0111 = 64 ADC clocks
N     * |        |          |1000 = 128 ADC clocks
N     * |        |          |1001 = 256 ADC clocks
N     * |        |          |1010 = 512 ADC clocks
N     * |        |          |Others = 1024 ADC clocks
N     * |[7:4]   |CH1SAMPCNT|Channel 1 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[11:8]  |CH2SAMPCNT|Channel 2 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[15:12] |CH3SAMPCNT|Channel 3 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[19:16] |CH4SAMPCNT|Channel 4 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[23:20] |CH5SAMPCNT|Channel 5 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[27:24] |CH6SAMPCNT|Channel 6 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[31:28] |CH7SAMPCNT|Channel 7 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N    */
N    __IO uint32_t SMPLCNT0;
X    volatile uint32_t SMPLCNT0;
N
N    /**
N     * SMPLCNT1
N     * ===================================================================================================
N     * Offset: 0x74  ADC Channel Sampling Time  Counter Register Group 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |CH8SAMPCNT|Channel 8 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[7:4]   |CH9SAMPCNT|Channel 9 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[11:8]  |CH10SAMPCNT|Channel 10 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[15:12] |CH11SAMPCNT|Channel 11 Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N     * |[19:16] |INTCHSAMPCNT|Internal Channel (VTEMP, AVDD, AVSS, Int_VREF, DAC0, DAC1) Sampling Counter
N     * |        |          |The same as Channel 0 sampling counter table.
N    */
N    __IO uint32_t SMPLCNT1;
X    volatile uint32_t SMPLCNT1;
N
N} ADC_T;
N
N/**
N    @addtogroup ADC_CONST ADC Bit Field Definition
N    Constant Definitions for ADC Controller
N@{ */
N#define ADC_RESULT_RSLT_Pos              (0)                                               /*!< ADC_T::RESULT: RSLT Position              */
N#define ADC_RESULT_RSLT_Msk              (0xffful << ADC_RESULT_RSLT_Pos)                  /*!< ADC_T::RESULT: RSLT Mask                  */
N
N#define ADC_RESULT_VALID_Pos             (16)                                              /*!< ADC_T::RESULT: VALID Position             */
N#define ADC_RESULT_VALID_Msk             (0x1ul << ADC_RESULT_VALID_Pos)                   /*!< ADC_T::RESULT: VALID Mask                 */
N
N#define ADC_RESULT_OVERRUN_Pos           (17)                                              /*!< ADC_T::RESULT: OVERRUN Position           */
N#define ADC_RESULT_OVERRUN_Msk           (0x1ul << ADC_RESULT_OVERRUN_Pos)                 /*!< ADC_T::RESULT: OVERRUN Mask               */
N
N#define ADC_CR_ADEN_Pos                (0)                                               /*!< ADC_T::CR: ADEN Position                */
N#define ADC_CR_ADEN_Msk                (0x1ul << ADC_CR_ADEN_Pos)                      /*!< ADC_T::CR: ADEN Mask                    */
N
N#define ADC_CR_ADIE_Pos                (1)                                               /*!< ADC_T::CR: ADIE Position                */
N#define ADC_CR_ADIE_Msk                (0x1ul << ADC_CR_ADIE_Pos)                      /*!< ADC_T::CR: ADIE Mask                    */
N
N#define ADC_CR_ADMD_Pos                (2)                                               /*!< ADC_T::CR: ADMD Position                */
N#define ADC_CR_ADMD_Msk                (0x3ul << ADC_CR_ADMD_Pos)                      /*!< ADC_T::CR: ADMD Mask                    */
N
N#define ADC_CR_TRGS_Pos                (4)                                               /*!< ADC_T::CR: TRGS Position                */
N#define ADC_CR_TRGS_Msk                (0x3ul << ADC_CR_TRGS_Pos)                      /*!< ADC_T::CR: TRGS Mask                    */
N
N#define ADC_CR_TRGCOND_Pos             (6)                                               /*!< ADC_T::CR: TRGCOND Position             */
N#define ADC_CR_TRGCOND_Msk             (0x3ul << ADC_CR_TRGCOND_Pos)                   /*!< ADC_T::CR: TRGCOND Mask                 */
N
N#define ADC_CR_TRGE_Pos                (8)                                               /*!< ADC_T::CR: TRGE Position                */
N#define ADC_CR_TRGE_Msk                (0x1ul << ADC_CR_TRGE_Pos)                      /*!< ADC_T::CR: TRGE Mask                    */
N
N#define ADC_CR_PTEN_Pos                (9)                                               /*!< ADC_T::CR: PTEN Position                */
N#define ADC_CR_PTEN_Msk                (0x1ul << ADC_CR_PTEN_Pos)                      /*!< ADC_T::CR: PTEN Mask                    */
N
N#define ADC_CR_DIFF_Pos                (10)                                              /*!< ADC_T::CR: DIFF Position                */
N#define ADC_CR_DIFF_Msk                (0x1ul << ADC_CR_DIFF_Pos)                      /*!< ADC_T::CR: DIFF Mask                    */
N
N#define ADC_CR_ADST_Pos                (11)                                              /*!< ADC_T::CR: ADST Position                */
N#define ADC_CR_ADST_Msk                (0x1ul << ADC_CR_ADST_Pos)                      /*!< ADC_T::CR: ADST Mask                    */
N
N#define ADC_CR_TMSEL_Pos               (12)                                              /*!< ADC_T::CR: TMSEL Position               */
N#define ADC_CR_TMSEL_Msk               (0x3ul << ADC_CR_TMSEL_Pos)                     /*!< ADC_T::CR: TMSEL Mask                   */
N
N#define ADC_CR_TMTRGMOD_Pos            (15)                                              /*!< ADC_T::CR: TMTRGMOD Position            */
N#define ADC_CR_TMTRGMOD_Msk            (0x1ul << ADC_CR_TMTRGMOD_Pos)                  /*!< ADC_T::CR: TMTRGMOD Mask                */
N
N#define ADC_CR_REFSEL_Pos              (16)                                              /*!< ADC_T::CR: REFSEL Position              */
N#define ADC_CR_REFSEL_Msk              (0x3ul << ADC_CR_REFSEL_Pos)                    /*!< ADC_T::CR: REFSEL Mask                  */
N
N#define ADC_CR_RESSEL_Pos              (18)                                              /*!< ADC_T::CR: RESSEL Position              */
N#define ADC_CR_RESSEL_Msk              (0x3ul << ADC_CR_RESSEL_Pos)                    /*!< ADC_T::CR: RESSEL Mask                  */
N
N#define ADC_CR_TMPDMACNT_Pos           (24)                                              /*!< ADC_T::CR: TMPDMACNT Position           */
N#define ADC_CR_TMPDMACNT_Msk           (0xfful << ADC_CR_TMPDMACNT_Pos)                /*!< ADC_T::CR: TMPDMACNT Mask               */
N
N#define ADC_CHEN_CHEN0_Pos             (0)                                               /*!< ADC_T::CHEN: CHEN0 Position             */
N#define ADC_CHEN_CHEN0_Msk             (0x1ul << ADC_CHEN_CHEN0_Pos)                   /*!< ADC_T::CHEN: CHEN0 Mask                 */
N
N#define ADC_CMPR_CMPEN_Pos            (0)                                               /*!< ADC_T::CMPR: CMPEN Position            */
N#define ADC_CMPR_CMPEN_Msk            (0x1ul << ADC_CMPR_CMPEN_Pos)                  /*!< ADC_T::CMPR: CMPEN Mask                */
N
N#define ADC_CMPR_CMPIE_Pos            (1)                                               /*!< ADC_T::CMPR: CMPIE Position            */
N#define ADC_CMPR_CMPIE_Msk            (0x1ul << ADC_CMPR_CMPIE_Pos)                  /*!< ADC_T::CMPR: CMPIE Mask                */
N
N#define ADC_CMPR_CMPCOND_Pos          (2)                                               /*!< ADC_T::CMPR: CMPCOND Position          */
N#define ADC_CMPR_CMPCOND_Msk          (0x1ul << ADC_CMPR_CMPCOND_Pos)                /*!< ADC_T::CMPR: CMPCOND Mask              */
N
N#define ADC_CMPR_CMPCH_Pos            (3)                                               /*!< ADC_T::CMPR: CMPCH Position            */
N#define ADC_CMPR_CMPCH_Msk            (0x1ful << ADC_CMPR_CMPCH_Pos)                 /*!< ADC_T::CMPR: CMPCH Mask                */
N
N#define ADC_CMPR_CMPMATCNT_Pos        (8)                                               /*!< ADC_T::CMPR: CMPMATCNT Position        */
N#define ADC_CMPR_CMPMATCNT_Msk        (0xful << ADC_CMPR_CMPMATCNT_Pos)              /*!< ADC_T::CMPR: CMPMATCNT Mask            */
N
N#define ADC_CMPR_CMPD_Pos             (16)                                              /*!< ADC_T::CMPR: CMPD Position             */
N#define ADC_CMPR_CMPD_Msk             (0xffful << ADC_CMPR_CMPD_Pos)                 /*!< ADC_T::CMPR: CMPD Mask                 */
N
N#define ADC_SR_ADF_Pos                 (0)                                               /*!< ADC_T::SR: ADF Position                 */
N#define ADC_SR_ADF_Msk                 (0x1ul << ADC_SR_ADF_Pos)                       /*!< ADC_T::SR: ADF Mask                     */
N
N#define ADC_SR_CMPF0_Pos               (1)                                               /*!< ADC_T::SR: CMPF0 Position               */
N#define ADC_SR_CMPF0_Msk               (0x1ul << ADC_SR_CMPF0_Pos)                     /*!< ADC_T::SR: CMPF0 Mask                   */
N
N#define ADC_SR_CMPF1_Pos               (2)                                               /*!< ADC_T::SR: CMPF1 Position               */
N#define ADC_SR_CMPF1_Msk               (0x1ul << ADC_SR_CMPF1_Pos)                     /*!< ADC_T::SR: CMPF1 Mask                   */
N
N#define ADC_SR_BUSY_Pos                (3)                                               /*!< ADC_T::SR: BUSY Position                */
N#define ADC_SR_BUSY_Msk                (0x1ul << ADC_SR_BUSY_Pos)                      /*!< ADC_T::SR: BUSY Mask                    */
N
N#define ADC_SR_CHANNEL_Pos             (4)                                               /*!< ADC_T::SR: CHANNEL Position             */
N#define ADC_SR_CHANNEL_Msk             (0x1ful << ADC_SR_CHANNEL_Pos)                  /*!< ADC_T::SR: CHANNEL Mask                 */
N
N#define ADC_SR_INITRDY_Pos             (16)                                              /*!< ADC_T::SR: INITRDY Position             */
N#define ADC_SR_INITRDY_Msk             (0x1ul << ADC_SR_INITRDY_Pos)                   /*!< ADC_T::SR: INITRDY Mask                 */
N
N#define ADC_PDMA_AD_PDMA_Pos           (0)                                               /*!< ADC_T::PDMA: AD_PDMA Position           */
N#define ADC_PDMA_AD_PDMA_Msk           (0xffful << ADC_PDMA_AD_PDMA_Pos)               /*!< ADC_T::PDMA: AD_PDMA Mask               */
N
N#define ADC_PWRCTL_PWUPRDY_Pos           (0)                                               /*!< ADC_T::PWRCTL: PWUPRDY Position           */
N#define ADC_PWRCTL_PWUPRDY_Msk           (0x1ul << ADC_PWRCTL_PWUPRDY_Pos)                 /*!< ADC_T::PWRCTL: PWUPRDY Mask               */
N
N#define ADC_PWRCTL_PWDCALEN_Pos          (1)                                               /*!< ADC_T::PWRCTL: PWDCALEN Position          */
N#define ADC_PWRCTL_PWDCALEN_Msk          (0x1ul << ADC_PWRCTL_PWDCALEN_Pos)                /*!< ADC_T::PWRCTL: PWDCALEN Mask              */
N
N#define ADC_PWRCTL_PWDMOD_Pos            (2)                                               /*!< ADC_T::PWRCTL: PWDMOD Position            */
N#define ADC_PWRCTL_PWDMOD_Msk            (0x3ul << ADC_PWRCTL_PWDMOD_Pos)                  /*!< ADC_T::PWRCTL: PWDMOD Mask                */
N
N#define ADC_CALCTL_CALEN_Pos          (0)                                               /*!< ADC_T::CALCTL: CALEN Position          */
N#define ADC_CALCTL_CALEN_Msk          (0x1ul << ADC_CALCTL_CALEN_Pos)                /*!< ADC_T::CALCTL: CALEN Mask              */
N
N#define ADC_CALCTL_CALSTART_Pos       (1)                                               /*!< ADC_T::CALCTL: CALSTART Position       */
N#define ADC_CALCTL_CALSTART_Msk       (0x1ul << ADC_CALCTL_CALSTART_Pos)             /*!< ADC_T::CALCTL: CALSTART Mask           */
N
N#define ADC_CALCTL_CALDONE_Pos        (2)                                               /*!< ADC_T::CALCTL: CALDONE Position        */
N#define ADC_CALCTL_CALDONE_Msk        (0x1ul << ADC_CALCTL_CALDONE_Pos)              /*!< ADC_T::CALCTL: CALDONE Mask            */
N
N#define ADC_CALCTL_CALSEL_Pos         (3)                                               /*!< ADC_T::CALCTL: CALSEL Position         */
N#define ADC_CALCTL_CALSEL_Msk         (0x1ul << ADC_CALCTL_CALSEL_Pos)               /*!< ADC_T::CALCTL: CALSEL Mask             */
N
N#define ADC_CALWORD_CALWORD_Pos       (0)                                               /*!< ADC_T::CALWORD: CALWORD Position       */
N#define ADC_CALWORD_CALWORD_Msk       (0x7ful << ADC_CALWORD_CALWORD_Pos)            /*!< ADC_T::CALWORD: CALWORD Mask           */
N
N#define ADC_SMPLCNT0_CH0SAMPCNT_Pos    (0)                                               /*!< ADC_T::SMPLCNT0: CH0SAMPCNT Position    */
N#define ADC_SMPLCNT0_CH0SAMPCNT_Msk    (0xful << ADC_SMPLCNT0_CH0SAMPCNT_Pos)          /*!< ADC_T::SMPLCNT0: CH0SAMPCNT Mask        */
N
N#define ADC_SMPLCNT1_CH8SAMPCNT_Pos    (0)                                               /*!< ADC_T::SMPLCNT1: CH8SAMPCNT Position    */
N#define ADC_SMPLCNT1_CH8SAMPCNT_Msk    (0xful << ADC_SMPLCNT1_CH8SAMPCNT_Pos)          /*!< ADC_T::SMPLCNT1: CH8SAMPCNT Mask        */
N
N#define ADC_SMPLCNT1_INTCHSAMPCNT_Pos  (16)                                              /*!< ADC_T::SMPLCNT1: INTCHSAMPCNT Position  */
N#define ADC_SMPLCNT1_INTCHSAMPCNT_Msk  (0xful << ADC_SMPLCNT1_INTCHSAMPCNT_Pos)        /*!< ADC_T::SMPLCNT1: INTCHSAMPCNT Mask      */
N
N/**@}*/ /* ADC_CONST */
N/**@}*/ /* end of ADC register group */
N
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * PWRCTL
N     * ===================================================================================================
N     * Offset: 0x00  System Power Down Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HXT_EN    |HXT Control
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |The bit default value is set by flash controller user configuration register config0 [26].
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |HXT is disabled by default.
N     * |[1]     |LXT_EN    |LXT Control
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |LXT is disabled by default.
N     * |[2]     |HIRC_EN   |HIRC Control
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |HIRC is enabled by default.
N     * |[3]     |LIRC_EN   |LIRC Control
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |LIRC is enabled by default.
N     * |[4]     |WK_DLY    |Wake-Up Delay Counter Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |When chip wakes up from Power-down mode, the clock control will delay 4096 clock cycles to wait HXT stable or 16 clock cycles to wait HIRC stable.
N     * |        |          |0 = Delay clock cycle Disabled.
N     * |        |          |1 = Delay clock cycle Enabled.
N     * |[5]     |PD_WK_IE  |Power-Down Mode Wake-Up Interrupt Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |PD_WK_INT will be set if both PD_WK_IS and PD_WK_IE are high.
N     * |[6]     |PD_EN     |Chip Power-Down Mode Enable Bit
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |When CPU sets this bit, the chip power down is enabled and chip will not enter Power-down mode until CPU sleep mode is also active
N     * |        |          |When chip wakes up from Power-down mode, this bit will be auto cleared.
N     * |        |          |When chip is in Power-down mode, the LDO, HXT and HIRC will be disabled, but LXT and LIRC are not controlled by Power-down mode.
N     * |        |          |When power down, the PLL and system clock (CPU, HCLKx and PCLKx) are also disabled no matter the Clock Source selection.
N     * |        |          |Peripheral clocks are not controlled by this bit, if peripheral Clock Source is from LXT or LIRC.
N     * |        |          |In Power-down mode, flash macro power is ON.
N     * |        |          |0 = Chip operated in Normal mode.
N     * |        |          |1 = Chip power down Enabled.
N     * |[8]     |HXT_SELXT |HXT SELXT
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = High frequency crystal loop back path Disabled. It is used for external oscillator.
N     * |        |          |1 = High frequency crystal loop back path Enabled. It is used for external crystal.
N     * |[9]     |HXT_GAIN  |HXT Gain Control Bit
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Gain control is used to enlarge the gain of crystal to make sure crystal wok normally.
N     * |        |          |If gain control is enabled, crystal will consume more power than gain control off.
N     * |        |          |0 = Gain control Disabled. It means HXT gain is always high.
N     * |        |          |For 16MHz to 24MHz crystal.
N     * |        |          |1 = Gain control Enabled. HXT gain will be high lasting 2ms then low. This is for power saving.
N     * |        |          |For 4MHz to 16MHz crystal.
N     * |[10]    |LXT_SCNT  |LXT Stable Time Control
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Delay 4096 LXT before LXT output.
N     * |        |          |1 = Delay 8192 LXT before LXT output.
N     * |[12:11] |HXT_HF_ST |HXT Frequency Selection
N     * |        |          |Set this bit to meet HXT frequency selection (Recommended)
N     * |        |          |00 = HXT frequency is from 4 MHz to 12 MHz.
N     * |        |          |01 = HXT frequency is from 12 MHz to 16 MHz.
N     * |        |          |10 = HXT frequency is from 16 MHz to 24 MHz.
N     * |        |          |11 = Reserved.
N    */
N    __IO uint32_t PWRCTL;
X    volatile uint32_t PWRCTL;
N
N    /**
N     * AHBCLK
N     * ===================================================================================================
N     * Offset: 0x04  AHB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GPIO_EN   |GPIO Controller Clock Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[1]     |DMA_EN    |DMA Controller Clock Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[3]     |EBI_EN    |EBI Controller Clock Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[4]     |SRAM_EN   |SRAM Controller Clock Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[5]     |TICK_EN   |System Tick Clock Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N    */
N    __IO uint32_t AHBCLK;
X    volatile uint32_t AHBCLK;
N
N    /**
N     * APBCLK
N     * ===================================================================================================
N     * Offset: 0x08  APB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WDT_EN    |Watchdog Timer Clock Enable Control
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |This bit is used to control the WDT APB clock only, The WDT engine Clock Source is from LIRC.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[1]     |RTC_EN    |Real-Time-Clock Clock Enable Control
N     * |        |          |This bit is used to control the RTC APB clock only, The RTC engine Clock Source is from LXT.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[6]     |FDIV_EN   |Frequency Divider Output Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[7]     |SC2_EN    |SmartCard 2 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[8]     |I2C0_EN   |I2C0 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[9]     |I2C1_EN   |I2C1 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[12]    |SPI0_EN   |SPI0 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[13]    |SPI1_EN   |SPI1 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[14]    |SPI2_EN   |SPI2 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[16]    |UART0_EN  |UART0 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[17]    |UART1_EN  |UART1 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[20]    |PWM0_CH01_EN|PWM0 Channel 0 And Channel 1Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[21]    |PWM0_CH23_EN|PWM0 Channel 2 And Channel 3 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[22]    |PWM1_CH01_EN|PWM1 Channel 0 And Channel 1 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[23]    |PWM1_CH23_EN|PWM1 Channel 2 And Channel 3 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[25]    |DAC_EN    |12-Bit DAC Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[26]    |LCD_EN    |LCD Controller Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[27]    |USBD_EN   |USB FS Device Controller Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[29]    |I2S_EN    |I2S Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[30]    |SC0_EN    |SmartCard 0 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[31]    |SC1_EN    |SmartCard 1 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N    */
N    __IO uint32_t APBCLK;
X    volatile uint32_t APBCLK;
N
N    /**
N     * CLKSTATUS
N     * ===================================================================================================
N     * Offset: 0x0C  Clock status monitor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HXT_STB   |HXT Clock Source Stable Flag
N     * |        |          |0 = HXT clock is not stable or not enable.
N     * |        |          |1 = HXT clock is stable.
N     * |[1]     |LXT_STB   |LXT Clock Source Stable Flag
N     * |        |          |0 = LXT clock is not stable or not enable.
N     * |        |          |1 = LXT clock is stable.
N     * |[2]     |PLL_STB   |PLL Clock Source Stable Flag
N     * |        |          |0 = PLL clock is not stable or not enable.
N     * |        |          |1 = PLL clock is stable.
N     * |[3]     |LIRC_STB  |LIRC Clock Source Stable Flag
N     * |        |          |0 = LIRC clock is not stable or not enable.
N     * |        |          |1 = LIRC clock is stable.
N     * |[4]     |HIRC_STB  |HIRC Clock Source Stable Flag
N     * |        |          |0 = HIRC clock is not stable or not enable.
N     * |        |          |1 = HIRC clock is stable.
N     * |[7]     |CLK_SW_FAIL|Clock Switch Fail Flag
N     * |        |          |0 = Clock switch success.
N     * |        |          |1 = Clock switch fail.
N     * |        |          |This bit will be set when target switch Clock Source is not stable. This bit is write 1 clear
N    */
N    __I  uint32_t CLKSTATUS;
X    volatile const  uint32_t CLKSTATUS;
N
N    /**
N     * CLKSEL0
N     * ===================================================================================================
N     * Offset: 0x10  Clock Source Select Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |HCLK_S    |HCLK Clock Source Selection
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Note:
N     * |        |          |Before Clock Source switches, the related clock sources (pre-select and new-select) must be turn on
N     * |        |          |The 3-bit default value is reloaded with the value of CFOSC (Config0[26:24]) in user configuration register in Flash controller by any reset.
N     * |        |          |Therefore the default value is either 000b or 111b.
N     * |        |          |000 = HXT
N     * |        |          |001 = LXT
N     * |        |          |010 = PLL Clock
N     * |        |          |011 = LIRC
N     * |        |          |111 = HIRC
N     * |        |          |Others = Reserved
N    */
N    __IO uint32_t CLKSEL0;
X    volatile uint32_t CLKSEL0;
N
N    /**
N     * CLKSEL1
N     * ===================================================================================================
N     * Offset: 0x14  Clock Source Select Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |UART_S    |UART 0/1 Clock Source Selection (UART0 And UART1 Use The Same Clock Source Selection)
N     * |        |          |00 = HXT
N     * |        |          |01 = LXT
N     * |        |          |10 = PLL Clock
N     * |        |          |11 = HIRC
N     * |[3:2]   |ADC_S     |ADC Clock Source Selection
N     * |        |          |00 = HXT
N     * |        |          |01 = LXT
N     * |        |          |10 = PLL Clock
N     * |        |          |11 = HIRC
N     * |[5:4]   |PWM0_CH01_S|PWM0 Channel 0 And Channel 1 Clock Source Selection
N     * |        |          |PWM0 channel 0 and channel 1 use the same Engine clock source, both of them with the same prescaler
N     * |        |          |00 = HXT
N     * |        |          |01 = LXT
N     * |        |          |10 = HCLK
N     * |        |          |11 = HIRC
N     * |[7:6]   |PWM0_CH23_S|PWM0 Channel 2 And Channel 3 Clock Source Selection
N     * |        |          |PWM0 channel 2 and channel 3 use the same Engine clock source, both of them with the same prescaler
N     * |        |          |00 = HXT
N     * |        |          |01 = LXT
N     * |        |          |10 = HCLK
N     * |        |          |11 = HIRC
N     * |[10:8]  |TMR0_S    |Timer0 Clock Source Selection
N     * |        |          |000 = HXT
N     * |        |          |001 = LXT
N     * |        |          |010 = LIRC
N     * |        |          |011 = External Pin
N     * |        |          |111 = HIRC
N     * |        |          |Others = Reserved
N     * |[14:12] |TMR1_S    |Timer1 Clock Source Selection
N     * |        |          |000 = HXT
N     * |        |          |001 = LXT
N     * |        |          |010 = LIRC
N     * |        |          |011 = External Pin
N     * |        |          |111 = HIRC
N     * |        |          |Others = Reserved
N     * |[18]    |LCD_S     |LCD Clock Source Selection
N     * |        |          |0 = Clock Source from LXT.
N     * |        |          |1 = Reserved.
N    */
N    __IO uint32_t CLKSEL1;
X    volatile uint32_t CLKSEL1;
N
N    /**
N     * CLKSEL2
N     * ===================================================================================================
N     * Offset: 0x18  Clock Source Select Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Selection
N     * |        |          |00 = HXT
N     * |        |          |01 = LXT
N     * |        |          |10 = HCLK
N     * |        |          |11 = HIRC
N     * |[5:4]   |PWM1_CH01_S|PWM1 Channel 0 And Channel 1 Clock Source Selection
N     * |        |          |PWM1 channel 0 and channel 1 use the same Engine clock source, both of them with the same pre-scale
N     * |        |          |00 = HXT
N     * |        |          |01 = LXT
N     * |        |          |10 = HCLK
N     * |        |          |11 = HIRC
N     * |[7:6]   |PWM1_CH23_S|PWM1 Channel 2 And Channel 2 Clock Source Selection
N     * |        |          |PWM1 channel 2 and channel 3 use the same Engine clock source, both of them with the same pre-scale
N     * |        |          |00 = HXT
N     * |        |          |01 = LXT
N     * |        |          |10 = HCLK
N     * |        |          |11 = HIRC
N     * |[10:8]  |TMR2_S    |Timer2 Clock Source Selection
N     * |        |          |000 = HXT
N     * |        |          |001 = LXT
N     * |        |          |010 = LIRC
N     * |        |          |011 = External Pin
N     * |        |          |111 = HIRC
N     * |        |          |Others = Reserved
N     * |[14:12] |TMR3_S    |Timer3 Clock Source Selection
N     * |        |          |000 = HXT
N     * |        |          |001 = LXT
N     * |        |          |010 = LIRC
N     * |        |          |011 = External Pin
N     * |        |          |111 = HIRC
N     * |        |          |Others = Reserved
N     * |[17:16] |I2S_S     |I2S Clock Source Selection
N     * |        |          |00 = HXT
N     * |        |          |01 = PLL Clock
N     * |        |          |10 = HIRC
N     * |        |          |11 = HIRC
N     * |[19:18] |SC_S      |SC Clock Source Selection
N     * |        |          |00 = HXT
N     * |        |          |01 = PLL Clock
N     * |        |          |10 = HIRC
N     * |        |          |11 = HIRC
N     * |        |          |Note: SC0,SC1 and SC2 use the same Clock Source selection but they have different clock divider number.
N     * |[20]    |SPI0_S    |SPI0 Clock Source Selection
N     * |        |          |0 = PLL.
N     * |        |          |1 = HCLK.
N     * |[21]    |SPI1_S    |SPI1 Clock Source Selection
N     * |        |          |0 = PLL.
N     * |        |          |1 = HCLK.
N     * |[22]    |SPI2_S    |SPI2 Clock Source Selection
N     * |        |          |0 = PLL.
N     * |        |          |1 = HCLK.
N    */
N    __IO uint32_t CLKSEL2;
X    volatile uint32_t CLKSEL2;
N
N    /**
N     * CLKDIV0
N     * ===================================================================================================
N     * Offset: 0x1C  Clock Divider Number Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |HCLK_N    |HCLK Clock Divide Number From HCLK Clock Source
N     * |        |          |The HCLK clock frequency = (HCLK Clock Source frequency) / (HCLK_N + 1).
N     * |[7:4]   |USB_N     |USB Clock Divide Number From PLL Clock
N     * |        |          |The USB clock frequency = (PLL frequency ) / (USB_N + 1).
N     * |[11:8]  |UART_N    |UART Clock Divide Number From UART Clock Source
N     * |        |          |The UART clock frequency = (UART Clock Source frequency ) / (UART_N + 1).
N     * |[15:12] |I2S_N     |I2S Clock Divide Number From I2S Clock Source
N     * |        |          |The I2S clock frequency = (I2S Clock Source frequency ) / (I2S_N + 1).
N     * |[23:16] |ADC_N     |ADC Clock Divide Number From ADC Clock Source
N     * |        |          |The ADC clock frequency = (ADC Clock Source frequency ) / (ADC_N + 1).
N     * |[31:28] |SC0_N     |SC 0 Clock Divide Number From SC 0 Clock Source
N     * |        |          |The SC 0 clock frequency = (SC0 Clock Source frequency ) / (SC0_N + 1).
N    */
N    __IO uint32_t CLKDIV0;
X    volatile uint32_t CLKDIV0;
N
N    /**
N     * CLKDIV1
N     * ===================================================================================================
N     * Offset: 0x20  Clock Divider Number Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |SC1_N     |SC 1 Clock Divide Number From SC 1 Clock Source
N     * |        |          |The SC 1 clock frequency = (SC 1 Clock Source frequency ) / (SC1_N + 1).
N     * |[7:4]   |SC2_N     |SC 2 Clock Divide Number From SC2 Clock Source
N     * |        |          |The SC 2 clock frequency = (SC 2 Clock Source frequency ) / (SC2_N + 1).
N    */
N    __IO uint32_t CLKDIV1;
X    volatile uint32_t CLKDIV1;
N
N    /**
N     * PLLCTL
N     * ===================================================================================================
N     * Offset: 0x24  PLL Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |FB_DV     |PLL Feedback Divider Control Pins
N     * |        |          |Refer to the formulas below the table.
N     * |        |          |The range of FB_DV is from 0 to 63.
N     * |[9:8]   |IN_DV     |PLL Input Divider Control Pins
N     * |        |          |Refer to the formulas below the table.
N     * |[12]    |OUT_DV    |PLL Output Divider Control Pins
N     * |        |          |Refer to the formulas below the table. This bit MUST be 0 for PLL output low deviation.
N     * |[16]    |PD        |Power-Down Mode
N     * |        |          |If set the PD_EN bit "1" in PWR_CTL register, the PLL will enter Power-down mode too
N     * |        |          |0 = PLL is in normal mode.
N     * |        |          |1 = PLL is in power-down mode (default).
N     * |[17]    |PLL_SRC   |PLL Source Clock Select
N     * |        |          |0 = PLL source clock from HXT.
N     * |        |          |1 = PLL source clock from HIRC.
N    */
N    __IO uint32_t PLLCTL;
X    volatile uint32_t PLLCTL;
N
N    /**
N     * FRQDIV
N     * ===================================================================================================
N     * Offset: 0x28  Frequency Divider Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
N     * |        |          |The formula of output frequency is
N     * |        |          |Fout = Fin/2^(N+1),.
N     * |        |          |Where Fin is the input clock frequency, Fout is the frequency of divider output clock and N is the 4-bit value of FSEL[3:0].
N     * |[4]     |FDIV_EN   |Frequency Divider Enable Bit
N     * |        |          |0 = Frequency Divider Disabled.
N     * |        |          |1 = Frequency Divider Enabled.
N    */
N    __IO uint32_t FRQDIV;
X    volatile uint32_t FRQDIV;
N
N    /**
N     * MCLKO
N     * ===================================================================================================
N     * Offset: 0x2C  Module Clock Output Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MCLK_SEL  |Module Clock Output Source Selection (PC.0)
N     * |        |          |000000 = ISP_CLK
N     * |        |          |000001 = HIRC
N     * |        |          |000010 = HXT
N     * |        |          |000011 = LXT
N     * |        |          |000100 = LIRC
N     * |        |          |000101 = PLL output
N     * |        |          |000110 = PLL input
N     * |        |          |000111 = System Tick
N     * |        |          |001000 = HCLK clock
N     * |        |          |001010 = PCLK clock
N     * |        |          |100000 = TMR0_CLK
N     * |        |          |100001 = TMR1_CLK
N     * |        |          |100010 = UART0_CLK
N     * |        |          |100011 = USB_CLK
N     * |        |          |100100 = ADC_CLK
N     * |        |          |100101 = WDT_CLK
N     * |        |          |100110 = PWM0_CH01_CLK
N     * |        |          |100111 = PWM0_CH32_CLK
N     * |        |          |101001 = LCD_CLK
N     * |        |          |111000 = TMR2_CLK
N     * |        |          |111001 = TMR3_CLK
N     * |        |          |111010 = UART1_CLK
N     * |        |          |111011 = PWM1_CH01_CLK
N     * |        |          |111100 = PWM1_CH23_CLK
N     * |        |          |111101 = I&sup2;S_CLK
N     * |        |          |111110 = SC0_CLK
N     * |        |          |111111 = SC1_CLK
N     * |[7]     |MCLK_EN   |Module Clock Output Enable
N     * |        |          |User can get the module clock output from PC.0 pin via choosing the clock source in the MCLK_SEL bit field and then setting MCLK_EN bit to 1.
N     * |        |          |0 = Module clock output Disabled.
N     * |        |          |1 = Module clock output Enabled.
N     * |        |          |Note: If this bit is enabled, PC.0 will be configured to module clock output and the setting of PC0_MFP will be ineffective
N    */
N    __IO uint32_t MCLKO;
X    volatile uint32_t MCLKO;
N
N    /**
N     * WK_INTSTS
N     * ===================================================================================================
N     * Offset: 0x30  Wake-up interrupt status
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PD_WK_IS  |Wake-Up Interrupt Status In Chip Power-Down Mode
N     * |        |          |This bit indicates that some event resumes chip from Power-down mode
N     * |        |          |The status is set if external interrupts, UART, GPIO, RTC, USB, SPI, Timer, WDT, and BOD wake-up occurred.
N     * |        |          |Write 1 to clear this bit.
N    */
N    __IO  uint32_t WK_INTSTS;
X    volatile  uint32_t WK_INTSTS;
N
N} CLK_T;
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N#define CLK_PWRCTL_HXT_EN_Pos            (0)                                               /*!< CLK_T::PWRCTL: HXT_EN Position            */
N#define CLK_PWRCTL_HXT_EN_Msk            (0x1ul << CLK_PWRCTL_HXT_EN_Pos)                  /*!< CLK_T::PWRCTL: HXT_EN Mask                */
N
N#define CLK_PWRCTL_LXT_EN_Pos            (1)                                               /*!< CLK_T::PWRCTL: LXT_EN Position            */
N#define CLK_PWRCTL_LXT_EN_Msk            (0x1ul << CLK_PWRCTL_LXT_EN_Pos)                  /*!< CLK_T::PWRCTL: LXT_EN Mask                */
N
N#define CLK_PWRCTL_HIRC_EN_Pos           (2)                                               /*!< CLK_T::PWRCTL: HIRC_EN Position           */
N#define CLK_PWRCTL_HIRC_EN_Msk           (0x1ul << CLK_PWRCTL_HIRC_EN_Pos)                 /*!< CLK_T::PWRCTL: HIRC_EN Mask               */
N
N#define CLK_PWRCTL_LIRC_EN_Pos           (3)                                               /*!< CLK_T::PWRCTL: LIRC_EN Position           */
N#define CLK_PWRCTL_LIRC_EN_Msk           (0x1ul << CLK_PWRCTL_LIRC_EN_Pos)                 /*!< CLK_T::PWRCTL: LIRC_EN Mask               */
N
N#define CLK_PWRCTL_WK_DLY_Pos            (4)                                               /*!< CLK_T::PWRCTL: WK_DLY Position            */
N#define CLK_PWRCTL_WK_DLY_Msk            (0x1ul << CLK_PWRCTL_WK_DLY_Pos)                  /*!< CLK_T::PWRCTL: WK_DLY Mask                */
N
N#define CLK_PWRCTL_PD_WK_IE_Pos          (5)                                               /*!< CLK_T::PWRCTL: PD_WK_IE Position          */
N#define CLK_PWRCTL_PD_WK_IE_Msk          (0x1ul << CLK_PWRCTL_PD_WK_IE_Pos)                /*!< CLK_T::PWRCTL: PD_WK_IE Mask              */
N
N#define CLK_PWRCTL_PD_EN_Pos             (6)                                               /*!< CLK_T::PWRCTL: PD_EN Position             */
N#define CLK_PWRCTL_PD_EN_Msk             (0x1ul << CLK_PWRCTL_PD_EN_Pos)                   /*!< CLK_T::PWRCTL: PD_EN Mask                 */
N
N#define CLK_PWRCTL_HXT_SELXT_Pos         (8)                                               /*!< CLK_T::PWRCTL: HXT_SELXT Position         */
N#define CLK_PWRCTL_HXT_SELXT_Msk         (0x1ul << CLK_PWRCTL_HXT_SELXT_Pos)               /*!< CLK_T::PWRCTL: HXT_SELXT Mask             */
N
N#define CLK_PWRCTL_HXT_GAIN_Pos          (9)                                               /*!< CLK_T::PWRCTL: HXT_GAIN Position          */
N#define CLK_PWRCTL_HXT_GAIN_Msk          (0x1ul << CLK_PWRCTL_HXT_GAIN_Pos)                /*!< CLK_T::PWRCTL: HXT_GAIN Mask              */
N
N#define CLK_PWRCTL_LXT_SCNT_Pos          (10)                                              /*!< CLK_T::PWRCTL: LXT_SCNT Position          */
N#define CLK_PWRCTL_LXT_SCNT_Msk          (0x1ul << CLK_PWRCTL_LXT_SCNT_Pos)                /*!< CLK_T::PWRCTL: LXT_SCNT Mask              */
N
N#define CLK_PWRCTL_HXT_HF_ST_Pos         (11)                                              /*!< CLK_T::PWRCTL: HXT_HF_ST Position         */
N#define CLK_PWRCTL_HXT_HF_ST_Msk         (0x3ul << CLK_PWRCTL_HXT_HF_ST_Pos)               /*!< CLK_T::PWRCTL: HXT_HF_ST Mask             */
N
N#define CLK_AHBCLK_GPIO_EN_Pos           (0)                                               /*!< CLK_T::AHBCLK: GPIO_EN Position           */
N#define CLK_AHBCLK_GPIO_EN_Msk           (0x1ul << CLK_AHBCLK_GPIO_EN_Pos)                 /*!< CLK_T::AHBCLK: GPIO_EN Mask               */
N
N#define CLK_AHBCLK_DMA_EN_Pos            (1)                                               /*!< CLK_T::AHBCLK: DMA_EN Position            */
N#define CLK_AHBCLK_DMA_EN_Msk            (0x1ul << CLK_AHBCLK_DMA_EN_Pos)                  /*!< CLK_T::AHBCLK: DMA_EN Mask                */
N
N#define CLK_AHBCLK_ISP_EN_Pos            (2)                                               /*!< CLK_T::AHBCLK: ISP_EN Position            */
N#define CLK_AHBCLK_ISP_EN_Msk            (0x1ul << CLK_AHBCLK_ISP_EN_Pos)                  /*!< CLK_T::AHBCLK: ISP_EN Mask                */
N
N#define CLK_AHBCLK_EBI_EN_Pos            (3)                                               /*!< CLK_T::AHBCLK: EBI_EN Position            */
N#define CLK_AHBCLK_EBI_EN_Msk            (0x1ul << CLK_AHBCLK_EBI_EN_Pos)                  /*!< CLK_T::AHBCLK: EBI_EN Mask                */
N
N#define CLK_AHBCLK_SRAM_EN_Pos           (4)                                               /*!< CLK_T::AHBCLK: SRAM_EN Position           */
N#define CLK_AHBCLK_SRAM_EN_Msk           (0x1ul << CLK_AHBCLK_SRAM_EN_Pos)                 /*!< CLK_T::AHBCLK: SRAM_EN Mask               */
N
N#define CLK_AHBCLK_TICK_EN_Pos           (5)                                               /*!< CLK_T::AHBCLK: TICK_EN Position           */
N#define CLK_AHBCLK_TICK_EN_Msk           (0x1ul << CLK_AHBCLK_TICK_EN_Pos)                 /*!< CLK_T::AHBCLK: TICK_EN Mask               */
N
N#define CLK_APBCLK_WDT_EN_Pos            (0)                                               /*!< CLK_T::APBCLK: WDT_EN Position            */
N#define CLK_APBCLK_WDT_EN_Msk            (0x1ul << CLK_APBCLK_WDT_EN_Pos)                  /*!< CLK_T::APBCLK: WDT_EN Mask                */
N
N#define CLK_APBCLK_RTC_EN_Pos            (1)                                               /*!< CLK_T::APBCLK: RTC_EN Position            */
N#define CLK_APBCLK_RTC_EN_Msk            (0x1ul << CLK_APBCLK_RTC_EN_Pos)                  /*!< CLK_T::APBCLK: RTC_EN Mask                */
N
N#define CLK_APBCLK_TMR0_EN_Pos           (2)                                               /*!< CLK_T::APBCLK: TMR0_EN Position           */
N#define CLK_APBCLK_TMR0_EN_Msk           (0x1ul << CLK_APBCLK_TMR0_EN_Pos)                 /*!< CLK_T::APBCLK: TMR0_EN Mask               */
N
N#define CLK_APBCLK_TMR1_EN_Pos           (3)                                               /*!< CLK_T::APBCLK: TMR1_EN Position           */
N#define CLK_APBCLK_TMR1_EN_Msk           (0x1ul << CLK_APBCLK_TMR1_EN_Pos)                 /*!< CLK_T::APBCLK: TMR1_EN Mask               */
N
N#define CLK_APBCLK_TMR2_EN_Pos           (4)                                               /*!< CLK_T::APBCLK: TMR2_EN Position           */
N#define CLK_APBCLK_TMR2_EN_Msk           (0x1ul << CLK_APBCLK_TMR2_EN_Pos)                 /*!< CLK_T::APBCLK: TMR2_EN Mask               */
N
N#define CLK_APBCLK_TMR3_EN_Pos           (5)                                               /*!< CLK_T::APBCLK: TMR3_EN Position           */
N#define CLK_APBCLK_TMR3_EN_Msk           (0x1ul << CLK_APBCLK_TMR3_EN_Pos)                 /*!< CLK_T::APBCLK: TMR3_EN Mask               */
N
N#define CLK_APBCLK_FDIV_EN_Pos           (6)                                               /*!< CLK_T::APBCLK: FDIV_EN Position           */
N#define CLK_APBCLK_FDIV_EN_Msk           (0x1ul << CLK_APBCLK_FDIV_EN_Pos)                 /*!< CLK_T::APBCLK: FDIV_EN Mask               */
N
N#define CLK_APBCLK_SC2_EN_Pos            (7)                                               /*!< CLK_T::APBCLK: SC2_EN Position            */
N#define CLK_APBCLK_SC2_EN_Msk            (0x1ul << CLK_APBCLK_SC2_EN_Pos)                  /*!< CLK_T::APBCLK: SC2_EN Mask                */
N
N#define CLK_APBCLK_I2C0_EN_Pos           (8)                                               /*!< CLK_T::APBCLK: I2C0_EN Position           */
N#define CLK_APBCLK_I2C0_EN_Msk           (0x1ul << CLK_APBCLK_I2C0_EN_Pos)                 /*!< CLK_T::APBCLK: I2C0_EN Mask               */
N
N#define CLK_APBCLK_I2C1_EN_Pos           (9)                                               /*!< CLK_T::APBCLK: I2C1_EN Position           */
N#define CLK_APBCLK_I2C1_EN_Msk           (0x1ul << CLK_APBCLK_I2C1_EN_Pos)                 /*!< CLK_T::APBCLK: I2C1_EN Mask               */
N
N#define CLK_APBCLK_SPI0_EN_Pos           (12)                                              /*!< CLK_T::APBCLK: SPI0_EN Position           */
N#define CLK_APBCLK_SPI0_EN_Msk           (0x1ul << CLK_APBCLK_SPI0_EN_Pos)                 /*!< CLK_T::APBCLK: SPI0_EN Mask               */
N
N#define CLK_APBCLK_SPI1_EN_Pos           (13)                                              /*!< CLK_T::APBCLK: SPI1_EN Position           */
N#define CLK_APBCLK_SPI1_EN_Msk           (0x1ul << CLK_APBCLK_SPI1_EN_Pos)                 /*!< CLK_T::APBCLK: SPI1_EN Mask               */
N
N#define CLK_APBCLK_SPI2_EN_Pos           (14)                                              /*!< CLK_T::APBCLK: SPI2_EN Position           */
N#define CLK_APBCLK_SPI2_EN_Msk           (0x1ul << CLK_APBCLK_SPI2_EN_Pos)                 /*!< CLK_T::APBCLK: SPI2_EN Mask               */
N
N#define CLK_APBCLK_UART0_EN_Pos          (16)                                              /*!< CLK_T::APBCLK: UART0_EN Position          */
N#define CLK_APBCLK_UART0_EN_Msk          (0x1ul << CLK_APBCLK_UART0_EN_Pos)                /*!< CLK_T::APBCLK: UART0_EN Mask              */
N
N#define CLK_APBCLK_UART1_EN_Pos          (17)                                              /*!< CLK_T::APBCLK: UART1_EN Position          */
N#define CLK_APBCLK_UART1_EN_Msk          (0x1ul << CLK_APBCLK_UART1_EN_Pos)                /*!< CLK_T::APBCLK: UART1_EN Mask              */
N
N#define CLK_APBCLK_PWM0_CH01_EN_Pos      (20)                                              /*!< CLK_T::APBCLK: PWM0_CH01_EN Position      */
N#define CLK_APBCLK_PWM0_CH01_EN_Msk      (0x1ul << CLK_APBCLK_PWM0_CH01_EN_Pos)            /*!< CLK_T::APBCLK: PWM0_CH01_EN Mask          */
N
N#define CLK_APBCLK_PWM0_CH23_EN_Pos      (21)                                              /*!< CLK_T::APBCLK: PWM0_CH23_EN Position      */
N#define CLK_APBCLK_PWM0_CH23_EN_Msk      (0x1ul << CLK_APBCLK_PWM0_CH23_EN_Pos)            /*!< CLK_T::APBCLK: PWM0_CH23_EN Mask          */
N
N#define CLK_APBCLK_PWM1_CH01_EN_Pos      (22)                                              /*!< CLK_T::APBCLK: PWM1_CH01_EN Position      */
N#define CLK_APBCLK_PWM1_CH01_EN_Msk      (0x1ul << CLK_APBCLK_PWM1_CH01_EN_Pos)            /*!< CLK_T::APBCLK: PWM1_CH01_EN Mask          */
N
N#define CLK_APBCLK_PWM1_CH23_EN_Pos      (23)                                              /*!< CLK_T::APBCLK: PWM1_CH23_EN Position      */
N#define CLK_APBCLK_PWM1_CH23_EN_Msk      (0x1ul << CLK_APBCLK_PWM1_CH23_EN_Pos)            /*!< CLK_T::APBCLK: PWM1_CH23_EN Mask          */
N
N#define CLK_APBCLK_DAC_EN_Pos            (25)                                              /*!< CLK_T::APBCLK: DAC_EN Position            */
N#define CLK_APBCLK_DAC_EN_Msk            (0x1ul << CLK_APBCLK_DAC_EN_Pos)                  /*!< CLK_T::APBCLK: DAC_EN Mask                */
N
N#define CLK_APBCLK_LCD_EN_Pos            (26)                                              /*!< CLK_T::APBCLK: LCD_EN Position            */
N#define CLK_APBCLK_LCD_EN_Msk            (0x1ul << CLK_APBCLK_LCD_EN_Pos)                  /*!< CLK_T::APBCLK: LCD_EN Mask                */
N
N#define CLK_APBCLK_USBD_EN_Pos           (27)                                              /*!< CLK_T::APBCLK: USBD_EN Position           */
N#define CLK_APBCLK_USBD_EN_Msk           (0x1ul << CLK_APBCLK_USBD_EN_Pos)                 /*!< CLK_T::APBCLK: USBD_EN Mask               */
N
N#define CLK_APBCLK_ADC_EN_Pos            (28)                                              /*!< CLK_T::APBCLK: ADC_EN Position            */
N#define CLK_APBCLK_ADC_EN_Msk            (0x1ul << CLK_APBCLK_ADC_EN_Pos)                  /*!< CLK_T::APBCLK: ADC_EN Mask                */
N
N#define CLK_APBCLK_I2S_EN_Pos            (29)                                              /*!< CLK_T::APBCLK: I2S_EN Position            */
N#define CLK_APBCLK_I2S_EN_Msk            (0x1ul << CLK_APBCLK_I2S_EN_Pos)                  /*!< CLK_T::APBCLK: I2S_EN Mask                */
N
N#define CLK_APBCLK_SC0_EN_Pos            (30)                                              /*!< CLK_T::APBCLK: SC0_EN Position            */
N#define CLK_APBCLK_SC0_EN_Msk            (0x1ul << CLK_APBCLK_SC0_EN_Pos)                  /*!< CLK_T::APBCLK: SC0_EN Mask                */
N
N#define CLK_APBCLK_SC1_EN_Pos            (31)                                              /*!< CLK_T::APBCLK: SC1_EN Position            */
N#define CLK_APBCLK_SC1_EN_Msk            (0x1ul << CLK_APBCLK_SC1_EN_Pos)                  /*!< CLK_T::APBCLK: SC1_EN Mask                */
N
N#define CLK_CLKSTATUS_HXT_STB_Pos        (0)                                               /*!< CLK_T::CLKSTATUS: HXT_STB Position        */
N#define CLK_CLKSTATUS_HXT_STB_Msk        (0x1ul << CLK_CLKSTATUS_HXT_STB_Pos)              /*!< CLK_T::CLKSTATUS: HXT_STB Mask            */
N
N#define CLK_CLKSTATUS_LXT_STB_Pos        (1)                                               /*!< CLK_T::CLKSTATUS: LXT_STB Position        */
N#define CLK_CLKSTATUS_LXT_STB_Msk        (0x1ul << CLK_CLKSTATUS_LXT_STB_Pos)              /*!< CLK_T::CLKSTATUS: LXT_STB Mask            */
N
N#define CLK_CLKSTATUS_PLL_STB_Pos        (2)                                               /*!< CLK_T::CLKSTATUS: PLL_STB Position        */
N#define CLK_CLKSTATUS_PLL_STB_Msk        (0x1ul << CLK_CLKSTATUS_PLL_STB_Pos)              /*!< CLK_T::CLKSTATUS: PLL_STB Mask            */
N
N#define CLK_CLKSTATUS_LIRC_STB_Pos       (3)                                               /*!< CLK_T::CLKSTATUS: LIRC_STB Position       */
N#define CLK_CLKSTATUS_LIRC_STB_Msk       (0x1ul << CLK_CLKSTATUS_LIRC_STB_Pos)             /*!< CLK_T::CLKSTATUS: LIRC_STB Mask           */
N
N#define CLK_CLKSTATUS_HIRC_STB_Pos       (4)                                               /*!< CLK_T::CLKSTATUS: HIRC_STB Position       */
N#define CLK_CLKSTATUS_HIRC_STB_Msk       (0x1ul << CLK_CLKSTATUS_HIRC_STB_Pos)             /*!< CLK_T::CLKSTATUS: HIRC_STB Mask           */
N
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos    (7)                                               /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Position    */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk    (0x1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)          /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Mask        */
N
N#define CLK_CLKSEL0_HCLK_S_Pos           (0)                                               /*!< CLK_T::CLKSEL0: HCLK_S Position           */
N#define CLK_CLKSEL0_HCLK_S_Msk           (0x7ul << CLK_CLKSEL0_HCLK_S_Pos)                 /*!< CLK_T::CLKSEL0: HCLK_S Mask               */
N
N#define CLK_CLKSEL1_UART_S_Pos           (0)                                               /*!< CLK_T::CLKSEL1: UART_S Position           */
N#define CLK_CLKSEL1_UART_S_Msk           (0x3ul << CLK_CLKSEL1_UART_S_Pos)                 /*!< CLK_T::CLKSEL1: UART_S Mask               */
N
N#define CLK_CLKSEL1_ADC_S_Pos            (2)                                               /*!< CLK_T::CLKSEL1: ADC_S Position            */
N#define CLK_CLKSEL1_ADC_S_Msk            (0x3ul << CLK_CLKSEL1_ADC_S_Pos)                  /*!< CLK_T::CLKSEL1: ADC_S Mask                */
N
N#define CLK_CLKSEL1_PWM0_CH01_S_Pos      (4)                                               /*!< CLK_T::CLKSEL1: PWM0_CH01_S Position      */
N#define CLK_CLKSEL1_PWM0_CH01_S_Msk      (0x3ul << CLK_CLKSEL1_PWM0_CH01_S_Pos)            /*!< CLK_T::CLKSEL1: PWM0_CH01_S Mask          */
N
N#define CLK_CLKSEL1_PWM0_CH23_S_Pos      (6)                                               /*!< CLK_T::CLKSEL1: PWM0_CH23_S Position      */
N#define CLK_CLKSEL1_PWM0_CH23_S_Msk      (0x3ul << CLK_CLKSEL1_PWM0_CH23_S_Pos)            /*!< CLK_T::CLKSEL1: PWM0_CH23_S Mask          */
N
N#define CLK_CLKSEL1_TMR0_S_Pos           (8)                                               /*!< CLK_T::CLKSEL1: TMR0_S Position           */
N#define CLK_CLKSEL1_TMR0_S_Msk           (0x7ul << CLK_CLKSEL1_TMR0_S_Pos)                 /*!< CLK_T::CLKSEL1: TMR0_S Mask               */
N
N#define CLK_CLKSEL1_TMR1_S_Pos           (12)                                              /*!< CLK_T::CLKSEL1: TMR1_S Position           */
N#define CLK_CLKSEL1_TMR1_S_Msk           (0x7ul << CLK_CLKSEL1_TMR1_S_Pos)                 /*!< CLK_T::CLKSEL1: TMR1_S Mask               */
N
N#define CLK_CLKSEL1_LCD_S_Pos            (18)                                              /*!< CLK_T::CLKSEL1: LCD_S Position            */
N#define CLK_CLKSEL1_LCD_S_Msk            (0x1ul << CLK_CLKSEL1_LCD_S_Pos)                  /*!< CLK_T::CLKSEL1: LCD_S Mask                */
N
N#define CLK_CLKSEL2_FRQDIV_S_Pos         (2)                                               /*!< CLK_T::CLKSEL2: FRQDIV_S Position         */
N#define CLK_CLKSEL2_FRQDIV_S_Msk         (0x3ul << CLK_CLKSEL2_FRQDIV_S_Pos)               /*!< CLK_T::CLKSEL2: FRQDIV_S Mask             */
N
N#define CLK_CLKSEL2_PWM1_CH01_S_Pos      (4)                                               /*!< CLK_T::CLKSEL2: PWM1_CH01_S Position      */
N#define CLK_CLKSEL2_PWM1_CH01_S_Msk      (0x3ul << CLK_CLKSEL2_PWM1_CH01_S_Pos)            /*!< CLK_T::CLKSEL2: PWM1_CH01_S Mask          */
N
N#define CLK_CLKSEL2_PWM1_CH23_S_Pos      (6)                                               /*!< CLK_T::CLKSEL2: PWM1_CH23_S Position      */
N#define CLK_CLKSEL2_PWM1_CH23_S_Msk      (0x3ul << CLK_CLKSEL2_PWM1_CH23_S_Pos)            /*!< CLK_T::CLKSEL2: PWM1_CH23_S Mask          */
N
N#define CLK_CLKSEL2_TMR2_S_Pos           (8)                                               /*!< CLK_T::CLKSEL2: TMR2_S Position           */
N#define CLK_CLKSEL2_TMR2_S_Msk           (0x7ul << CLK_CLKSEL2_TMR2_S_Pos)                 /*!< CLK_T::CLKSEL2: TMR2_S Mask               */
N
N#define CLK_CLKSEL2_TMR3_S_Pos           (12)                                              /*!< CLK_T::CLKSEL2: TMR3_S Position           */
N#define CLK_CLKSEL2_TMR3_S_Msk           (0x7ul << CLK_CLKSEL2_TMR3_S_Pos)                 /*!< CLK_T::CLKSEL2: TMR3_S Mask               */
N
N#define CLK_CLKSEL2_I2S_S_Pos            (16)                                              /*!< CLK_T::CLKSEL2: I2S_S Position            */
N#define CLK_CLKSEL2_I2S_S_Msk            (0x3ul << CLK_CLKSEL2_I2S_S_Pos)                  /*!< CLK_T::CLKSEL2: I2S_S Mask                */
N
N#define CLK_CLKSEL2_SC_S_Pos             (18)                                              /*!< CLK_T::CLKSEL2: SC_S Position             */
N#define CLK_CLKSEL2_SC_S_Msk             (0x3ul << CLK_CLKSEL2_SC_S_Pos)                   /*!< CLK_T::CLKSEL2: SC_S Mask                 */
N
N#define CLK_CLKSEL2_SPI0_S_Pos           (20)                                              /*!< CLK_T::CLKSEL2: SPI0_S Position           */
N#define CLK_CLKSEL2_SPI0_S_Msk           (0x1ul << CLK_CLKSEL2_SPI0_S_Pos)                 /*!< CLK_T::CLKSEL2: SPI0_S Mask               */
N
N#define CLK_CLKSEL2_SPI1_S_Pos           (21)                                              /*!< CLK_T::CLKSEL2: SPI1_S Position           */
N#define CLK_CLKSEL2_SPI1_S_Msk           (0x1ul << CLK_CLKSEL2_SPI1_S_Pos)                 /*!< CLK_T::CLKSEL2: SPI1_S Mask               */
N
N#define CLK_CLKSEL2_SPI2_S_Pos           (22)                                              /*!< CLK_T::CLKSEL2: SPI2_S Position           */
N#define CLK_CLKSEL2_SPI2_S_Msk           (0x1ul << CLK_CLKSEL2_SPI2_S_Pos)                 /*!< CLK_T::CLKSEL2: SPI2_S Mask               */
N
N#define CLK_CLKDIV0_HCLK_N_Pos           (0)                                               /*!< CLK_T::CLKDIV0: HCLK_N Position           */
N#define CLK_CLKDIV0_HCLK_N_Msk           (0xful << CLK_CLKDIV0_HCLK_N_Pos)                 /*!< CLK_T::CLKDIV0: HCLK_N Mask               */
N
N#define CLK_CLKDIV0_USB_N_Pos            (4)                                               /*!< CLK_T::CLKDIV0: USB_N Position            */
N#define CLK_CLKDIV0_USB_N_Msk            (0xful << CLK_CLKDIV0_USB_N_Pos)                  /*!< CLK_T::CLKDIV0: USB_N Mask                */
N
N#define CLK_CLKDIV0_UART_N_Pos           (8)                                               /*!< CLK_T::CLKDIV0: UART_N Position           */
N#define CLK_CLKDIV0_UART_N_Msk           (0xful << CLK_CLKDIV0_UART_N_Pos)                 /*!< CLK_T::CLKDIV0: UART_N Mask               */
N
N#define CLK_CLKDIV0_I2S_N_Pos            (12)                                              /*!< CLK_T::CLKDIV0: I2S_N Position            */
N#define CLK_CLKDIV0_I2S_N_Msk            (0xful << CLK_CLKDIV0_I2S_N_Pos)                  /*!< CLK_T::CLKDIV0: I2S_N Mask                */
N
N#define CLK_CLKDIV0_ADC_N_Pos            (16)                                              /*!< CLK_T::CLKDIV0: ADC_N Position            */
N#define CLK_CLKDIV0_ADC_N_Msk            (0xfful << CLK_CLKDIV0_ADC_N_Pos)                 /*!< CLK_T::CLKDIV0: ADC_N Mask                */
N
N#define CLK_CLKDIV0_SC0_N_Pos            (28)                                              /*!< CLK_T::CLKDIV0: SC0_N Position            */
N#define CLK_CLKDIV0_SC0_N_Msk            (0xful << CLK_CLKDIV0_SC0_N_Pos)                  /*!< CLK_T::CLKDIV0: SC0_N Mask                */
N
N#define CLK_CLKDIV1_SC1_N_Pos            (0)                                               /*!< CLK_T::CLKDIV1: SC1_N Position            */
N#define CLK_CLKDIV1_SC1_N_Msk            (0xful << CLK_CLKDIV1_SC1_N_Pos)                  /*!< CLK_T::CLKDIV1: SC1_N Mask                */
N
N#define CLK_CLKDIV1_SC2_N_Pos            (4)                                               /*!< CLK_T::CLKDIV1: SC2_N Position            */
N#define CLK_CLKDIV1_SC2_N_Msk            (0xful << CLK_CLKDIV1_SC2_N_Pos)                  /*!< CLK_T::CLKDIV1: SC2_N Mask                */
N
N#define CLK_PLLCTL_FB_DV_Pos             (0)                                               /*!< CLK_T::PLLCTL: FB_DV Position             */
N#define CLK_PLLCTL_FB_DV_Msk             (0x3ful << CLK_PLLCTL_FB_DV_Pos)                  /*!< CLK_T::PLLCTL: FB_DV Mask                 */
N
N#define CLK_PLLCTL_IN_DV_Pos             (8)                                               /*!< CLK_T::PLLCTL: IN_DV Position             */
N#define CLK_PLLCTL_IN_DV_Msk             (0x3ul << CLK_PLLCTL_IN_DV_Pos)                   /*!< CLK_T::PLLCTL: IN_DV Mask                 */
N
N#define CLK_PLLCTL_OUT_DV_Pos            (12)                                              /*!< CLK_T::PLLCTL: OUT_DV Position            */
N#define CLK_PLLCTL_OUT_DV_Msk            (0x1ul << CLK_PLLCTL_OUT_DV_Pos)                  /*!< CLK_T::PLLCTL: OUT_DV Mask                */
N
N#define CLK_PLLCTL_PD_Pos                (16)                                              /*!< CLK_T::PLLCTL: PD Position                */
N#define CLK_PLLCTL_PD_Msk                (0x1ul << CLK_PLLCTL_PD_Pos)                      /*!< CLK_T::PLLCTL: PD Mask                    */
N
N#define CLK_PLLCTL_PLL_SRC_Pos           (17)                                              /*!< CLK_T::PLLCTL: PLL_SRC Position           */
N#define CLK_PLLCTL_PLL_SRC_Msk           (0x1ul << CLK_PLLCTL_PLL_SRC_Pos)                 /*!< CLK_T::PLLCTL: PLL_SRC Mask               */
N
N#define CLK_FRQDIV_FSEL_Pos              (0)                                               /*!< CLK_T::FRQDIV: FSEL Position              */
N#define CLK_FRQDIV_FSEL_Msk              (0xful << CLK_FRQDIV_FSEL_Pos)                    /*!< CLK_T::FRQDIV: FSEL Mask                  */
N
N#define CLK_FRQDIV_FDIV_EN_Pos           (4)                                               /*!< CLK_T::FRQDIV: FDIV_EN Position           */
N#define CLK_FRQDIV_FDIV_EN_Msk           (0x1ul << CLK_FRQDIV_FDIV_EN_Pos)                 /*!< CLK_T::FRQDIV: FDIV_EN Mask               */
N
N#define CLK_MCLKO_MCLK_SEL_Pos           (0)                                               /*!< CLK_T::MCLKO: MCLK_SEL Position           */
N#define CLK_MCLKO_MCLK_SEL_Msk           (0x3ful << CLK_MCLKO_MCLK_SEL_Pos)                /*!< CLK_T::MCLKO: MCLK_SEL Mask               */
N
N#define CLK_MCLKO_MCLK_EN_Pos            (7)                                               /*!< CLK_T::MCLKO: MCLK_EN Position            */
N#define CLK_MCLKO_MCLK_EN_Msk            (0x1ul << CLK_MCLKO_MCLK_EN_Pos)                  /*!< CLK_T::MCLKO: MCLK_EN Mask                */
N
N#define CLK_WK_INTSTS_PD_WK_IS_Pos       (0)                                               /*!< CLK_T::WK_INTSTS: PD_WK_IS Position          */
N#define CLK_WK_INTSTS_PD_WK_IS_Msk       (0x1ul << CLK_WK_INTSTS_PD_WK_IS_Pos)             /*!< CLK_T::WK_INTSTS: PD_WK_IS Mask              */
N
N/**@}*/ /* CLK_CONST */
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- Digital to Analog Converter -------------------------*/
N/**
N    @addtogroup DAC Digital to Analog Converter(DAC)
N    Memory Mapped Structure for DAC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * CTL0
N     * ===================================================================================================
N     * Offset: 0x00  DAC0 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DACEN     |DAC Enable
N     * |        |          |0 = Power down DAC.
N     * |        |          |1 = Power on DAC.
N     * |        |          |Note: When DAC is powered on, DAC will automatically start conversion after waiting for DACPWONSTBCNT+1 PCLK cycle
N     * |[1]     |DACIE     |DAC Interrupt Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[6:4]   |DACLSEL   |DAC Load Selection
N     * |        |          |Select the load trigger for the DAC latch.
N     * |        |          |000 = DAC latch loads when DACx_DAT written
N     * |        |          |001 = PDMA ACK
N     * |        |          |010 = Rising edge of TMR0
N     * |        |          |011 = Rising edge of TMR1
N     * |        |          |100 = Rising edge of TMR2
N     * |        |          |101 = Rising edge of TMR3
N     * |        |          |Others = Reserved
N     * |[21:8]  |DACPWONSTBCNT|DACPWONSTBCNT
N     * |        |          |DAC need 6 us to be stable after DAC is power on from power down state.
N     * |        |          |This field controls a internal counter (in PCLK unit) to guarantee DAC stable time requirement.
N    */
N    __IO uint32_t CTL0;
X    volatile uint32_t CTL0;
N
N    /**
N     * DATA0
N     * ===================================================================================================
N     * Offset: 0x04  DAC0 Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |DACData   |DAC data
N    */
N    __IO uint32_t DATA0;
X    volatile uint32_t DATA0;
N
N    /**
N     * STS0
N     * ===================================================================================================
N     * Offset: 0x08  DAC0 Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DACIFG    |DAC Interrupt Flag
N     * |        |          |0 = No interrupt pending.
N     * |        |          |1 = Interrupt pending.
N     * |        |          |Note: This bit is read only.
N     * |[1]     |DACSTFG   |DAC Start Flag
N     * |        |          |0 = DAC is not start yet.
N     * |        |          |1 = DAC has been started.
N     * |        |          |Note: this bit is read only.
N     * |[2]     |BUSY      |BUSY Bit
N     * |        |          |0 = DAC is not busy.
N     * |        |          |1 = DAC is busy.
N    */
N    __IO uint32_t STS0;
X    volatile uint32_t STS0;
N    uint32_t RESERVE0[1];
N
N
N    /**
N     * CTL1
N     * ===================================================================================================
N     * Offset: 0x10  DAC1 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DACEN     |DAC Enable
N     * |        |          |0 = Power down DAC.
N     * |        |          |1 = Power on DAC.
N     * |        |          |Note: When DAC is powered on, DAC will automatically start conversion after waiting for DACPWONSTBCNT+1 PCLK cycle
N     * |[1]     |DACIE     |DAC Interrupt Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[6:4]   |DACLSEL   |DAC Load Selection
N     * |        |          |Select the load trigger for the DAC latch.
N     * |        |          |000 = DAC latch loads when DACx_DAT written
N     * |        |          |001 = PDMA ACK
N     * |        |          |010 = Rising edge of TMR0
N     * |        |          |011 = Rising edge of TMR1
N     * |        |          |100 = Rising edge of TMR2
N     * |        |          |101 = Rising edge of TMR3
N     * |        |          |Others = Reserved
N     * |[21:8]  |DACPWONSTBCNT|DACPWONSTBCNT
N     * |        |          |DAC need 6 us to be stable after DAC is power on from power down state.
N     * |        |          |This field controls a internal counter (in PCLK unit) to guarantee DAC stable time requirement.
N    */
N    __IO uint32_t CTL1;
X    volatile uint32_t CTL1;
N
N    /**
N     * DATA1
N     * ===================================================================================================
N     * Offset: 0x14  DAC1 Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |DACData   |DAC data
N    */
N    __IO uint32_t DATA1;
X    volatile uint32_t DATA1;
N
N    /**
N     * STS1
N     * ===================================================================================================
N     * Offset: 0x18  DAC1 Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DACIFG    |DAC Interrupt Flag
N     * |        |          |0 = No interrupt pending.
N     * |        |          |1 = Interrupt pending.
N     * |        |          |Note: This bit is read only.
N     * |[1]     |DACSTFG   |DAC Start Flag
N     * |        |          |0 = DAC is not start yet.
N     * |        |          |1 = DAC has been started.
N     * |        |          |Note: this bit is read only.
N     * |[2]     |BUSY      |BUSY Bit
N     * |        |          |0 = DAC is not busy.
N     * |        |          |1 = DAC is busy.
N    */
N    __IO uint32_t STS1;
X    volatile uint32_t STS1;
N    uint32_t RESERVE1[1];
N
N
N    /**
N     * COMCTL
N     * ===================================================================================================
N     * Offset: 0x20  DAC01 Common Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |WAITDACCONV|Wait DAC Conversion Complete
N     * |        |          |The DAC needs at least 2 us to settle down every time when each data deliver to DAC, which means user cannot update each DACx_data register faster than 2 us; otherwise data will lost.
N     * |        |          |Setting this register can adjust the time interval in PCLK unit between each DACx_data into DAC in order to meet the 2 us requirement.
N     * |[8]     |DAC01GRP  |Group DAC0 And DAC1
N     * |        |          |0 = Not grouped.
N     * |        |          |1 = Grouped.
N     * |[10:9]  |REFSEL    |Reference Voltage Selection
N     * |        |          |00 = AVDD
N     * |        |          |01 = Internal reference voltage
N     * |        |          |10 = External reference voltage
N     * |        |          |11= Reserved
N    */
N    __IO uint32_t COMCTL;
X    volatile uint32_t COMCTL;
N
N} DAC_T;
N
N/**
N    @addtogroup DAC_CONST DAC Bit Field Definition
N    Constant Definitions for DAC Controller
N@{ */
N
N#define DAC_CTL_DACEN_Pos                (0)                                               /*!< DAC_T::CTL: DACEN Position                */
N#define DAC_CTL_DACEN_Msk                (0x1ul << DAC_CTL_DACEN_Pos)                      /*!< DAC_T::CTL: DACEN Mask                    */
N
N#define DAC_CTL_DACIE_Pos                (1)                                               /*!< DAC_T::CTL: DACIE Position                */
N#define DAC_CTL_DACIE_Msk                (0x1ul << DAC_CTL_DACIE_Pos)                      /*!< DAC_T::CTL: DACIE Mask                    */
N
N#define DAC_CTL_DACLSEL_Pos              (4)                                               /*!< DAC_T::CTL: DACLSEL Position              */
N#define DAC_CTL_DACLSEL_Msk              (0x7ul << DAC_CTL_DACLSEL_Pos)                    /*!< DAC_T::CTL: DACLSEL Mask                  */
N
N#define DAC_CTL_DACPWONSTBCNT_Pos        (8)                                               /*!< DAC_T::CTL: DACPWONSTBCNT Position        */
N#define DAC_CTL_DACPWONSTBCNT_Msk        (0x3ffful << DAC_CTL_DACPWONSTBCNT_Pos)           /*!< DAC_T::CTL: DACPWONSTBCNT Mask            */
N
N#define DAC_DATA_DACData_Pos             (0)                                               /*!< DAC_T::DATA: DACData Position             */
N#define DAC_DATA_DACData_Msk             (0xffful << DAC_DATA_DACData_Pos)                 /*!< DAC_T::DATA: DACData Mask                 */
N
N#define DAC_STS_DACIFG_Pos               (0)                                               /*!< DAC_T::STS: DACIFG Position               */
N#define DAC_STS_DACIFG_Msk               (0x1ul << DAC_STS_DACIFG_Pos)                     /*!< DAC_T::STS: DACIFG Mask                   */
N
N#define DAC_STS_DACSTFG_Pos              (1)                                               /*!< DAC_T::STS: DACSTFG Position              */
N#define DAC_STS_DACSTFG_Msk              (0x1ul << DAC_STS_DACSTFG_Pos)                    /*!< DAC_T::STS: DACSTFG Mask                  */
N
N#define DAC_STS_BUSY_Pos                 (2)                                               /*!< DAC_T::STS: BUSY Position                 */
N#define DAC_STS_BUSY_Msk                 (0x1ul << DAC_STS_BUSY_Pos)                       /*!< DAC_T::STS: BUSY Mask                     */
N
N#define DAC_COMCTL_WAITDACCONV_Pos       (0)                                               /*!< DAC_T::COMCTL: WAITDACCONV Position       */
N#define DAC_COMCTL_WAITDACCONV_Msk       (0xfful << DAC_COMCTL_WAITDACCONV_Pos)            /*!< DAC_T::COMCTL: WAITDACCONV Mask           */
N
N#define DAC_COMCTL_DAC01GRP_Pos          (8)                                               /*!< DAC_T::COMCTL: DAC01GRP Position          */
N#define DAC_COMCTL_DAC01GRP_Msk          (0x1ul << DAC_COMCTL_DAC01GRP_Pos)                /*!< DAC_T::COMCTL: DAC01GRP Mask              */
N
N#define DAC_COMCTL_REFSEL_Pos            (9)                                               /*!< DAC_T::COMCTL: REFSEL Position            */
N#define DAC_COMCTL_REFSEL_Msk            (0x3ul << DAC_COMCTL_REFSEL_Pos)                  /*!< DAC_T::COMCTL: REFSEL Mask                */
N
N/**@}*/ /* DAC_CONST */
N/**@}*/ /* end of DAC register group */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller(EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * EBICON
N     * ===================================================================================================
N     * Offset: 0x00  External Bus Interface General Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ExtEN     |EBI Enable
N     * |        |          |This bit is the functional enable bit for EBI.
N     * |        |          |0 = EBI function is disabled.
N     * |        |          |1 = EBI function is enabled.
N     * |[1]     |ExtBW16   |EBI Data Width 16-Bit
N     * |        |          |This bit defines if the data bus is 8-bit or 16-bit.
N     * |        |          |0 = EBI data width is 8-bit.
N     * |        |          |1 = EBI data width is 16-bit.
N     * |[10:8]  |MCLKDIV   |External Output Clock Divider
N     * |        |          |The frequency of EBI output clock is controlled by MCLKDIV as shown in the following table.
N     * |        |          |000 = HCLK/1.
N     * |        |          |001 = HCLK/2.
N     * |        |          |010 = HCLK/4.
N     * |        |          |011 = HCLK/8.
N     * |        |          |100 = HCLK/16.
N     * |        |          |101 = HCLK/32.
N     * |        |          |110 = Default.
N     * |        |          |111 = Default.
N     * |        |          |Notice: Default value of output clock is HCLK/1
N     * |[11]    |MCLKEN    |External Clock Enable
N     * |        |          |This bit control if EBI generates the clock to external device.
N     * |        |          |If external device is a synchronous device, it's necessary to set this bit high to enable EBI generating clock to external device.
N     * |        |          |If the external device is an asynchronous device, keep this bit low is recommended to save power consumption.
N     * |        |          |0 = EBI Disabled to generate clock to external device.
N     * |        |          |1 = EBI Enabled to generate clock to external device.
N     * |[18:16] |ExttALE   |Expand Time Of ALE
N     * |        |          |The ALE width (tALE) to latch the address can be controlled by ExttALE.
N     * |        |          |tALE = (ExttALE+1)*MCLK.
N    */
N    __IO uint32_t EBICON;
X    volatile uint32_t EBICON;
N
N    /**
N     * EXTIME
N     * ===================================================================================================
N     * Offset: 0x04  External Bus Interface Timing Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |ExttACC   |EBI Data Access Time
N     * |        |          |ExttACC define data access time (tACC).
N     * |        |          |tACC = (ExttACC +1) * MCLK.
N     * |[10:8]  |ExttAHD   |EBI Data Access Hold Time
N     * |        |          |ExttAHD define data access hold time (tAHD).
N     * |        |          |tAHD = (ExttAHD +1) * MCLK.
N     * |[15:12] |ExtIW2X   |Idle State Cycle After Write
N     * |        |          |When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not zero.
N     * |        |          |Idle state cycle = (ExtIW2X*MCLK).
N     * |[19:16] |ExtIR2W   |Idle State Cycle Between Read-Write
N     * |        |          |When read action is finish and next action is going to write, idle state is inserted and nCS return to high if ExtIR2W is not zero.
N     * |        |          |Idle state cycle = (ExtIR2W*MCLK).
N     * |[27:24] |ExtIR2R   |Idle State Cycle Between Read-Read
N     * |        |          |When read action is finish and next action is going to read, idle state is inserted and nCS return to high if ExtIR2R is not zero.
N     * |        |          |Idle state cycle = (ExtIR2R*MCLK).
N    */
N    __IO uint32_t EXTIME;
X    volatile uint32_t EXTIME;
N
N} EBI_T;
N
N/**
N    @addtogroup EBI_CONST EBI Bit Field Definition
N    Constant Definitions for EBI Controller
N@{ */
N
N#define EBI_EBICON_ExtEN_Pos             (0)                                               /*!< EBI_T::EBICON: ExtEN Position             */
N#define EBI_EBICON_ExtEN_Msk             (0x1ul << EBI_EBICON_ExtEN_Pos)                   /*!< EBI_T::EBICON: ExtEN Mask                 */
N
N#define EBI_EBICON_ExtBW16_Pos           (1)                                               /*!< EBI_T::EBICON: ExtBW16 Position           */
N#define EBI_EBICON_ExtBW16_Msk           (0x1ul << EBI_EBICON_ExtBW16_Pos)                 /*!< EBI_T::EBICON: ExtBW16 Mask               */
N
N#define EBI_EBICON_MCLKDIV_Pos           (8)                                               /*!< EBI_T::EBICON: MCLKDIV Position           */
N#define EBI_EBICON_MCLKDIV_Msk           (0x7ul << EBI_EBICON_MCLKDIV_Pos)                 /*!< EBI_T::EBICON: MCLKDIV Mask               */
N
N#define EBI_EBICON_MCLKEN_Pos            (11)                                              /*!< EBI_T::EBICON: MCLKEN Position            */
N#define EBI_EBICON_MCLKEN_Msk            (0x1ul << EBI_EBICON_MCLKEN_Pos)                  /*!< EBI_T::EBICON: MCLKEN Mask                */
N
N#define EBI_EBICON_ExttALE_Pos           (16)                                              /*!< EBI_T::EBICON: ExttALE Position           */
N#define EBI_EBICON_ExttALE_Msk           (0x7ul << EBI_EBICON_ExttALE_Pos)                 /*!< EBI_T::EBICON: ExttALE Mask               */
N
N#define EBI_EXTIME_ExttACC_Pos           (0)                                               /*!< EBI_T::EXTIME: ExttACC Position           */
N#define EBI_EXTIME_ExttACC_Msk           (0x1ful << EBI_EXTIME_ExttACC_Pos)                /*!< EBI_T::EXTIME: ExttACC Mask               */
N
N#define EBI_EXTIME_ExttAHD_Pos           (8)                                               /*!< EBI_T::EXTIME: ExttAHD Position           */
N#define EBI_EXTIME_ExttAHD_Msk           (0x7ul << EBI_EXTIME_ExttAHD_Pos)                 /*!< EBI_T::EXTIME: ExttAHD Mask               */
N
N#define EBI_EXTIME_ExtIW2X_Pos           (12)                                              /*!< EBI_T::EXTIME: ExtIW2X Position           */
N#define EBI_EXTIME_ExtIW2X_Msk           (0xful << EBI_EXTIME_ExtIW2X_Pos)                 /*!< EBI_T::EXTIME: ExtIW2X Mask               */
N
N#define EBI_EXTIME_ExtIR2W_Pos           (16)                                              /*!< EBI_T::EXTIME: ExtIR2W Position           */
N#define EBI_EXTIME_ExtIR2W_Msk           (0xful << EBI_EXTIME_ExtIR2W_Pos)                 /*!< EBI_T::EXTIME: ExtIR2W Mask               */
N
N#define EBI_EXTIME_ExtIR2R_Pos           (24)                                              /*!< EBI_T::EXTIME: ExtIR2R Position           */
N#define EBI_EXTIME_ExtIR2R_Msk           (0xful << EBI_EXTIME_ExtIR2R_Pos)                 /*!< EBI_T::EXTIME: ExtIR2R Mask               */
N
N/**@}*/ /* EBI_CONST */
N/**@}*/ /* end of EBI register group */
N
N
N/*---------------------- Flash Memory Controller -------------------------*/
N/**
N    @addtogroup FMC Flash Memory Controller(FMC)
N    Memory Mapped Structure for FMC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * ISPCON
N     * ===================================================================================================
N     * Offset: 0x00  ISP Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPEN     |ISP Enable (Write-Protection Bit)
N     * |        |          |ISP function enable bit. Set this bit to enable ISP function.
N     * |        |          |0 = ISP function Disabled.
N     * |        |          |1 = ISP function Enabled.
N     * |[1]     |BS        |Boot Select (Write-Protection Bit)
N     * |        |          |Set/clear this bit to select next booting from LDROM/APROM, respectively.
N     * |        |          |This bit also functions as chip booting status flag, which can be used to check where chip booted from.
N     * |        |          |This bit is initiated with the inversed value of CBS in Config0 after power-on reset; It keeps the same value at other reset.
N     * |        |          |0 = boot from APROM.
N     * |        |          |1 = boot from LDROM.
N     * |[3]     |APUEN     |APROM Update Enable (Write-Protection Bit)
N     * |        |          |APROM update enable bit.
N     * |        |          |0 = APROM can not be updated.
N     * |        |          |1 = APROM can be updated when the MCU runs in APROM.
N     * |[4]     |CFGUEN    |Enable Config-Bits Update By ISP (Write-Protection Bit)
N     * |        |          |0 = Disabling ISP can update config-bits.
N     * |        |          |1 = Enabling ISP can update config-bits.
N     * |[5]     |LDUEN     |LDROM Update Enable (Write-Protection Bit)
N     * |        |          |LDROM update enable bit.
N     * |        |          |0 = LDROM cannot be updated.
N     * |        |          |1 = LDROM can be updated when the chip runs in APROM.
N     * |[6]     |ISPFF     |ISP Fail Flag (Write-Protection Bit)
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself
N     * |        |          |(2) LDROM writes to itself
N     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0
N     * |        |          |(4) Destination address is illegal, such as over an available range
N     * |        |          |Write 1 to clear.
N    */
N    __IO uint32_t ISPCON;
X    volatile uint32_t ISPCON;
N
N    /**
N     * ISPADR
N     * ===================================================================================================
N     * Offset: 0x04  ISP Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPADR    |ISP Address
N     * |        |          |This chip supports word program only.
N     * |        |          |ISPADR[1:0] must be kept 00b for ISP operation, and ISPADR[8:0] must be kept 0_0000_0000b for Vector Page Re-map Command.
N    */
N    __IO uint32_t ISPADR;
X    volatile uint32_t ISPADR;
N
N    /**
N     * ISPDAT
N     * ===================================================================================================
N     * Offset: 0x08  ISP Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT    |ISP Data
N     * |        |          |Write data to this register before ISP program operation
N     * |        |          |Read data from this register after ISP read operation
N    */
N    __IO uint32_t ISPDAT;
X    volatile uint32_t ISPDAT;
N
N    /**
N     * ISPCMD
N     * ===================================================================================================
N     * Offset: 0x0C  ISP Command Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |FCTRL     |ISP Command
N     * |        |          |The ISP command table is shown as follows.
N     * |[4]     |FCEN      |ISP Command
N     * |        |          |The ISP command table is shown as follows.
N     * |[5]     |FOEN      |ISP Command
N     * |        |          |The ISP command table is shown as follows.
N    */
N    __IO uint32_t ISPCMD;
X    volatile uint32_t ISPCMD;
N
N    /**
N     * ISPTRG
N     * ===================================================================================================
N     * Offset: 0x10  ISP Trigger Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP Start Trigger
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP is progressing.
N    */
N    __IO uint32_t ISPTRG;
X    volatile uint32_t ISPTRG;
N
N    /**
N     * DFBADR
N     * ===================================================================================================
N     * Offset: 0x14  Data Flash Base Address
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DFBA      |Data Flash Base Address
N     * |        |          |This register indicates data flash start address. It is a read only register.
N     * |        |          |The data flash start address is defined by user.
N     * |        |          |Since on chip flash erase unit is 512 bytes, it is mandatory to keep bit 8-0 as 0.
N    */
N    __I  uint32_t DFBADR;
X    volatile const  uint32_t DFBADR;
N    uint32_t RESERVE0[10];
N
N
N    /**
N     * ISPSTA
N     * ===================================================================================================
N     * Offset: 0x40  ISP Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPBUSY   |ISP BUSY
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP operation is busy.
N     * |        |          |Read Only
N     * |[2:1]   |CBS       |Config Boot Selection Status
N     * |[6]     |ISPFF     |ISP Fail Flag
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself.
N     * |        |          |(2) LDROM writes to itself.
N     * |        |          |(3) CONFIG is erased/programmed when the MCU is running in APROM.
N     * |        |          |(4) Destination address is illegal, such as over an available range.
N     * |        |          |Write 1 to clear.
N    */
N    __IO uint32_t ISPSTA;
X    volatile uint32_t ISPSTA;
N
N} FMC_T;
N
N/**
N    @addtogroup FMC_CONST FMC Bit Field Definition
N    Constant Definitions for FMC Controller
N@{ */
N
N#define FMC_ISPCON_ISPEN_Pos             (0)                                               /*!< FMC_T::ISPCON: ISPEN Position             */
N#define FMC_ISPCON_ISPEN_Msk             (0x1ul << FMC_ISPCON_ISPEN_Pos)                   /*!< FMC_T::ISPCON: ISPEN Mask                 */
N
N#define FMC_ISPCON_BS_Pos                (1)                                               /*!< FMC_T::ISPCON: BS Position                */
N#define FMC_ISPCON_BS_Msk                (0x1ul << FMC_ISPCON_BS_Pos)                      /*!< FMC_T::ISPCON: BS Mask                    */
N
N#define FMC_ISPCON_APUEN_Pos             (3)                                               /*!< FMC_T::ISPCON: APUEN Position             */
N#define FMC_ISPCON_APUEN_Msk             (0x1ul << FMC_ISPCON_APUEN_Pos)                   /*!< FMC_T::ISPCON: APUEN Mask                 */
N
N#define FMC_ISPCON_CFGUEN_Pos            (4)                                               /*!< FMC_T::ISPCON: CFGUEN Position            */
N#define FMC_ISPCON_CFGUEN_Msk            (0x1ul << FMC_ISPCON_CFGUEN_Pos)                  /*!< FMC_T::ISPCON: CFGUEN Mask                */
N
N#define FMC_ISPCON_LDUEN_Pos             (5)                                               /*!< FMC_T::ISPCON: LDUEN Position             */
N#define FMC_ISPCON_LDUEN_Msk             (0x1ul << FMC_ISPCON_LDUEN_Pos)                   /*!< FMC_T::ISPCON: LDUEN Mask                 */
N
N#define FMC_ISPCON_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPCON: ISPFF Position             */
N#define FMC_ISPCON_ISPFF_Msk             (0x1ul << FMC_ISPCON_ISPFF_Pos)                   /*!< FMC_T::ISPCON: ISPFF Mask                 */
N
N#define FMC_ISPADR_ISPADR_Pos            (0)                                               /*!< FMC_T::ISPADR: ISPADR Position            */
N#define FMC_ISPADR_ISPADR_Msk            (0xfffffffful << FMC_ISPADR_ISPADR_Pos)           /*!< FMC_T::ISPADR: ISPADR Mask                */
N
N#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC_T::ISPDAT: ISPDAT Position            */
N#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC_T::ISPDAT: ISPDAT Mask                */
N
N#define FMC_ISPCMD_FCTRL_Pos             (0)                                               /*!< FMC_T::ISPCMD: FCTRL Position             */
N#define FMC_ISPCMD_FCTRL_Msk             (0xful << FMC_ISPCMD_FCTRL_Pos)                   /*!< FMC_T::ISPCMD: FCTRL Mask                 */
N
N#define FMC_ISPCMD_FCEN_Pos              (4)                                               /*!< FMC_T::ISPCMD: FCEN Position              */
N#define FMC_ISPCMD_FCEN_Msk              (0x1ul << FMC_ISPCMD_FCEN_Pos)                    /*!< FMC_T::ISPCMD: FCEN Mask                  */
N
N#define FMC_ISPCMD_FOEN_Pos              (5)                                               /*!< FMC_T::ISPCMD: FOEN Position              */
N#define FMC_ISPCMD_FOEN_Msk              (0x1ul << FMC_ISPCMD_FOEN_Pos)                    /*!< FMC_T::ISPCMD: FOEN Mask                  */
N
N#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPTRG: ISPGO Position             */
N#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC_T::ISPTRG: ISPGO Mask                 */
N
N#define FMC_DFBADR_DFBA_Pos              (0)                                               /*!< FMC_T::DFBADR: DFBA Position              */
N#define FMC_DFBADR_DFBA_Msk              (0xfffffffful << FMC_DFBADR_DFBA_Pos)             /*!< FMC_T::DFBADR: DFBA Mask                  */
N
N#define FMC_ISPSTA_ISPBUSY_Pos           (0)                                               /*!< FMC_T::ISPSTA: ISPBUSY Position           */
N#define FMC_ISPSTA_ISPBUSY_Msk           (0x1ul << FMC_ISPSTA_ISPBUSY_Pos)                 /*!< FMC_T::ISPSTA: ISPBUSY Mask               */
N
N#define FMC_ISPSTA_CBS_Pos               (1)                                               /*!< FMC_T::ISPSTA: CBS Position               */
N#define FMC_ISPSTA_CBS_Msk               (0x3ul << FMC_ISPSTA_CBS_Pos)                     /*!< FMC_T::ISPSTA: CBS Mask                   */
N
N#define FMC_ISPSTA_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPSTA: ISPFF Position             */
N#define FMC_ISPSTA_ISPFF_Msk             (0x1ul << FMC_ISPSTA_ISPFF_Pos)                   /*!< FMC_T::ISPSTA: ISPFF Mask                 */
N
N/**@}*/ /* FMC_CONST */
N/**@}*/ /* end of FMC register group */
N
N
N/*---------------------- System Global Control Registers -------------------------*/
N/**
N    @addtogroup System Global Control Registers(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * PDID
N     * ===================================================================================================
N     * Offset: 0x00  Part Device Identification number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDID      |Part Device ID
N     * |        |          |This register reflects device part number code.
N     * |        |          |Software can read this register to identify which device is used.
N    */
N    __I  uint32_t PDID;
X    volatile const  uint32_t PDID;
N
N    /**
N     * RST_SRC
N     * ===================================================================================================
N     * Offset: 0x04  System Reset Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RSTS_POR  |The RSTS_POR Flag Is Set By The "Reset Signal" From The Power-On Reset (POR) Module Or Bit CHIP_RST (IPRSTC1[0]) To Indicate The Previous Reset Source
N     * |        |          |0 = No reset from POR or CHIP_RST.
N     * |        |          |1 = Power-on Reset (POR) or CHIP_RST had issued the reset signal to reset the system.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[1]     |RSTS_PAD  |The RSTS_PAD Flag Is Set By The "Reset Signal" From The /RESET Pin To Indicate The Previous Reset Source
N     * |        |          |0 = No reset from /RESET pin.
N     * |        |          |1 = The /RESET pin had issued the reset signal to reset the system.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[2]     |RSTS_WDT  |The RSTS_WDT Flag Is Set By The "Reset Signal" From The Watchdog Timer Module To Indicate The Previous Reset Source
N     * |        |          |0 = No reset from Watchdog Timer.
N     * |        |          |1 = The Watchdog Timer module had issued the reset signal to reset the system.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[4]     |RSTS_BOD  |The RSTS_BOD Flag Is Set By The "Reset Signal" From The Brown-Out-Detected Module To Indicate The Previous Reset Source
N     * |        |          |0 = No reset from BOD.
N     * |        |          |1 = Brown-out-Detected module had issued the reset signal to reset the system.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[5]     |RSTS_SYS  |The RSTS_SYS Flag Is Set By The "Reset Signal" From The Cortex_M0 Kernel To Indicate The Previous Reset Source
N     * |        |          |0 = No reset from Cortex_M0.
N     * |        |          |1 = Cortex_M0 had issued the reset signal to reset the system by writing 1 to the bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[7]     |RSTS_CPU  |The RSTS_CPU Flag Is Set By Hardware If Software Writes CPU_RST (IPRST_CTL1[1]) "1" To Rest Cortex-M0 CPU Kernel And Flash Memory Controller (FMC)
N     * |        |          |0 = No reset from CPU.
N     * |        |          |1 = Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST to 1.
N     * |        |          |This bit is cleared by writing 1 to itself.
N    */
N    __IO uint32_t RST_SRC;
X    volatile uint32_t RST_SRC;
N
N    /**
N     * IPRST_CTL1
N     * ===================================================================================================
N     * Offset: 0x08  IP Reset Control Resister1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHIP_RST  |CHIP One Shot Reset
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Setting this bit will reset the whole chip, including CPU kernel and all peripherals like power-on reset and this bit will automatically return to "0" after the 2 clock cycles.
N     * |        |          |The chip setting from flash will be also reloaded when chip one shot reset.
N     * |        |          |0 = Normal.
N     * |        |          |1 = Reset CHIP.
N     * |        |          |Note: In the following conditions, chip setting from flash will be reloaded.
N     * |        |          |Power-on Reset
N     * |        |          |Brown-out-Detected Reset
N     * |        |          |Low level on the /RESET pin
N     * |        |          |Set IPRST_CTL1[CHIP_RST]
N     * |[1]     |CPU_RST   |CPU Kernel One Shot Reset
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Setting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit will automatically return to "0" after the 2 clock cycles
N     * |        |          |0 = Normal.
N     * |        |          |1 = Reset CPU.
N     * |[2]     |DMA_RST   |DMA Controller Reset
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Set this bit "1" will generate a reset signal to the DMA.
N     * |        |          |SW needs to set this bit to low to release reset signal.
N     * |        |          |0 = Normal operation.
N     * |        |          |1 = DMA IP reset.
N     * |[3]     |EBI_RST   |EBI Controller Reset
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Set this bit "1" will generate a reset signal to the EBI.
N     * |        |          |SW needs to set this bit to low to release reset signal.
N     * |        |          |0 = Normal operation.
N     * |        |          |1 = EBI IP reset.
N    */
N    __IO uint32_t IPRST_CTL1;
X    volatile uint32_t IPRST_CTL1;
N
N    /**
N     * IPRST_CTL2
N     * ===================================================================================================
N     * Offset: 0x0C  IP Reset Control Resister2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |GPIO_RST  |GPIO Controller Reset
N     * |        |          |0 = GPIO normal operation.
N     * |        |          |1 = GPIO reset.
N     * |[2]     |TMR0_RST  |Timer0 Controller Reset
N     * |        |          |0 = Timer0 normal operation.
N     * |        |          |1 = Timer0 reset.
N     * |[3]     |TMR1_RST  |Timer1 Controller Reset
N     * |        |          |0 = Timer1 normal operation.
N     * |        |          |1 = Timer1 block reset.
N     * |[4]     |TMR2_RST  |Timer2 Controller Reset
N     * |        |          |0 = Timer2 normal operation.
N     * |        |          |1 = Timer2 block reset.
N     * |[5]     |TMR3_RST  |Timer3 Controller Reset
N     * |        |          |0 = Timer3 normal operation.
N     * |        |          |1 = Timer3 block reset.
N     * |[7]     |SC2_RST   |SmartCard 2 Controller Reset
N     * |        |          |0 = SmartCard 2 block normal operation.
N     * |        |          |1 = SmartCard 2 block reset.
N     * |[8]     |I2C0_RST  |I2C0 Controller Reset
N     * |        |          |0 = I2C0 normal operation.
N     * |        |          |1 = I2C0 block reset.
N     * |[9]     |I2C1_RST  |I2C1 Controller Reset
N     * |        |          |0 = I2C1 block normal operation.
N     * |        |          |1 = I2C1 block reset.
N     * |[12]    |SPI0_RST  |SPI0 Controller Reset
N     * |        |          |0 = SPI0 block normal operation.
N     * |        |          |1 = SPI0 block reset.
N     * |[13]    |SPI1_RST  |SPI1 Controller Reset
N     * |        |          |0 = SPI1 normal operation.
N     * |        |          |1 = SPI1 block reset.
N     * |[14]    |SPI2_RST  |SPI2 Controller Reset
N     * |        |          |0 = SPI2 normal operation.
N     * |        |          |1 = SPI2 block reset.
N     * |[16]    |UART0_RST |UART0 Controller Reset
N     * |        |          |0 = UART0 normal operation.
N     * |        |          |1 = UART0 block reset.
N     * |[17]    |UART1_RST |UART1 Controller Reset
N     * |        |          |0 = UART1 normal operation.
N     * |        |          |1 = UART1 block reset.
N     * |[20]    |PWM0_RST  |PWM0 Controller Reset
N     * |        |          |0 = PWM0 block normal operation.
N     * |        |          |1 = PWM0 block reset.
N     * |[21]    |PWM1_RST  |PWM1 Controller Reset
N     * |        |          |0 = PWM1 block normal operation.
N     * |        |          |1 = PWM1 block reset.
N     * |[25]    |DAC_RST   |DAC Controller Reset
N     * |        |          |0 = DAC block normal operation.
N     * |        |          |1 = DAC block reset.
N     * |[26]    |LCD_RST   |LCD Controller Reset
N     * |        |          |0 = LCD block normal operation.
N     * |        |          |1 = LCD block reset.
N     * |[27]    |USBD_RST  |USB Device Controller Reset
N     * |        |          |0 = USB block normal operation.
N     * |        |          |1 = USB block reset.
N     * |[28]    |ADC_RST   |ADC Controller Reset
N     * |        |          |0 = ADC block normal operation.
N     * |        |          |1 = ADC block reset.
N     * |[29]    |I2S_RST   |I2S Controller Reset
N     * |        |          |0 = I2S block normal operation.
N     * |        |          |1 = I2S block reset.
N     * |[30]    |SC0_RST   |SmartCard 0 Controller Reset
N     * |        |          |0 = SmartCard block normal operation.
N     * |        |          |1 = SmartCard block reset.
N     * |[31]    |SC1_RST   |SmartCard1 Controller Reset
N     * |        |          |0 = SmartCard block normal operation.
N     * |        |          |1 = SmartCard block reset.
N    */
N    __IO uint32_t IPRST_CTL2;
X    volatile uint32_t IPRST_CTL2;
N    uint32_t RESERVE0[4];
N
N
N    /**
N     * TEMPCTL
N     * ===================================================================================================
N     * Offset: 0x20  Temperature Sensor Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |VTEMP_EN  |Temperature Sensor Enable
N     * |        |          |0 = Temperature sensor function Disabled (default).
N     * |        |          |1 = Temperature sensor function Enabled.
N    */
N    __IO uint32_t TEMPCTL;
X    volatile uint32_t TEMPCTL;
N    uint32_t RESERVE1[3];
N
N
N    /**
N     * PA_L_MFP
N     * ===================================================================================================
N     * Offset: 0x30  Port A low byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PA0_MFP   |PA.0 Pin Function Selection
N     * |        |          |001 = ADC input channel 0
N     * |        |          |100 = SmartCard 2 card detect
N     * |        |          |Others = GPIOA[0]
N     * |[6:4]   |PA1_MFP   |PA.1 Pin Function Selection
N     * |        |          |001 = ADC input channel 1
N     * |        |          |010 = EBI AD[12]
N     * |        |          |Others = GPIOA[1]
N     * |[10:8]  |PA2_MFP   |PA.2 Pin Function Selection
N     * |        |          |001 = ADC input channel 2
N     * |        |          |010 = EBI AD[11]
N     * |        |          |101 = UART1_RXD
N     * |        |          |Others = GPIOA[2]
N     * |[14:12] |PA3_MFP   |PA.3 Pin Function Selection
N     * |        |          |001 = ADC input channel 3
N     * |        |          |010 = EBI AD[10]
N     * |        |          |101 = UART1_TXD
N     * |        |          |Others = GPIOA[3]
N     * |[18:16] |PA4_MFP   |PA.4 Pin Function Selection
N     * |        |          |001 = ADC input channel 4
N     * |        |          |010 = EBI AD[9]
N     * |        |          |100 = SmartCard 2 power
N     * |        |          |101 = I2C0 SDA
N     * |        |          |111 = LCD SEG 39
N     * |        |          |Others = GPIOA[4]
N     * |[22:20] |PA5_MFP   |PA.5 Pin Function Selection
N     * |        |          |001 = ADC input channel 5
N     * |        |          |010 = EBI AD[8]
N     * |        |          |100 = SmartCard2 RST
N     * |        |          |101 = I2C0 SCL
N     * |        |          |111 = LCD SEG 38
N     * |        |          |Others = GPIOA[5]
N     * |[26:24] |PA6_MFP   |PA.6 Pin Function Selection
N     * |        |          |001 = ADC input channel 6
N     * |        |          |010 = EBI AD[7]
N     * |        |          |011 = Timer 3 Capture event
N     * |        |          |100 = SmartCard 2 clock
N     * |        |          |101 = PWM0 Channel 3
N     * |        |          |111 = LCD SEG 37
N     * |        |          |Others = GPIOA[6]
N     * |[30:28] |PA7_MFP   |PA.7 Pin Function Selection
N     * |        |          |001 = ADC input channel 7
N     * |        |          |010 = EBI AD[6]
N     * |        |          |011 = Timer 2 capture event
N     * |        |          |100 = SmartCard 2 data pin
N     * |        |          |101 = PWM0 Channel 2
N     * |        |          |111 = LCD SEG 36
N     * |        |          |Others = GPIOA[7]
N    */
N    __IO uint32_t PA_L_MFP;
X    volatile uint32_t PA_L_MFP;
N
N    /**
N     * PA_H_MFP
N     * ===================================================================================================
N     * Offset: 0x34  Port A high byte  multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PA8_MFP   |PA.8 Pin Function Selection
N     * |        |          |001 = I2C0 SDA
N     * |        |          |011 = SmartCard0 clock
N     * |        |          |100 = SPI2 1st slave select pin
N     * |        |          |111 = LCD SEG 20
N     * |        |          |Others = GPIOA[8]
N     * |[6:4]   |PA9_MFP   |PA.9 Pin Function Selection
N     * |        |          |001 = I2C0 SCL
N     * |        |          |011 = SmartCard0 DATA
N     * |        |          |100 = SPI2 SCLK
N     * |        |          |111 = LCD SEG 21
N     * |        |          |Others = GPIOA[9]
N     * |[10:8]  |PA10_MFP  |PA.10 Pin Function Selection
N     * |        |          |001 = I2C1 SDA
N     * |        |          |010 = EBI nWR
N     * |        |          |011 = SmartCard0 Power
N     * |        |          |100 = SPI2 MISO0
N     * |        |          |111 = LCD SEG 22
N     * |        |          |Others = GPIOA[10]
N     * |[14:12] |PA11_MFP  |PA.11 Pin Function Selection
N     * |        |          |001 = I2C1 SCL
N     * |        |          |010 = EBI nRE
N     * |        |          |011 = SmartCard0 RST
N     * |        |          |100 = SPI2 MOSI0
N     * |        |          |111 = LCD SEG 23
N     * |        |          |Others = GPIOA[11]
N     * |[18:16] |PA12_MFP  |PA.12 Pin Function Selection
N     * |        |          |001 = PWM0 Channel 0
N     * |        |          |010 = EBI AD[13]
N     * |        |          |011 = Timer0 capture event
N     * |        |          |101 = I2C0 SDA
N     * |        |          |Others = GPIOA[12]
N     * |[22:20] |PA13_MFP  |PA.13 Pin Function Selection
N     * |        |          |001 = PWM0 Channel 1
N     * |        |          |010 = EBI AD[14]
N     * |        |          |011 = Timer1 capture event
N     * |        |          |101 = I2C0 SCL
N     * |        |          |Others = GPIOA[13]
N     * |[26:24] |PA14_MFP  |PA.14 Pin Function Selection
N     * |        |          |001 = PWM0 Channel 2
N     * |        |          |010 = EBI AD[15]
N     * |        |          |011 = Timer2 capture event
N     * |        |          |110 = UART0 RX
N     * |        |          |Others = GPIOA[14]
N     * |[30:28] |PA15_MFP  |PA.15 Pin Function Selection
N     * |        |          |001 = PWM0 Channel 3
N     * |        |          |010 = I2S MCLK
N     * |        |          |011 = Timer3 capture event
N     * |        |          |100 = SmartCard 0 power
N     * |        |          |110 = UART0 TX
N     * |        |          |Others = GPIOA[15]
N    */
N    __IO uint32_t PA_H_MFP;
X    volatile uint32_t PA_H_MFP;
N
N    /**
N     * PB_L_MFP
N     * ===================================================================================================
N     * Offset: 0x38  Port B low byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PB0_MFP   |PB.0 Pin Function Selection
N     * |        |          |001 = UART0 RX
N     * |        |          |011 = SPI1 MOSI0
N     * |        |          |111 = LCD SEG 7
N     * |        |          |Others = GPIOB[0]
N     * |[6:4]   |PB1_MFP   |PB.1 Pin Function Selection
N     * |        |          |001 = UART0 TX
N     * |        |          |011 = SPI1 MISO0
N     * |        |          |111 = LCD SEG 6
N     * |        |          |Others = GPIOB[1]
N     * |[10:8]  |PB2_MFP   |PB.2 Pin Function Selection
N     * |        |          |001 = UART0 RTSn
N     * |        |          |010 = EBI nWRL
N     * |        |          |011 = SPI1 SCLK
N     * |        |          |111 = LCD SEG 5
N     * |        |          |Others = GPIOB[2]
N     * |[14:12] |PB3_MFP   |PB.3 Pin Function Selection
N     * |        |          |001 = UART0 CTSn
N     * |        |          |010 = EBI nWRH
N     * |        |          |011 = SPI1 1st slave select pin
N     * |        |          |111 = LCD SEG 4
N     * |        |          |Others = GPIOB[3]
N     * |[18:16] |PB4_MFP   |PB.4 Pin Function Selection
N     * |        |          |001 = UART1 RX
N     * |        |          |011 = SmartCard0 card detection
N     * |        |          |100 = SPI2 1st slave select pin
N     * |        |          |111 = LCD SEG 13
N     * |        |          |Others = GPIOB[4]
N     * |[22:20] |PB5_MFP   |PB.5 Pin Function Selection
N     * |        |          |001 = UART1 TX
N     * |        |          |011 = SmartCard0 RST
N     * |        |          |100 = SPI2 SCLK
N     * |        |          |111 = LCD SEG 12
N     * |        |          |Others = GPIOB[5]
N     * |[26:24] |PB6_MFP   |PB.6 Pin Function Selection
N     * |        |          |001 = UART1 RTSn
N     * |        |          |010 = EBI ALE
N     * |        |          |100 = SPI2 MISO0
N     * |        |          |111 = LCD SEG 11
N     * |        |          |Others = GPIOB[6]
N     * |[30:28] |PB7_MFP   |PB.7 Pin Function Selection
N     * |        |          |001 = UART1 CTSn
N     * |        |          |010 = EBI nCS
N     * |        |          |100 = SPI2 MOSI0
N     * |        |          |111 = LCD SEG 10
N     * |        |          |Others = GPIOB[7]
N    */
N    __IO uint32_t PB_L_MFP;
X    volatile uint32_t PB_L_MFP;
N
N    /**
N     * PB_H_MFP
N     * ===================================================================================================
N     * Offset: 0x3C  Port B high byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PB8_MFP   |PB.8 Pin Function Selection
N     * |        |          |001 = ADC external trigger
N     * |        |          |010 = Timer0 external event input or Timer0 toggle output
N     * |        |          |011 = External interrupt 0
N     * |        |          |100 = SmartCard 2 power
N     * |        |          |111 = LCD SEG 30
N     * |        |          |Others = GPIOB[8]
N     * |[6:4]   |PB9_MFP   |PB.9 Pin Function Selection
N     * |        |          |001 = SPI1 2nd slave select pin
N     * |        |          |010 = Timer1 external event input or Timer1 toggle output
N     * |        |          |100 = SmartCard 2 RST
N     * |        |          |101 = External interrupt 0
N     * |        |          |111 = LCD V1
N     * |        |          |Others = GPIOB[9]
N     * |[10:8]  |PB10_MFP  |PB.10 Pin Function Selection
N     * |        |          |001 = SPI0 2nd slave select pin
N     * |        |          |010 = Timer2 external event input or Timer2 toggle output
N     * |        |          |100 = SmartCard 2 clock
N     * |        |          |101 = SPI0 MOSI0
N     * |        |          |111 = LCD V2
N     * |        |          |Others = GPIOB[10]
N     * |[14:12] |PB11_MFP  |PB.11 Pin Function Selection
N     * |        |          |001 = PWM1 Channel 0
N     * |        |          |010 = Timer3 external event input or Timer3 toggle output
N     * |        |          |100 = SmartCard 2 DATA
N     * |        |          |101 = SPI0 MISO0
N     * |        |          |111 = LCD V3
N     * |        |          |Others = GPIOB[11]
N     * |[18:16] |PB12_MFP  |PB.12 Pin Function Selection
N     * |        |          |010 = EBI AD[0]
N     * |        |          |100 = FRQDIV_CLK
N     * |        |          |111 = LCD SEG 24
N     * |        |          |Others = GPIOB[12]
N     * |[22:20] |PB13_MFP  |PB.13 Pin Function Selection
N     * |        |          |010 = EBI AD[1]
N     * |        |          |111 = LCD SEG 25
N     * |        |          |Others = GPIOB[13]
N     * |[26:24] |PB14_MFP  |PB.14 Pin Function Selection
N     * |        |          |001 = External interrupt 0
N     * |        |          |011 = SmartCard 2 card detect
N     * |        |          |100 = SPI2 2nd slave select pin
N     * |        |          |111 = LCD SEG 26
N     * |        |          |Others = GPIOB[14]
N     * |[30:28] |PB15_MFP  |PB.15 Pin Function Selection
N     * |        |          |001 = External interrupt 1
N     * |        |          |011 = Snooper pin
N     * |        |          |100 = SmartCard1 card detect
N     * |        |          |111 = LCD SEG 31
N     * |        |          |Others = GPIOB[15]
N    */
N    __IO uint32_t PB_H_MFP;
X    volatile uint32_t PB_H_MFP;
N
N    /**
N     * PC_L_MFP
N     * ===================================================================================================
N     * Offset: 0x40  Port C low byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PC0_MFP   |PC.0 Pin Function Selection
N     * |        |          |001 = SPI0 1st slave select pin
N     * |        |          |010 = I2S WS
N     * |        |          |100 = SmartCard1 clock
N     * |        |          |111 = LCD DH1
N     * |        |          |Others = GPIOC[0]
N     * |[6:4]   |PC1_MFP   |PC.1 Pin Function Selection
N     * |        |          |001 = SPI0 SCLK
N     * |        |          |010 = I2S BCLK
N     * |        |          |100 = SmartCard1 DATA
N     * |        |          |111 = LCD DH2
N     * |        |          |Others = GPIOC[1]
N     * |[10:8]  |PC2_MFP   |PC.2 Pin Function Selection
N     * |        |          |001 = SPI0 MISO0
N     * |        |          |010 = I2S Din
N     * |        |          |100 = SmartCard1 Power
N     * |        |          |111 = LCD COM 0
N     * |        |          |Others = GPIOC[2]
N     * |[14:12] |PC3_MFP   |PC.3 Pin Function Selection
N     * |        |          |001 = SPI0 MOSI1
N     * |        |          |010 = I2S Dout
N     * |        |          |100 = SmartCard1 RST
N     * |        |          |111 = LCD COM 1
N     * |        |          |Others = GPIOC[3]
N     * |[18:16] |PC4_MFP   |PC.4 Pin Function Selection
N     * |        |          |001 = SPI0 MISO1
N     * |        |          |111 = LCD COM 2
N     * |        |          |Others = GPIOC[4]
N     * |[22:20] |PC5_MFP   |PC.5 Pin Function Selection
N     * |        |          |001 = SPI0 MOSI1
N     * |        |          |111 = LCD COM 3
N     * |        |          |Others = GPIOC[5]
N     * |[26:24] |PC6_MFP   |PC.6 Pin Function Selection
N     * |        |          |001 = DA out0
N     * |        |          |010 = EBI AD[4]
N     * |        |          |011 = Timer0 capture event
N     * |        |          |100 = SmartCard1 card detection
N     * |        |          |101 = PWM0 Channel 0
N     * |        |          |Others = GPIOC[6]
N     * |[30:28] |PC7_MFP   |PC.7 Pin Function Selection
N     * |        |          |001 = DA out1
N     * |        |          |010 = EBI AD[5]
N     * |        |          |011 = Timer1 capture event
N     * |        |          |101 = PWM0 Channel 1
N     * |        |          |Others = GPIOC[7]
N    */
N    __IO uint32_t PC_L_MFP;
X    volatile uint32_t PC_L_MFP;
N
N    /**
N     * PC_H_MFP
N     * ===================================================================================================
N     * Offset: 0x44  Port C high byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PC8_MFP   |PC.8 Pin Function Selection
N     * |        |          |001 = SPI1 1st slave select pin
N     * |        |          |010 = EBI MCLK
N     * |        |          |101 = I2C1 SDA
N     * |        |          |Others = GPIOC[8]
N     * |[6:4]   |PC9_MFP   |PC.9 Pin Function Selection
N     * |        |          |001 = SPI1 SCLK
N     * |        |          |101 = I2C1 SCL
N     * |        |          |Others = GPIOC[9]
N     * |[10:8]  |PC10_MFP  |PC.10 Pin Function Selection
N     * |        |          |001 = SPI1 MISO0
N     * |        |          |101 = UART1 RX
N     * |        |          |Others = GPIOC[10]
N     * |[14:12] |PC11_MFP  |PC.11 Pin Function Selection
N     * |        |          |001 = SPI1 MOSI0
N     * |        |          |101 = UART1 TX
N     * |        |          |Others = GPIOC[11]
N     * |[18:16] |PC12_MFP  |PC.12 Pin Function Selection
N     * |        |          |001 = SPI1 MISO1
N     * |        |          |010 = PWM1 Channel 0
N     * |        |          |101 = External interrupt 0
N     * |        |          |110 = I2C0 SDA
N     * |        |          |Others = GPIOC[12]
N     * |[22:20] |PC13_MFP  |PC.13 Pin Function Selection
N     * |        |          |001 = SPI1 MOSI1
N     * |        |          |010 = PWM1 Channel 1
N     * |        |          |100 = Snooper pin
N     * |        |          |101 = External interrupt 1
N     * |        |          |110 = I2C0 SCL
N     * |        |          |Others = GPIOC[13]
N     * |[26:24] |PC14_MFP  |PC.14 Pin Function Selection
N     * |        |          |010 = EBI AD[2]
N     * |        |          |100 = PWM1 Channel 3
N     * |        |          |111 = LCD SEG 32
N     * |        |          |Others = GPIOC[14]
N     * |[30:28] |PC15_MFP  |PC.15 Pin Function Selection
N     * |        |          |010 = EBI AD[3]
N     * |        |          |011 = Timer0 capture event
N     * |        |          |100 = PWM1 Channel 2
N     * |        |          |111 = LCD SEG 33
N     * |        |          |Others = GPIOC[15]
N    */
N    __IO uint32_t PC_H_MFP;
X    volatile uint32_t PC_H_MFP;
N
N    /**
N     * PD_L_MFP
N     * ===================================================================================================
N     * Offset: 0x48  Port D low byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PD0_MFP   |PD.0 Pin Function Selection
N     * |        |          |001 = UART1 RX
N     * |        |          |011 = SPI2 1st slave select pin
N     * |        |          |100 = SmartCard1 clock
N     * |        |          |101 = ADC input channel8
N     * |        |          |Others = GPIOD[0]
N     * |[6:4]   |PD1_MFP   |PD.1 Pin Function Selection
N     * |        |          |001 = UART1 TX
N     * |        |          |011 = SPI2 SCLK
N     * |        |          |100 = SmartCard1 DATA
N     * |        |          |101 = ADC input channel9
N     * |        |          |Others = GPIOD[1]
N     * |[10:8]  |PD2_MFP   |PD.2 Pin Function Selection
N     * |        |          |001 = UART1 RTSn
N     * |        |          |010 = I2S WS
N     * |        |          |011 = SPI2 MISO0
N     * |        |          |100 = SmartCard1 power
N     * |        |          |101 = ADC input channel10
N     * |        |          |Others = GPIOD[2]
N     * |[14:12] |PD3_MFP   |PD.3 Pin Function Selection
N     * |        |          |001 = UART1 CTSn
N     * |        |          |010 = I2S BCLK
N     * |        |          |011 = SPI2 MOSI0
N     * |        |          |100 = SmartCard1 reset
N     * |        |          |101 = ADC input channel11
N     * |        |          |Others = GPIOD[3]
N     * |[18:16] |PD4_MFP   |PD.4 Pin Function Selection
N     * |        |          |010 = I2S Din
N     * |        |          |011 = SPI2 MISO1
N     * |        |          |100 = SmartCard1 card detection
N     * |        |          |111 = LCD SEG 35
N     * |        |          |Others = GPIOD[4]
N     * |[22:20] |PD5_MFP   |PD.5 Pin Function Selection
N     * |        |          |010 = I2S Dout
N     * |        |          |011 = SPI2 MOSI1
N     * |        |          |111 = LCD SEG 34
N     * |        |          |Others = GPIOD[5]
N     * |[26:24] |PD6_MFP   |PD.6 Pin Function Selection
N     * |        |          |111 = LCD SEG 3
N     * |        |          |Others = GPIOD[6]
N     * |[30:28] |PD7_MFP   |PD.7 Pin Function Selection
N     * |        |          |111 = LCD SEG 2
N     * |        |          |Others = GPIOD[7]
N    */
N    __IO uint32_t PD_L_MFP;
X    volatile uint32_t PD_L_MFP;
N
N    /**
N     * PD_H_MFP
N     * ===================================================================================================
N     * Offset: 0x4C  Port D high byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PD8_MFP   |PD.8 Pin Function Selection
N     * |        |          |111 = LCD SEG 19
N     * |        |          |Others = GPIOD[8]
N     * |[6:4]   |PD9_MFP   |PD.9 Pin Function Selection
N     * |        |          |111 = LCD SEG 18
N     * |        |          |Others = GPIOD[9]
N     * |[10:8]  |PD10_MFP  |PD.10 Pin Function Selection
N     * |        |          |111 = LCD SEG 17
N     * |        |          |Others = GPIOD[10]
N     * |[14:12] |PD11_MFP  |PD.11 Pin Function Selection
N     * |        |          |111 = LCD SEG 16
N     * |        |          |Others = GPIOD[11]
N     * |[18:16] |PD12_MFP  |PD.12 Pin Function Selection
N     * |        |          |111 = LCD SEG 15
N     * |        |          |Others = GPIOD[12]
N     * |[22:20] |PD13_MFP  |PD.13 Pin Function Selection
N     * |        |          |111 = LCD SEG 14
N     * |        |          |Others = GPIOD[13]
N     * |[26:24] |PD14_MFP  |PD.14 Pin Function Selection
N     * |        |          |111 = LCD SEG 1
N     * |        |          |Others = GPIOD[14]
N     * |[30:28] |PD15_MFP  |PD.15 Pin Function Selection
N     * |        |          |111 = LCD SEG 0
N     * |        |          |Others = GPIOD[15]
N    */
N    __IO uint32_t PD_H_MFP;
X    volatile uint32_t PD_H_MFP;
N
N    /**
N     * PE_L_MFP
N     * ===================================================================================================
N     * Offset: 0x50  Port E low byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PE0_MFP   |PE.0 Pin Function Selection
N     * |        |          |001 = PWM1 Channel 2
N     * |        |          |010 = I2S MCLK
N     * |        |          |Others = GPIOE[0]
N     * |[6:4]   |PE1_MFP   |PE.1 Pin Function Selection
N     * |        |          |001 = PWM1 Channel 3
N     * |        |          |110 = SPI0 1st slave select pin
N     * |        |          |Others = GPIOE[1]
N     * |[10:8]  |PE2_MFP   |PE.2 Pin Function Selection
N     * |        |          |110 = SPI0 SCLK
N     * |        |          |Others = GPIOE[2]
N     * |[14:12] |PE3_MFP   |PE.3 Pin Function Selection
N     * |        |          |110 = SPI0 MISO0
N     * |        |          |Others = GPIOE[3]
N     * |[18:16] |PE4_MFP   |PE.4 Pin Function Selection
N     * |        |          |110 = SPI0 MOSI0
N     * |        |          |Others = GPIOE[4]
N     * |[22:20] |PE5_MFP   |PE.5 Pin Function Selection
N     * |        |          |001 = PWM1 Channel 1
N     * |        |          |Others = GPIOE[5]
N     * |[26:24] |PE6_MFP   |PE.6 Pin Function Selection
N     * |        |          |GPIOE[6]
N     * |[30:28] |PE7_MFP   |PE.7 Pin Function Selection
N     * |        |          |111 = LCD SEG 8
N     * |        |          |Others = GPIOE[7]
N    */
N    __IO uint32_t PE_L_MFP;
X    volatile uint32_t PE_L_MFP;
N
N    /**
N     * PE_H_MFP
N     * ===================================================================================================
N     * Offset: 0x54  Port E high byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PE8_MFP   |PE.8 Pin Function Selection
N     * |        |          |111 = LCD SEG 9
N     * |        |          |Others = GPIOE[8]
N     * |[6:4]   |PE9_MFP   |PE.9 Pin Function Selection
N     * |        |          |111 = UART1 RX
N     * |        |          |Others = GPIOE[9]
N     * |[10:8]  |PE10_MFP  |PE.10 Pin Function Selection
N     * |        |          |111 = UART1 TX
N     * |        |          |Others = GPIOE[10]
N     * |[14:12] |PE11_MFP  |PE.11 Pin Function Selection
N     * |        |          |111 = UART1 RTSn
N     * |        |          |Others = GPIOE[11]
N     * |[18:16] |PE12_MFP  |PE.12 Pin Function Selection
N     * |        |          |111 = UART1 CTSn
N     * |        |          |Others = GPIOE[12]
N     * |[22:20] |PE13_MFP  |PE.13 Pin Function Selection
N     * |        |          |111 = LCD SEG 27
N     * |        |          |Others = GPIOE[13]
N     * |[26:24] |PE14_MFP  |PE.14 Pin Function Selection
N     * |        |          |111 = LCD SEG 28
N     * |        |          |Others = GPIOE[14]
N     * |[30:28] |PE15_MFP  |PE.15 Pin Function Selection
N     * |        |          |111 = LCD SEG 2
N     * |        |          |Others = GPIOE[15]
N    */
N    __IO uint32_t PE_H_MFP;
X    volatile uint32_t PE_H_MFP;
N
N    /**
N     * PF_L_MFP
N     * ===================================================================================================
N     * Offset: 0x58  Port F low byte multiple function control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |PF0_MFP   |PF.0 Pin Function Selection
N     * |        |          |101 = External interrupt 0
N     * |        |          |111 = ICE DATA
N     * |        |          |Others = GPIOF[1]
N     * |[6:4]   |PF1_MFP   |PF.1 Pin Function Selection
N     * |        |          |100 = FRQDIV_CLK
N     * |        |          |101 = External interrupt 1
N     * |        |          |111 = ICE CLOCK
N     * |        |          |Others = GPIOF[1]
N     * |[10:8]  |PF2_MFP   |PF.2 Pin Function Selection
N     * |        |          |111 = HXT OUT
N     * |        |          |Others = GPIOF[2]
N     * |[14:12] |PF3_MFP   |PF.3 Pin Function Selection
N     * |        |          |111 = HXT IN
N     * |        |          |Others = GPIOF[3]
N     * |[18:16] |PF4_MFP   |PF.4 Pin Function Selection
N     * |        |          |001 = I2C0 SDA
N     * |        |          |Others = GPIOF[4]
N     * |[22:20] |PF5_MFP   |PF.5 Pin Function Selection
N     * |        |          |001 = I2C0 SCL
N     * |        |          |Others = GPIOF[5]
N    */
N    __IO uint32_t PF_L_MFP;
X    volatile uint32_t PF_L_MFP;
N    uint32_t RESERVE2[1];
N
N
N    /**
N     * PORCTL
N     * ===================================================================================================
N     * Offset: 0x60  Power-On-Reset Controller Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |POR_DIS_CODE|Power-On Reset Enable Control
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
N     * |        |          |If setting the POR_DIS_CODE to 0x5AA5, the POR reset function will be disabled and the POR function will be active again when POR_DIS_CODE is set to another value or POR_DIS_CODE is reset by chip other reset functions, including: /RESET, Watchdog Timer reset, BOD reset, ICE reset command and the software-chip reset function.
N    */
N    __IO uint32_t PORCTL;
X    volatile uint32_t PORCTL;
N
N    /**
N     * BODCTL
N     * ===================================================================================================
N     * Offset: 0x64  Brown-out Detector Controller Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BOD17_EN  |Brown-Out Detector 1.7V Function Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[20:19]
N     * |        |          |Users can disable BOD17_EN but it takes effective (disabled) only in Power-down mode.
N     * |        |          |Once existing Power-down mode, BOD17 will be enabled by HW automatically.
N     * |        |          |When CPU reads this bit, CPU will read whether BOD17 function enabled or not.
N     * |        |          |In other words,CPU will always read high.
N     * |        |          |0 = Brown-out Detector 1.7V function Disabled.
N     * |        |          |1 = Brown-out Detector 1.7V function Enabled.
N     * |[1]     |BOD20_EN  |Brown-Out Detector 2.0 V Function Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Brown-out Detector 2.0 V function Disabled.
N     * |        |          |1 = Brown-out Detector 2.0 V function Enabled.
N     * |        |          |BOD20_EN is default on.
N     * |        |          |If SW disables it, Brown-out Detector 2.0 V function is not disabled until chip enters power-down mode.
N     * |        |          |If system is not in power-down mode, BOD20_EN will be enabled by hardware automatically.
N     * |[2]     |BOD25_EN  |Brown-Out Detector 2.5 V Function Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Brown-out Detector 2.5 V function Disabled.
N     * |        |          |1 = Brown-out Detector 2.5 V function Enabled.
N     * |[4]     |BOD17_RST_EN|BOD 1.7 V Reset Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Reset does not issue when BOD17 occurs.
N     * |        |          |1 = Reset issues when BOD17 occurs.
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[20:19]
N     * |        |          |BOD17_RST_EN can be controlled (enable or disable) only when BOD17_EN is high.
N     * |[5]     |BOD20_RST_EN|BOD 2.0 V Reset Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Reset does not issue when BOD20 occurs.
N     * |        |          |1 = Reset issues when BOD20 occurs.
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[20:19]
N     * |[6]     |BOD25_RST_EN|BOD 2.5 V Reset Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Reset does not issue when BOD25 occurs.
N     * |        |          |1 = Reset issues when BOD25 occurs.
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[20:19]
N     * |[8]     |BOD17_INT_EN|BOD 1.7 V Interrupt Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Interrupt does not issue when BOD17 occurs.
N     * |        |          |1 = Interrupt issues when BOD17 occurs.
N     * |[9]     |BOD20_INT_EN|BOD 2.0 V Interrupt Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Interrupt does not issue when BOD20 occurs.
N     * |        |          |1 = Interrupt issues when BOD20 occurs.
N     * |[10]    |BOD25_INT_EN|BOD 2.5 V Interrupt Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Interrupt does not issue when BOD25 occurs.
N     * |        |          |1 = Interrupt issues when BOD25 occurs.
N    */
N    __IO uint32_t BODCTL;
X    volatile uint32_t BODCTL;
N
N    /**
N     * BODSTS
N     * ===================================================================================================
N     * Offset: 0x68  Brown-out Detector Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BOD_INT   |Brown-Out Detector Interrupt Status
N     * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the target detected voltage or the VDD is raised up through the target detected voltage and Brown-out interrupt is enabled, this bit will be set to 1.
N     * |        |          |0 = Brown-out Detector does not detect any voltage drift at VDD down through or up through the target detected voltage after interrupt is enabled.
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[1]     |BOD17_drop|Brown-Out Detector Lower Than 1.7V Status
N     * |        |          |Setting BOD17_drop high means once the detected voltage is lower than target detected voltage setting (1.7V).
N     * |        |          |Software can write 1 to clear BOD17_drop.
N     * |[2]     |BOD20_drop|Brown-Out Detector Lower Than 2.0V Status
N     * |        |          |Setting BOD20_drop high means once the detected voltage is lower than target detected voltage setting (2.0V).
N     * |        |          |Software can write 1 to clear BOD20_drop.
N     * |[3]     |BOD25_drop|Brown-Out Detector Lower Than 2.5V Status
N     * |        |          |Setting BOD25_drop high means once the detected voltage is lower than target detected voltage setting (2.5V).
N     * |        |          |Software can write 1 to clear BOD25_drop.
N     * |[4]     |BOD17_rise|Brown-Out Detector Higher Than 1.7V Status
N     * |        |          |Setting BOD17_rise high means once the detected voltage is higher than target detected voltage setting (1.7V).
N     * |        |          |Software can write 1 to clear BOD17_rise.
N     * |[5]     |BOD20_rise|Brown-Out Detector Higher Than 2.0V Status
N     * |        |          |Setting BOD20_rise high means once the detected voltage is higher than target detected voltage setting (2.0V).
N     * |        |          |Software can write 1 to clear BOD20_rise.
N     * |[6]     |BOD25_rise|Brown-Out Detector Higher Than 2.5V Status
N     * |        |          |Setting BOD25_rise high means once the detected voltage is higher than target detected voltage setting (2.5V).
N     * |        |          |Software can write 1 to clear BOD25_rise.
N    */
N    __IO  uint32_t BODSTS;
X    volatile  uint32_t BODSTS;
N
N    /**
N     * Int_VREFCTL
N     * ===================================================================================================
N     * Offset: 0x6C  Voltage reference Control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BGP_EN    |Band-Gap Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Band-gap is the reference voltage of internal reference voltage.
N     * |        |          |User must enable band-gap if want to enable internal 1.8V or 2.5V reference voltage.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[1]     |REG_EN    |Regulator Enable
N     * |        |          |Enable internal 1.8V or 2.5V reference voltage.
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[2]     |SEL25     |Regulator Output Voltage Selection
N     * |        |          |Select internal reference voltage level.
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = 1.8V.
N     * |        |          |1 = 2.5V.
N     * |[3]     |EXT_MODE  |Regulator External Mode
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Users can output regulator output voltage in VREF pin if EXT_MODE is high.
N     * |        |          |0 = No connection with external VREF pin.
N     * |        |          |1 = Connect to external VREF pin.
N     * |        |          |Connect a 1uF to 10uF capacitor to AVSS will let internal voltage reference be more stable.
N    */
N    __IO uint32_t Int_VREFCTL;
X    volatile uint32_t Int_VREFCTL;
N    uint32_t RESERVE3[4];
N
N
N    /**
N     * IRCTRIMCTL
N     * ===================================================================================================
N     * Offset: 0x80  HIRC Trim Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |TRIM_SEL  |Trim Frequency Selection
N     * |        |          |This field indicates the target frequency of HIRC auto trim.
N     * |        |          |If no any target frequency is selected (TRIM_SEL is 00), the HIRC auto trim function is disabled.
N     * |        |          |During auto trim operation, if 32.768 kHz clock error detected or trim retry limitation count reached, this field will be cleared to 00 automatically.
N     * |        |          |00 = Disable HIRC auto trim function
N     * |        |          |01 = Enable HIRC auto trim function and trim HIRC to 11.0592 MHz
N     * |        |          |10 = Enable HIRC auto trim function and trim HIRC to 12 MHz
N     * |        |          |11 = Enable HIRC auto trim function and trim HIRC to 12.288 MHz
N     * |[5:4]   |TRIM_LOOP |Trim Calculation Loop
N     * |        |          |This field defines that trim value calculation is based on how many 32.768 kHz clock.
N     * |        |          |For example, if TRIM_LOOP is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.
N     * |        |          |00 = 4 32.768 kHz clock
N     * |        |          |01 = 8 32.768 kHz clock
N     * |        |          |10 = 16 32.768 kHz clock
N     * |        |          |11 = 32 32.768 kHz clock
N     * |[7:6]   |TRIM_RETRY_CNT|Trim Value Update Limitation Count
N     * |        |          |This field defines that how many times the auto trim circuit will try to update the HIRC trim value before the frequency of HIRC locked.
N     * |        |          |Once the HIRC locked, the internal trim value update counter will be reset.
N     * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC still doesn't lock, the auto trim operation will be disabled and TRIM_SEL will be cleared to 00.
N     * |        |          |00 = Trim retry count limitation is 64
N     * |        |          |01 = Trim retry count limitation is 128
N     * |        |          |10 = Trim retry count limitation is 256
N     * |        |          |11 = Trim retry count limitation is 512
N     * |[8]     |ERR_STOP  |Trim Stop When 32.768 KHz Error Detected
N     * |        |          |This bit is used to control if stop the HIRC trim operation when 32.768 kHz clock error is detected.
N     * |        |          |If set this bit high and 32.768 kHz clock error detected, the status 32K_ERR_INT would be set high and HIRC trim operation was stopped.
N     * |        |          |If this bit is low and 32.768 kHz clock error detected, the status 23K_ERR_INT would be set high and HIRC trim operation is continuously.
N     * |        |          |0 = Continue the HIRC trim operation even if 32.768 kHz clock error detected.
N     * |        |          |1 = Stop the HIRC trim operation if 32.768 kHz clock error detected.
N    */
N    __IO uint32_t IRCTRIMCTL;
X    volatile uint32_t IRCTRIMCTL;
N
N    /**
N     * IRCTRIMIEN
N     * ===================================================================================================
N     * Offset: 0x84  HIRC Trim Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TRIM_FAIL_IEN|Trim Failure Interrupt Enable
N     * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by TRIM_SEL.
N     * |        |          |If this bit is high and TRIM_FAIL_INT is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
N     * |        |          |0 = TRIM_FAIL_INT status Disabled to trigger an interrupt to CPU.
N     * |        |          |1 = TRIM_FAIL_INT status Enabled to trigger an interrupt to CPU.
N     * |[2]     |32K_ERR_IEN|32.768 KHz Clock Error Interrupt Enable
N     * |        |          |This bit controls if CPU would get an interrupt while 32.768 kHz clock is inaccuracy during auto trim operation.
N     * |        |          |If this bit is high, and 32K_ERR_INT is set during auto trim operation, an interrupt will be triggered to notify the 32.768 kHz clock frequency is inaccuracy.
N     * |        |          |0 = 32K_ERR_INT status Disabled to trigger an interrupt to CPU.
N     * |        |          |1 = 32K_ERR_INT status Enabled to trigger an interrupt to CPU.
N    */
N    __IO uint32_t IRCTRIMIEN;
X    volatile uint32_t IRCTRIMIEN;
N
N    /**
N     * IRCTRIMINT
N     * ===================================================================================================
N     * Offset: 0x88  HIRC Trim Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FREQ_LOCK |HIRC Frequency Lock Status
N     * |        |          |This bit indicates the HIRC frequency lock.
N     * |        |          |This is a status bit and doesn't trigger any interrupt.
N     * |[1]     |TRIM_FAIL_INT|Trim Failure Interrupt Status
N     * |        |          |This bit indicates that HIRC trim value update limitation count reached and HIRC clock frequency still doesn't lock.
N     * |        |          |Once this bit is set, the auto trim operation stopped and TRIM_SEL will be cleared to 00 by hardware automatically.
N     * |        |          |If this bit is set and TRIM_FAIL_IEN is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
N     * |        |          |Write 1 to clear this to zero.
N     * |        |          |0 = Trim value update limitation count doesn't reach.
N     * |        |          |1 = Trim value update limitation count reached and HIRC frequency still doesn't lock.
N     * |[2]     |32K_ERR_INT|32.768 KHz Clock Error Interrupt Status
N     * |        |          |This bit indicates that 32.768 kHz clock frequency is inaccuracy.
N     * |        |          |Once this bit is set, the auto trim operation stopped and TRIM_SEL will be cleared to 00 by hardware automatically.
N     * |        |          |If this bit is set and 32K_ERR_IEN is high, an interrupt will be triggered to notify the 32.768 kHz clock frequency is inaccuracy.
N     * |        |          |Write 1 to clear this to zero.
N     * |        |          |0 = 32.768 kHz clock frequency is accuracy.
N     * |        |          |1 = 32.768 kHz clock frequency is inaccuracy.
N    */
N    __IO uint32_t IRCTRIMINT;
X    volatile uint32_t IRCTRIMINT;
N    uint32_t RESERVE4[29];
N
N
N    /**
N     * RegLockAddr
N     * ===================================================================================================
N     * Offset: 0x100  Register Lock Key address
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RegUnLock |Register unlock bit
N     * |        |          |0 = Protected register are Locked. Any write to the target register is ignored.
N     * |        |          |1 = Protected registers are Unlocked.
N    */
N    __IO uint32_t RegLockAddr;
X    volatile uint32_t RegLockAddr;
N
N} SYS_T;
N
N/**
N    @addtogroup SYS_CONST SYS Bit Field Definition
N    Constant Definitions for SYS Controller
N@{ */
N
N#define SYS_PDID_PDID_Pos                (0)                                               /*!< SYS_T::PDID: PDID Position                */
N#define SYS_PDID_PDID_Msk                (0xfffffffful << SYS_PDID_PDID_Pos)               /*!< SYS_T::PDID: PDID Mask                    */
N
N#define SYS_RST_SRC_RSTS_POR_Pos         (0)                                               /*!< SYS_T::RST_SRC: RSTS_POR Position             */
N#define SYS_RST_SRC_RSTS_POR_Msk         (0x1ul << SYS_RST_SRC_RSTS_POR_Pos)               /*!< SYS_T::RST_SRC: RSTS_POR Mask                 */
N
N#define SYS_RST_SRC_RSTS_PAD_Pos         (1)                                               /*!< SYS_T::RST_SRC: RSTS_PAD Position             */
N#define SYS_RST_SRC_RSTS_PAD_Msk         (0x1ul << SYS_RST_SRC_RSTS_PAD_Pos)               /*!< SYS_T::RST_SRC: RSTS_PAD Mask                 */
N
N#define SYS_RST_SRC_RSTS_WDT_Pos         (2)                                               /*!< SYS_T::RST_SRC: RSTS_WDT Position             */
N#define SYS_RST_SRC_RSTS_WDT_Msk         (0x1ul << SYS_RST_SRC_RSTS_WDT_Pos)               /*!< SYS_T::RST_SRC: RSTS_WDT Mask                 */
N
N#define SYS_RST_SRC_RSTS_BOD_Pos         (4)                                               /*!< SYS_T::RST_SRC: RSTS_BOD Position             */
N#define SYS_RST_SRC_RSTS_BOD_Msk         (0x1ul << SYS_RST_SRC_RSTS_BOD_Pos)               /*!< SYS_T::RST_SRC: RSTS_BOD Mask                 */
N
N#define SYS_RST_SRC_RSTS_SYS_Pos         (5)                                               /*!< SYS_T::RST_SRC: RSTS_SYS_T::Position             */
N#define SYS_RST_SRC_RSTS_SYS_Msk         (0x1ul << SYS_RST_SRC_RSTS_SYS_Pos)               /*!< SYS_T::RST_SRC: RSTS_SYS_T::Mask                 */
N
N#define SYS_RST_SRC_RSTS_CPU_Pos         (7)                                               /*!< SYS_T::RST_SRC: RSTS_CPU Position             */
N#define SYS_RST_SRC_RSTS_CPU_Msk         (0x1ul << SYS_RST_SRC_RSTS_CPU_Pos)               /*!< SYS_T::RST_SRC: RSTS_CPU Mask                 */
N
N#define SYS_IPRST_CTL1_CHIP_RST_Pos      (0)                                               /*!< SYS_T::IPRST_CTL1: CHIP_RST Position            */
N#define SYS_IPRST_CTL1_CHIP_RST_Msk      (0x1ul << SYS_IPRST_CTL1_CHIP_RST_Pos)            /*!< SYS_T::IPRST_CTL1: CHIP_RST Mask                */
N
N#define SYS_IPRST_CTL1_CPU_RST_Pos       (1)                                               /*!< SYS_T::IPRST_CTL1: CPU_RST Position             */
N#define SYS_IPRST_CTL1_CPU_RST_Msk       (0x1ul << SYS_IPRST_CTL1_CPU_RST_Pos)              /*!< SYS_T::IPRST_CTL1: CPU_RST Mask                 */
N
N#define SYS_IPRST_CTL1_DMA_RST_Pos       (2)                                               /*!< SYS_T::IPRST_CTL1: DMA_RST Position             */
N#define SYS_IPRST_CTL1_DMA_RST_Msk       (0x1ul << SYS_IPRST_CTL1_DMA_RST_Pos)             /*!< SYS_T::IPRST_CTL1: DMA_RST Mask                 */
N
N#define SYS_IPRST_CTL1_EBI_RST_Pos       (3)                                               /*!< SYS_T::IPRST_CTL1: EBI_RST Position             */
N#define SYS_IPRST_CTL1_EBI_RST_Msk       (0x1ul << SYS_IPRST_CTL1_EBI_RST_Pos)             /*!< SYS_T::IPRST_CTL1: EBI_RST Mask                 */
N
N#define SYS_IPRST_CTL2_GPIO_RST_Pos      (1)                                               /*!< SYS_T::IPRST_CTL2: GPIO_RST Position            */
N#define SYS_IPRST_CTL2_GPIO_RST_Msk      (0x1ul << SYS_IPRST_CTL2_GPIO_RST_Pos)            /*!< SYS_T::IPRST_CTL2: GPIO_RST Mask                */
N
N#define SYS_IPRST_CTL2_TMR0_RST_Pos      (2)                                               /*!< SYS_T::IPRST_CTL2: TMR0_RST Position            */
N#define SYS_IPRST_CTL2_TMR0_RST_Msk      (0x1ul << SYS_IPRST_CTL2_TMR0_RST_Pos)            /*!< SYS_T::IPRST_CTL2: TMR0_RST Mask                */
N
N#define SYS_IPRST_CTL2_TMR1_RST_Pos      (3)                                               /*!< SYS_T::IPRST_CTL2: TMR1_RST Position            */
N#define SYS_IPRST_CTL2_TMR1_RST_Msk      (0x1ul << SYS_IPRST_CTL2_TMR1_RST_Pos)            /*!< SYS_T::IPRST_CTL2: TMR1_RST Mask                */
N
N#define SYS_IPRST_CTL2_TMR2_RST_Pos      (4)                                               /*!< SYS_T::IPRST_CTL2: TMR2_RST Position            */
N#define SYS_IPRST_CTL2_TMR2_RST_Msk      (0x1ul << SYS_IPRST_CTL2_TMR2_RST_Pos)            /*!< SYS_T::IPRST_CTL2: TMR2_RST Mask                */
N
N#define SYS_IPRST_CTL2_TMR3_RST_Pos      (5)                                               /*!< SYS_T::IPRST_CTL2: TMR3_RST Position            */
N#define SYS_IPRST_CTL2_TMR3_RST_Msk      (0x1ul << SYS_IPRST_CTL2_TMR3_RST_Pos)            /*!< SYS_T::IPRST_CTL2: TMR3_RST Mask                */
N
N#define SYS_IPRST_CTL2_SC2_RST_Pos       (7)                                               /*!< SYS_T::IPRST_CTL2: SC2_RST Position             */
N#define SYS_IPRST_CTL2_SC2_RST_Msk       (0x1ul << SYS_IPRST_CTL2_SC2_RST_Pos)             /*!< SYS_T::IPRST_CTL2: SC2_RST Mask                 */
N
N#define SYS_IPRST_CTL2_I2C0_RST_Pos      (8)                                               /*!< SYS_T::IPRST_CTL2: I2C0_RST Position            */
N#define SYS_IPRST_CTL2_I2C0_RST_Msk      (0x1ul << SYS_IPRST_CTL2_I2C0_RST_Pos)            /*!< SYS_T::IPRST_CTL2: I2C0_RST Mask                */
N
N#define SYS_IPRST_CTL2_I2C1_RST_Pos      (9)                                               /*!< SYS_T::IPRST_CTL2: I2C1_RST Position            */
N#define SYS_IPRST_CTL2_I2C1_RST_Msk      (0x1ul << SYS_IPRST_CTL2_I2C1_RST_Pos)            /*!< SYS_T::IPRST_CTL2: I2C1_RST Mask                */
N
N#define SYS_IPRST_CTL2_SPI0_RST_Pos      (12)                                              /*!< SYS_T::IPRST_CTL2: SPI0_RST Position            */
N#define SYS_IPRST_CTL2_SPI0_RST_Msk      (0x1ul << SYS_IPRST_CTL2_SPI0_RST_Pos)            /*!< SYS_T::IPRST_CTL2: SPI0_RST Mask                */
N
N#define SYS_IPRST_CTL2_SPI1_RST_Pos      (13)                                              /*!< SYS_T::IPRST_CTL2: SPI1_RST Position            */
N#define SYS_IPRST_CTL2_SPI1_RST_Msk      (0x1ul << SYS_IPRST_CTL2_SPI1_RST_Pos)            /*!< SYS_T::IPRST_CTL2: SPI1_RST Mask                */
N
N#define SYS_IPRST_CTL2_SPI2_RST_Pos      (14)                                              /*!< SYS_T::IPRST_CTL2: SPI2_RST Position            */
N#define SYS_IPRST_CTL2_SPI2_RST_Msk      (0x1ul << SYS_IPRST_CTL2_SPI2_RST_Pos)            /*!< SYS_T::IPRST_CTL2: SPI2_RST Mask                */
N
N#define SYS_IPRST_CTL2_UART0_RST_Pos     (16)                                              /*!< SYS_T::IPRST_CTL2: UART0_RST Position           */
N#define SYS_IPRST_CTL2_UART0_RST_Msk     (0x1ul << SYS_IPRST_CTL2_UART0_RST_Pos)          /*!< SYS_T::IPRST_CTL2: UART0_RST Mask               */
N
N#define SYS_IPRST_CTL2_UART1_RST_Pos     (17)                                              /*!< SYS_T::IPRST_CTL2: UART1_RST Position           */
N#define SYS_IPRST_CTL2_UART1_RST_Msk     (0x1ul << SYS_IPRST_CTL2_UART1_RST_Pos)           /*!< SYS_T::IPRST_CTL2: UART1_RST Mask               */
N
N#define SYS_IPRST_CTL2_PWM0_RST_Pos      (20)                                              /*!< SYS_T::IPRST_CTL2: PWM0_RST Position            */
N#define SYS_IPRST_CTL2_PWM0_RST_Msk      (0x1ul << SYS_IPRST_CTL2_PWM0_RST_Pos)            /*!< SYS_T::IPRST_CTL2: PWM0_RST Mask                */
N
N#define SYS_IPRST_CTL2_PWM1_RST_Pos      (21)                                              /*!< SYS_T::IPRST_CTL2: PWM1_RST Position            */
N#define SYS_IPRST_CTL2_PWM1_RST_Msk      (0x1ul << SYS_IPRST_CTL2_PWM1_RST_Pos)            /*!< SYS_T::IPRST_CTL2: PWM1_RST Mask                */
N
N#define SYS_IPRST_CTL2_DAC_RST_Pos       (25)                                              /*!< SYS_T::IPRST_CTL2: DAC_RST Position             */
N#define SYS_IPRST_CTL2_DAC_RST_Msk       (0x1ul << SYS_IPRST_CTL2_DAC_RST_Pos)             /*!< SYS_T::IPRST_CTL2: DAC_RST Mask                 */
N
N#define SYS_IPRST_CTL2_LCD_RST_Pos       (26)                                              /*!< SYS_T::IPRST_CTL2: LCD_RST Position             */
N#define SYS_IPRST_CTL2_LCD_RST_Msk       (0x1ul << SYS_IPRST_CTL2_LCD_RST_Pos)             /*!< SYS_T::IPRST_CTL2: LCD_RST Mask                 */
N
N#define SYS_IPRST_CTL2_USBD_RST_Pos      (27)                                              /*!< SYS_T::IPRST_CTL2: USBD_RST Position            */
N#define SYS_IPRST_CTL2_USBD_RST_Msk      (0x1ul << SYS_IPRST_CTL2_USBD_RST_Pos)            /*!< SYS_T::IPRST_CTL2: USBD_RST Mask                */
N
N#define SYS_IPRST_CTL2_ADC_RST_Pos       (28)                                              /*!< SYS_T::IPRST_CTL2: ADC_RST Position             */
N#define SYS_IPRST_CTL2_ADC_RST_Msk       (0x1ul << SYS_IPRST_CTL2_ADC_RST_Pos)             /*!< SYS_T::IPRST_CTL2: ADC_RST Mask                 */
N
N#define SYS_IPRST_CTL2_I2S_RST_Pos       (29)                                              /*!< SYS_T::IPRST_CTL2: I2S_RST Position             */
N#define SYS_IPRST_CTL2_I2S_RST_Msk       (0x1ul << SYS_IPRST_CTL2_I2S_RST_Pos)             /*!< SYS_T::IPRST_CTL2: I2S_RST Mask                 */
N
N#define SYS_IPRST_CTL2_SC0_RST_Pos       (30)                                              /*!< SYS_T::IPRST_CTL2: SC0_RST Position             */
N#define SYS_IPRST_CTL2_SC0_RST_Msk       (0x1ul << SYS_IPRST_CTL2_SC0_RST_Pos)             /*!< SYS_T::IPRST_CTL2: SC0_RST Mask                 */
N
N#define SYS_IPRST_CTL2_SC1_RST_Pos       (31)                                              /*!< SYS_T::IPRST_CTL2: SC1_RST Position             */
N#define SYS_IPRST_CTL2_SC1_RST_Msk       (0x1ul << SYS_IPRST_CTL2_SC1_RST_Pos)             /*!< SYS_T::IPRST_CTL2: SC1_RST Mask                 */
N
N#define SYS_TEMPCTL_VTEMP_EN_Pos         (0)                                               /*!< SYS_T::TEMPCTL: VTEMP_EN Position         */
N#define SYS_TEMPCTL_VTEMP_EN_Msk         (0x1ul << SYS_TEMPCTL_VTEMP_EN_Pos)               /*!< SYS_T::TEMPCTL: VTEMP_EN Mask             */
N
N#define SYS_PA_L_MFP_PA0_MFP_Pos         (0)                                               /*!< SYS_T::PA_L_MFP: PA0_MFP Position            */
N#define SYS_PA_L_MFP_PA0_MFP_Msk         (0x7ul << SYS_PA_L_MFP_PA0_MFP_Pos)               /*!< SYS_T::PA_L_MFP: PA0_MFP Mask                */
N
N#define SYS_PA_L_MFP_PA1_MFP_Pos         (4)                                               /*!< SYS_T::PA_L_MFP: PA1_MFP Position            */
N#define SYS_PA_L_MFP_PA1_MFP_Msk         (0x7ul << SYS_PA_L_MFP_PA1_MFP_Pos)               /*!< SYS_T::PA_L_MFP: PA1_MFP Mask                */
N
N#define SYS_PA_L_MFP_PA2_MFP_Pos         (8)                                               /*!< SYS_T::PA_L_MFP: PA2_MFP Position            */
N#define SYS_PA_L_MFP_PA2_MFP_Msk         (0x7ul << SYS_PA_L_MFP_PA2_MFP_Pos)               /*!< SYS_T::PA_L_MFP: PA2_MFP Mask                */
N
N#define SYS_PA_L_MFP_PA3_MFP_Pos         (12)                                              /*!< SYS_T::PA_L_MFP: PA3_MFP Position            */
N#define SYS_PA_L_MFP_PA3_MFP_Msk         (0x7ul << SYS_PA_L_MFP_PA3_MFP_Pos)               /*!< SYS_T::PA_L_MFP: PA3_MFP Mask                */
N
N#define SYS_PA_L_MFP_PA4_MFP_Pos         (16)                                              /*!< SYS_T::PA_L_MFP: PA4_MFP Position            */
N#define SYS_PA_L_MFP_PA4_MFP_Msk         (0x7ul << SYS_PA_L_MFP_PA4_MFP_Pos)               /*!< SYS_T::PA_L_MFP: PA4_MFP Mask                */
N
N#define SYS_PA_L_MFP_PA5_MFP_Pos         (20)                                              /*!< SYS_T::PA_L_MFP: PA5_MFP Position            */
N#define SYS_PA_L_MFP_PA5_MFP_Msk         (0x7ul << SYS_PA_L_MFP_PA5_MFP_Pos)               /*!< SYS_T::PA_L_MFP: PA5_MFP Mask                */
N
N#define SYS_PA_L_MFP_PA6_MFP_Pos         (24)                                              /*!< SYS_T::PA_L_MFP: PA6_MFP Position            */
N#define SYS_PA_L_MFP_PA6_MFP_Msk         (0x7ul << SYS_PA_L_MFP_PA6_MFP_Pos)               /*!< SYS_T::PA_L_MFP: PA6_MFP Mask                */
N
N#define SYS_PA_L_MFP_PA7_MFP_Pos         (28)                                              /*!< SYS_T::PA_L_MFP: PA7_MFP Position            */
N#define SYS_PA_L_MFP_PA7_MFP_Msk         (0x7ul << SYS_PA_L_MFP_PA7_MFP_Pos)               /*!< SYS_T::PA_L_MFP: PA7_MFP Mask                */
N
N#define SYS_PA_H_MFP_PA8_MFP_Pos         (0)                                               /*!< SYS_T::PA_H_MFP: PA8_MFP Position            */
N#define SYS_PA_H_MFP_PA8_MFP_Msk         (0x7ul << SYS_PA_H_MFP_PA8_MFP_Pos)               /*!< SYS_T::PA_H_MFP: PA8_MFP Mask                */
N
N#define SYS_PA_H_MFP_PA9_MFP_Pos         (4)                                               /*!< SYS_T::PA_H_MFP: PA9_MFP Position            */
N#define SYS_PA_H_MFP_PA9_MFP_Msk         (0x7ul << SYS_PA_H_MFP_PA9_MFP_Pos)               /*!< SYS_T::PA_H_MFP: PA9_MFP Mask                */
N
N#define SYS_PA_H_MFP_PA10_MFP_Pos        (8)                                               /*!< SYS_T::PA_H_MFP: PA10_MFP Position           */
N#define SYS_PA_H_MFP_PA10_MFP_Msk        (0x7ul << SYS_PA_H_MFP_PA10_MFP_Pos)              /*!< SYS_T::PA_H_MFP: PA10_MFP Mask               */
N
N#define SYS_PA_H_MFP_PA11_MFP_Pos        (12)                                              /*!< SYS_T::PA_H_MFP: PA11_MFP Position           */
N#define SYS_PA_H_MFP_PA11_MFP_Msk        (0x7ul << SYS_PA_H_MFP_PA11_MFP_Pos)              /*!< SYS_T::PA_H_MFP: PA11_MFP Mask               */
N
N#define SYS_PA_H_MFP_PA12_MFP_Pos        (16)                                              /*!< SYS_T::PA_H_MFP: PA12_MFP Position           */
N#define SYS_PA_H_MFP_PA12_MFP_Msk        (0x7ul << SYS_PA_H_MFP_PA12_MFP_Pos)              /*!< SYS_T::PA_H_MFP: PA12_MFP Mask               */
N
N#define SYS_PA_H_MFP_PA13_MFP_Pos        (20)                                              /*!< SYS_T::PA_H_MFP: PA13_MFP Position           */
N#define SYS_PA_H_MFP_PA13_MFP_Msk        (0x7ul << SYS_PA_H_MFP_PA13_MFP_Pos)              /*!< SYS_T::PA_H_MFP: PA13_MFP Mask               */
N
N#define SYS_PA_H_MFP_PA14_MFP_Pos        (24)                                              /*!< SYS_T::PA_H_MFP: PA14_MFP Position           */
N#define SYS_PA_H_MFP_PA14_MFP_Msk        (0x7ul << SYS_PA_H_MFP_PA14_MFP_Pos)              /*!< SYS_T::PA_H_MFP: PA14_MFP Mask               */
N
N#define SYS_PA_H_MFP_PA15_MFP_Pos        (28)                                              /*!< SYS_T::PA_H_MFP: PA15_MFP Position           */
N#define SYS_PA_H_MFP_PA15_MFP_Msk        (0x7ul << SYS_PA_H_MFP_PA15_MFP_Pos)              /*!< SYS_T::PA_H_MFP: PA15_MFP Mask               */
N
N#define SYS_PB_L_MFP_PB0_MFP_Pos         (0)                                               /*!< SYS_T::PB_L_MFP: PB0_MFP Position            */
N#define SYS_PB_L_MFP_PB0_MFP_Msk         (0x7ul << SYS_PB_L_MFP_PB0_MFP_Pos)               /*!< SYS_T::PB_L_MFP: PB0_MFP Mask                */
N
N#define SYS_PB_L_MFP_PB1_MFP_Pos         (4)                                               /*!< SYS_T::PB_L_MFP: PB1_MFP Position            */
N#define SYS_PB_L_MFP_PB1_MFP_Msk         (0x7ul << SYS_PB_L_MFP_PB1_MFP_Pos)               /*!< SYS_T::PB_L_MFP: PB1_MFP Mask                */
N
N#define SYS_PB_L_MFP_PB2_MFP_Pos         (8)                                               /*!< SYS_T::PB_L_MFP: PB2_MFP Position            */
N#define SYS_PB_L_MFP_PB2_MFP_Msk         (0x7ul << SYS_PB_L_MFP_PB2_MFP_Pos)               /*!< SYS_T::PB_L_MFP: PB2_MFP Mask                */
N
N#define SYS_PB_L_MFP_PB3_MFP_Pos         (12)                                              /*!< SYS_T::PB_L_MFP: PB3_MFP Position            */
N#define SYS_PB_L_MFP_PB3_MFP_Msk         (0x7ul << SYS_PB_L_MFP_PB3_MFP_Pos)               /*!< SYS_T::PB_L_MFP: PB3_MFP Mask                */
N
N#define SYS_PB_L_MFP_PB4_MFP_Pos         (16)                                              /*!< SYS_T::PB_L_MFP: PB4_MFP Position            */
N#define SYS_PB_L_MFP_PB4_MFP_Msk         (0x7ul << SYS_PB_L_MFP_PB4_MFP_Pos)               /*!< SYS_T::PB_L_MFP: PB4_MFP Mask                */
N
N#define SYS_PB_L_MFP_PB5_MFP_Pos         (20)                                              /*!< SYS_T::PB_L_MFP: PB5_MFP Position            */
N#define SYS_PB_L_MFP_PB5_MFP_Msk         (0x7ul << SYS_PB_L_MFP_PB5_MFP_Pos)               /*!< SYS_T::PB_L_MFP: PB5_MFP Mask                */
N
N#define SYS_PB_L_MFP_PB6_MFP_Pos         (24)                                              /*!< SYS_T::PB_L_MFP: PB6_MFP Position            */
N#define SYS_PB_L_MFP_PB6_MFP_Msk         (0x7ul << SYS_PB_L_MFP_PB6_MFP_Pos)               /*!< SYS_T::PB_L_MFP: PB6_MFP Mask                */
N
N#define SYS_PB_L_MFP_PB7_MFP_Pos         (28)                                              /*!< SYS_T::PB_L_MFP: PB7_MFP Position            */
N#define SYS_PB_L_MFP_PB7_MFP_Msk         (0x7ul << SYS_PB_L_MFP_PB7_MFP_Pos)               /*!< SYS_T::PB_L_MFP: PB7_MFP Mask                */
N
N#define SYS_PB_H_MFP_PB8_MFP_Pos         (0)                                               /*!< SYS_T::PB_H_MFP: PB8_MFP Position            */
N#define SYS_PB_H_MFP_PB8_MFP_Msk         (0x7ul << SYS_PB_H_MFP_PB8_MFP_Pos)               /*!< SYS_T::PB_H_MFP: PB8_MFP Mask                */
N
N#define SYS_PB_H_MFP_PB9_MFP_Pos         (4)                                               /*!< SYS_T::PB_H_MFP: PB9_MFP Position            */
N#define SYS_PB_H_MFP_PB9_MFP_Msk         (0x7ul << SYS_PB_H_MFP_PB9_MFP_Pos)               /*!< SYS_T::PB_H_MFP: PB9_MFP Mask                */
N
N#define SYS_PB_H_MFP_PB10_MFP_Pos        (8)                                               /*!< SYS_T::PB_H_MFP: PB10_MFP Position           */
N#define SYS_PB_H_MFP_PB10_MFP_Msk        (0x7ul << SYS_PB_H_MFP_PB10_MFP_Pos)              /*!< SYS_T::PB_H_MFP: PB10_MFP Mask               */
N
N#define SYS_PB_H_MFP_PB11_MFP_Pos        (12)                                              /*!< SYS_T::PB_H_MFP: PB11_MFP Position           */
N#define SYS_PB_H_MFP_PB11_MFP_Msk        (0x7ul << SYS_PB_H_MFP_PB11_MFP_Pos)              /*!< SYS_T::PB_H_MFP: PB11_MFP Mask               */
N
N#define SYS_PB_H_MFP_PB12_MFP_Pos        (16)                                              /*!< SYS_T::PB_H_MFP: PB12_MFP Position           */
N#define SYS_PB_H_MFP_PB12_MFP_Msk        (0x7ul << SYS_PB_H_MFP_PB12_MFP_Pos)              /*!< SYS_T::PB_H_MFP: PB12_MFP Mask               */
N
N#define SYS_PB_H_MFP_PB13_MFP_Pos        (20)                                              /*!< SYS_T::PB_H_MFP: PB13_MFP Position           */
N#define SYS_PB_H_MFP_PB13_MFP_Msk        (0x7ul << SYS_PB_H_MFP_PB13_MFP_Pos)              /*!< SYS_T::PB_H_MFP: PB13_MFP Mask               */
N
N#define SYS_PB_H_MFP_PB14_MFP_Pos        (24)                                              /*!< SYS_T::PB_H_MFP: PB14_MFP Position           */
N#define SYS_PB_H_MFP_PB14_MFP_Msk        (0x7ul << SYS_PB_H_MFP_PB14_MFP_Pos)              /*!< SYS_T::PB_H_MFP: PB14_MFP Mask               */
N
N#define SYS_PB_H_MFP_PB15_MFP_Pos        (28)                                              /*!< SYS_T::PB_H_MFP: PB15_MFP Position           */
N#define SYS_PB_H_MFP_PB15_MFP_Msk        (0x7ul << SYS_PB_H_MFP_PB15_MFP_Pos)              /*!< SYS_T::PB_H_MFP: PB15_MFP Mask               */
N
N#define SYS_PC_L_MFP_PC0_MFP_Pos         (0)                                               /*!< SYS_T::PC_L_MFP: PC0_MFP Position            */
N#define SYS_PC_L_MFP_PC0_MFP_Msk         (0x7ul << SYS_PC_L_MFP_PC0_MFP_Pos)               /*!< SYS_T::PC_L_MFP: PC0_MFP Mask                */
N
N#define SYS_PC_L_MFP_PC1_MFP_Pos         (4)                                               /*!< SYS_T::PC_L_MFP: PC1_MFP Position            */
N#define SYS_PC_L_MFP_PC1_MFP_Msk         (0x7ul << SYS_PC_L_MFP_PC1_MFP_Pos)               /*!< SYS_T::PC_L_MFP: PC1_MFP Mask                */
N
N#define SYS_PC_L_MFP_PC2_MFP_Pos         (8)                                               /*!< SYS_T::PC_L_MFP: PC2_MFP Position            */
N#define SYS_PC_L_MFP_PC2_MFP_Msk         (0x7ul << SYS_PC_L_MFP_PC2_MFP_Pos)               /*!< SYS_T::PC_L_MFP: PC2_MFP Mask                */
N
N#define SYS_PC_L_MFP_PC3_MFP_Pos         (12)                                              /*!< SYS_T::PC_L_MFP: PC3_MFP Position            */
N#define SYS_PC_L_MFP_PC3_MFP_Msk         (0x7ul << SYS_PC_L_MFP_PC3_MFP_Pos)               /*!< SYS_T::PC_L_MFP: PC3_MFP Mask                */
N
N#define SYS_PC_L_MFP_PC4_MFP_Pos         (16)                                              /*!< SYS_T::PC_L_MFP: PC4_MFP Position            */
N#define SYS_PC_L_MFP_PC4_MFP_Msk         (0x7ul << SYS_PC_L_MFP_PC4_MFP_Pos)               /*!< SYS_T::PC_L_MFP: PC4_MFP Mask                */
N
N#define SYS_PC_L_MFP_PC5_MFP_Pos         (20)                                              /*!< SYS_T::PC_L_MFP: PC5_MFP Position            */
N#define SYS_PC_L_MFP_PC5_MFP_Msk         (0x7ul << SYS_PC_L_MFP_PC5_MFP_Pos)               /*!< SYS_T::PC_L_MFP: PC5_MFP Mask                */
N
N#define SYS_PC_L_MFP_PC6_MFP_Pos         (24)                                              /*!< SYS_T::PC_L_MFP: PC6_MFP Position            */
N#define SYS_PC_L_MFP_PC6_MFP_Msk         (0x7ul << SYS_PC_L_MFP_PC6_MFP_Pos)               /*!< SYS_T::PC_L_MFP: PC6_MFP Mask                */
N
N#define SYS_PC_L_MFP_PC7_MFP_Pos         (28)                                              /*!< SYS_T::PC_L_MFP: PC7_MFP Position            */
N#define SYS_PC_L_MFP_PC7_MFP_Msk         (0x7ul << SYS_PC_L_MFP_PC7_MFP_Pos)               /*!< SYS_T::PC_L_MFP: PC7_MFP Mask                */
N
N#define SYS_PC_H_MFP_PC8_MFP_Pos         (0)                                               /*!< SYS_T::PC_H_MFP: PC8_MFP Position            */
N#define SYS_PC_H_MFP_PC8_MFP_Msk         (0x7ul << SYS_PC_H_MFP_PC8_MFP_Pos)               /*!< SYS_T::PC_H_MFP: PC8_MFP Mask                */
N
N#define SYS_PC_H_MFP_PC9_MFP_Pos         (4)                                               /*!< SYS_T::PC_H_MFP: PC9_MFP Position            */
N#define SYS_PC_H_MFP_PC9_MFP_Msk         (0x7ul << SYS_PC_H_MFP_PC9_MFP_Pos)               /*!< SYS_T::PC_H_MFP: PC9_MFP Mask                */
N
N#define SYS_PC_H_MFP_PC10_MFP_Pos        (8)                                               /*!< SYS_T::PC_H_MFP: PC10_MFP Position           */
N#define SYS_PC_H_MFP_PC10_MFP_Msk        (0x7ul << SYS_PC_H_MFP_PC10_MFP_Pos)              /*!< SYS_T::PC_H_MFP: PC10_MFP Mask               */
N
N#define SYS_PC_H_MFP_PC11_MFP_Pos        (12)                                              /*!< SYS_T::PC_H_MFP: PC11_MFP Position           */
N#define SYS_PC_H_MFP_PC11_MFP_Msk        (0x7ul << SYS_PC_H_MFP_PC11_MFP_Pos)              /*!< SYS_T::PC_H_MFP: PC11_MFP Mask               */
N
N#define SYS_PC_H_MFP_PC12_MFP_Pos        (16)                                              /*!< SYS_T::PC_H_MFP: PC12_MFP Position           */
N#define SYS_PC_H_MFP_PC12_MFP_Msk        (0x7ul << SYS_PC_H_MFP_PC12_MFP_Pos)              /*!< SYS_T::PC_H_MFP: PC12_MFP Mask               */
N
N#define SYS_PC_H_MFP_PC13_MFP_Pos        (20)                                              /*!< SYS_T::PC_H_MFP: PC13_MFP Position           */
N#define SYS_PC_H_MFP_PC13_MFP_Msk        (0x7ul << SYS_PC_H_MFP_PC13_MFP_Pos)              /*!< SYS_T::PC_H_MFP: PC13_MFP Mask               */
N
N#define SYS_PC_H_MFP_PC14_MFP_Pos        (24)                                              /*!< SYS_T::PC_H_MFP: PC14_MFP Position           */
N#define SYS_PC_H_MFP_PC14_MFP_Msk        (0x7ul << SYS_PC_H_MFP_PC14_MFP_Pos)              /*!< SYS_T::PC_H_MFP: PC14_MFP Mask               */
N
N#define SYS_PC_H_MFP_PC15_MFP_Pos        (28)                                              /*!< SYS_T::PC_H_MFP: PC15_MFP Position           */
N#define SYS_PC_H_MFP_PC15_MFP_Msk        (0x7ul << SYS_PC_H_MFP_PC15_MFP_Pos)              /*!< SYS_T::PC_H_MFP: PC15_MFP Mask               */
N
N#define SYS_PD_L_MFP_PD0_MFP_Pos         (0)                                               /*!< SYS_T::PD_L_MFP: PD0_MFP Position            */
N#define SYS_PD_L_MFP_PD0_MFP_Msk         (0x7ul << SYS_PD_L_MFP_PD0_MFP_Pos)               /*!< SYS_T::PD_L_MFP: PD0_MFP Mask                */
N
N#define SYS_PD_L_MFP_PD1_MFP_Pos         (4)                                               /*!< SYS_T::PD_L_MFP: PD1_MFP Position            */
N#define SYS_PD_L_MFP_PD1_MFP_Msk         (0x7ul << SYS_PD_L_MFP_PD1_MFP_Pos)               /*!< SYS_T::PD_L_MFP: PD1_MFP Mask                */
N
N#define SYS_PD_L_MFP_PD2_MFP_Pos         (8)                                               /*!< SYS_T::PD_L_MFP: PD2_MFP Position            */
N#define SYS_PD_L_MFP_PD2_MFP_Msk         (0x7ul << SYS_PD_L_MFP_PD2_MFP_Pos)               /*!< SYS_T::PD_L_MFP: PD2_MFP Mask                */
N
N#define SYS_PD_L_MFP_PD3_MFP_Pos         (12)                                              /*!< SYS_T::PD_L_MFP: PD3_MFP Position            */
N#define SYS_PD_L_MFP_PD3_MFP_Msk         (0x7ul << SYS_PD_L_MFP_PD3_MFP_Pos)               /*!< SYS_T::PD_L_MFP: PD3_MFP Mask                */
N
N#define SYS_PD_L_MFP_PD4_MFP_Pos         (16)                                              /*!< SYS_T::PD_L_MFP: PD4_MFP Position            */
N#define SYS_PD_L_MFP_PD4_MFP_Msk         (0x7ul << SYS_PD_L_MFP_PD4_MFP_Pos)               /*!< SYS_T::PD_L_MFP: PD4_MFP Mask                */
N
N#define SYS_PD_L_MFP_PD5_MFP_Pos         (20)                                              /*!< SYS_T::PD_L_MFP: PD5_MFP Position            */
N#define SYS_PD_L_MFP_PD5_MFP_Msk         (0x7ul << SYS_PD_L_MFP_PD5_MFP_Pos)               /*!< SYS_T::PD_L_MFP: PD5_MFP Mask                */
N
N#define SYS_PD_L_MFP_PD6_MFP_Pos         (24)                                              /*!< SYS_T::PD_L_MFP: PD6_MFP Position            */
N#define SYS_PD_L_MFP_PD6_MFP_Msk         (0x7ul << SYS_PD_L_MFP_PD6_MFP_Pos)               /*!< SYS_T::PD_L_MFP: PD6_MFP Mask                */
N
N#define SYS_PD_L_MFP_PD7_MFP_Pos         (28)                                              /*!< SYS_T::PD_L_MFP: PD7_MFP Position            */
N#define SYS_PD_L_MFP_PD7_MFP_Msk         (0x7ul << SYS_PD_L_MFP_PD7_MFP_Pos)               /*!< SYS_T::PD_L_MFP: PD7_MFP Mask                */
N
N#define SYS_PD_H_MFP_PD8_MFP_Pos         (0)                                               /*!< SYS_T::PD_H_MFP: PD8_MFP Position            */
N#define SYS_PD_H_MFP_PD8_MFP_Msk         (0x7ul << SYS_PD_H_MFP_PD8_MFP_Pos)               /*!< SYS_T::PD_H_MFP: PD8_MFP Mask                */
N
N#define SYS_PD_H_MFP_PD9_MFP_Pos         (4)                                               /*!< SYS_T::PD_H_MFP: PD9_MFP Position            */
N#define SYS_PD_H_MFP_PD9_MFP_Msk         (0x7ul << SYS_PD_H_MFP_PD9_MFP_Pos)               /*!< SYS_T::PD_H_MFP: PD9_MFP Mask                */
N
N#define SYS_PD_H_MFP_PD10_MFP_Pos        (8)                                               /*!< SYS_T::PD_H_MFP: PD10_MFP Position           */
N#define SYS_PD_H_MFP_PD10_MFP_Msk        (0x7ul << SYS_PD_H_MFP_PD10_MFP_Pos)              /*!< SYS_T::PD_H_MFP: PD10_MFP Mask               */
N
N#define SYS_PD_H_MFP_PD11_MFP_Pos        (12)                                              /*!< SYS_T::PD_H_MFP: PD11_MFP Position           */
N#define SYS_PD_H_MFP_PD11_MFP_Msk        (0x7ul << SYS_PD_H_MFP_PD11_MFP_Pos)              /*!< SYS_T::PD_H_MFP: PD11_MFP Mask               */
N
N#define SYS_PD_H_MFP_PD12_MFP_Pos        (16)                                              /*!< SYS_T::PD_H_MFP: PD12_MFP Position           */
N#define SYS_PD_H_MFP_PD12_MFP_Msk        (0x7ul << SYS_PD_H_MFP_PD12_MFP_Pos)              /*!< SYS_T::PD_H_MFP: PD12_MFP Mask               */
N
N#define SYS_PD_H_MFP_PD13_MFP_Pos        (20)                                              /*!< SYS_T::PD_H_MFP: PD13_MFP Position           */
N#define SYS_PD_H_MFP_PD13_MFP_Msk        (0x7ul << SYS_PD_H_MFP_PD13_MFP_Pos)              /*!< SYS_T::PD_H_MFP: PD13_MFP Mask               */
N
N#define SYS_PD_H_MFP_PD14_MFP_Pos        (24)                                              /*!< SYS_T::PD_H_MFP: PD14_MFP Position           */
N#define SYS_PD_H_MFP_PD14_MFP_Msk        (0x7ul << SYS_PD_H_MFP_PD14_MFP_Pos)              /*!< SYS_T::PD_H_MFP: PD14_MFP Mask               */
N
N#define SYS_PD_H_MFP_PD15_MFP_Pos        (28)                                              /*!< SYS_T::PD_H_MFP: PD15_MFP Position           */
N#define SYS_PD_H_MFP_PD15_MFP_Msk        (0x7ul << SYS_PD_H_MFP_PD15_MFP_Pos)              /*!< SYS_T::PD_H_MFP: PD15_MFP Mask               */
N
N#define SYS_PE_L_MFP_PE0_MFP_Pos         (0)                                               /*!< SYS_T::PE_L_MFP: PE0_MFP Position            */
N#define SYS_PE_L_MFP_PE0_MFP_Msk         (0x7ul << SYS_PE_L_MFP_PE0_MFP_Pos)               /*!< SYS_T::PE_L_MFP: PE0_MFP Mask                */
N
N#define SYS_PE_L_MFP_PE1_MFP_Pos         (4)                                               /*!< SYS_T::PE_L_MFP: PE1_MFP Position            */
N#define SYS_PE_L_MFP_PE1_MFP_Msk         (0x7ul << SYS_PE_L_MFP_PE1_MFP_Pos)               /*!< SYS_T::PE_L_MFP: PE1_MFP Mask                */
N
N#define SYS_PE_L_MFP_PE2_MFP_Pos         (8)                                               /*!< SYS_T::PE_L_MFP: PE2_MFP Position            */
N#define SYS_PE_L_MFP_PE2_MFP_Msk         (0x7ul << SYS_PE_L_MFP_PE2_MFP_Pos)               /*!< SYS_T::PE_L_MFP: PE2_MFP Mask                */
N
N#define SYS_PE_L_MFP_PE3_MFP_Pos         (12)                                              /*!< SYS_T::PE_L_MFP: PE3_MFP Position            */
N#define SYS_PE_L_MFP_PE3_MFP_Msk         (0x7ul << SYS_PE_L_MFP_PE3_MFP_Pos)               /*!< SYS_T::PE_L_MFP: PE3_MFP Mask                */
N
N#define SYS_PE_L_MFP_PE4_MFP_Pos         (16)                                              /*!< SYS_T::PE_L_MFP: PE4_MFP Position            */
N#define SYS_PE_L_MFP_PE4_MFP_Msk         (0x7ul << SYS_PE_L_MFP_PE4_MFP_Pos)               /*!< SYS_T::PE_L_MFP: PE4_MFP Mask                */
N
N#define SYS_PE_L_MFP_PE5_MFP_Pos         (20)                                              /*!< SYS_T::PE_L_MFP: PE5_MFP Position            */
N#define SYS_PE_L_MFP_PE5_MFP_Msk         (0x7ul << SYS_PE_L_MFP_PE5_MFP_Pos)               /*!< SYS_T::PE_L_MFP: PE5_MFP Mask                */
N
N#define SYS_PE_L_MFP_PE6_MFP_Pos         (24)                                              /*!< SYS_T::PE_L_MFP: PE6_MFP Position            */
N#define SYS_PE_L_MFP_PE6_MFP_Msk         (0x7ul << SYS_PE_L_MFP_PE6_MFP_Pos)               /*!< SYS_T::PE_L_MFP: PE6_MFP Mask                */
N
N#define SYS_PE_L_MFP_PE7_MFP_Pos         (28)                                              /*!< SYS_T::PE_L_MFP: PE7_MFP Position            */
N#define SYS_PE_L_MFP_PE7_MFP_Msk         (0x7ul << SYS_PE_L_MFP_PE7_MFP_Pos)               /*!< SYS_T::PE_L_MFP: PE7_MFP Mask                */
N
N#define SYS_PE_H_MFP_PE8_MFP_Pos         (0)                                               /*!< SYS_T::PE_H_MFP: PE8_MFP Position            */
N#define SYS_PE_H_MFP_PE8_MFP_Msk         (0x7ul << SYS_PE_H_MFP_PE8_MFP_Pos)               /*!< SYS_T::PE_H_MFP: PE8_MFP Mask                */
N
N#define SYS_PE_H_MFP_PE9_MFP_Pos         (4)                                               /*!< SYS_T::PE_H_MFP: PE9_MFP Position            */
N#define SYS_PE_H_MFP_PE9_MFP_Msk         (0x7ul << SYS_PE_H_MFP_PE9_MFP_Pos)               /*!< SYS_T::PE_H_MFP: PE9_MFP Mask                */
N
N#define SYS_PE_H_MFP_PE10_MFP_Pos        (8)                                               /*!< SYS_T::PE_H_MFP: PE10_MFP Position           */
N#define SYS_PE_H_MFP_PE10_MFP_Msk        (0x7ul << SYS_PE_H_MFP_PE10_MFP_Pos)              /*!< SYS_T::PE_H_MFP: PE10_MFP Mask               */
N
N#define SYS_PE_H_MFP_PE11_MFP_Pos        (12)                                              /*!< SYS_T::PE_H_MFP: PE11_MFP Position           */
N#define SYS_PE_H_MFP_PE11_MFP_Msk        (0x7ul << SYS_PE_H_MFP_PE11_MFP_Pos)              /*!< SYS_T::PE_H_MFP: PE11_MFP Mask               */
N
N#define SYS_PE_H_MFP_PE12_MFP_Pos        (16)                                              /*!< SYS_T::PE_H_MFP: PE12_MFP Position           */
N#define SYS_PE_H_MFP_PE12_MFP_Msk        (0x7ul << SYS_PE_H_MFP_PE12_MFP_Pos)              /*!< SYS_T::PE_H_MFP: PE12_MFP Mask               */
N
N#define SYS_PE_H_MFP_PE13_MFP_Pos        (20)                                              /*!< SYS_T::PE_H_MFP: PE13_MFP Position           */
N#define SYS_PE_H_MFP_PE13_MFP_Msk        (0x7ul << SYS_PE_H_MFP_PE13_MFP_Pos)              /*!< SYS_T::PE_H_MFP: PE13_MFP Mask               */
N
N#define SYS_PE_H_MFP_PE14_MFP_Pos        (24)                                              /*!< SYS_T::PE_H_MFP: PE14_MFP Position           */
N#define SYS_PE_H_MFP_PE14_MFP_Msk        (0x7ul << SYS_PE_H_MFP_PE14_MFP_Pos)              /*!< SYS_T::PE_H_MFP: PE14_MFP Mask               */
N
N#define SYS_PE_H_MFP_PE15_MFP_Pos        (28)                                              /*!< SYS_T::PE_H_MFP: PE15_MFP Position           */
N#define SYS_PE_H_MFP_PE15_MFP_Msk        (0x7ul << SYS_PE_H_MFP_PE15_MFP_Pos)              /*!< SYS_T::PE_H_MFP: PE15_MFP Mask               */
N
N#define SYS_PF_L_MFP_PF0_MFP_Pos         (0)                                               /*!< SYS_T::PF_L_MFP: PF0_MFP Position            */
N#define SYS_PF_L_MFP_PF0_MFP_Msk         (0x7ul << SYS_PF_L_MFP_PF0_MFP_Pos)               /*!< SYS_T::PF_L_MFP: PF0_MFP Mask                */
N
N#define SYS_PF_L_MFP_PF1_MFP_Pos         (4)                                               /*!< SYS_T::PF_L_MFP: PF1_MFP Position            */
N#define SYS_PF_L_MFP_PF1_MFP_Msk         (0x7ul << SYS_PF_L_MFP_PF1_MFP_Pos)               /*!< SYS_T::PF_L_MFP: PF1_MFP Mask                */
N
N#define SYS_PF_L_MFP_PF2_MFP_Pos         (8)                                               /*!< SYS_T::PF_L_MFP: PF2_MFP Position            */
N#define SYS_PF_L_MFP_PF2_MFP_Msk         (0x7ul << SYS_PF_L_MFP_PF2_MFP_Pos)               /*!< SYS_T::PF_L_MFP: PF2_MFP Mask                */
N
N#define SYS_PF_L_MFP_PF3_MFP_Pos         (12)                                              /*!< SYS_T::PF_L_MFP: PF3_MFP Position            */
N#define SYS_PF_L_MFP_PF3_MFP_Msk         (0x7ul << SYS_PF_L_MFP_PF3_MFP_Pos)               /*!< SYS_T::PF_L_MFP: PF3_MFP Mask                */
N
N#define SYS_PF_L_MFP_PF4_MFP_Pos         (16)                                              /*!< SYS_T::PF_L_MFP: PF4_MFP Position            */
N#define SYS_PF_L_MFP_PF4_MFP_Msk         (0x7ul << SYS_PF_L_MFP_PF4_MFP_Pos)               /*!< SYS_T::PF_L_MFP: PF4_MFP Mask                */
N
N#define SYS_PF_L_MFP_PF5_MFP_Pos         (20)                                              /*!< SYS_T::PF_L_MFP: PF5_MFP Position            */
N#define SYS_PF_L_MFP_PF5_MFP_Msk         (0x7ul << SYS_PF_L_MFP_PF5_MFP_Pos)               /*!< SYS_T::PF_L_MFP: PF5_MFP Mask                */
N
N#define SYS_PORCTL_POR_DIS_CODE_Pos      (0)                                               /*!< SYS_T::PORCTL: POR_DIS_CODE Position      */
N#define SYS_PORCTL_POR_DIS_CODE_Msk      (0xfffful << SYS_PORCTL_POR_DIS_CODE_Pos)         /*!< SYS_T::PORCTL: POR_DIS_CODE Mask          */
N
N#define SYS_BODCTL_BOD17_EN_Pos          (0)                                               /*!< SYS_T::BODCTL: BOD17_EN Position          */
N#define SYS_BODCTL_BOD17_EN_Msk          (0x1ul << SYS_BODCTL_BOD17_EN_Pos)                /*!< SYS_T::BODCTL: BOD17_EN Mask              */
N
N#define SYS_BODCTL_BOD20_EN_Pos          (1)                                               /*!< SYS_T::BODCTL: BOD20_EN Position          */
N#define SYS_BODCTL_BOD20_EN_Msk          (0x1ul << SYS_BODCTL_BOD20_EN_Pos)                /*!< SYS_T::BODCTL: BOD20_EN Mask              */
N
N#define SYS_BODCTL_BOD25_EN_Pos          (2)                                               /*!< SYS_T::BODCTL: BOD25_EN Position          */
N#define SYS_BODCTL_BOD25_EN_Msk          (0x1ul << SYS_BODCTL_BOD25_EN_Pos)                /*!< SYS_T::BODCTL: BOD25_EN Mask              */
N
N#define SYS_BODCTL_BOD17_RST_EN_Pos      (4)                                               /*!< SYS_T::BODCTL: BOD17_RST_EN Position      */
N#define SYS_BODCTL_BOD17_RST_EN_Msk      (0x1ul << SYS_BODCTL_BOD17_RST_EN_Pos)            /*!< SYS_T::BODCTL: BOD17_RST_EN Mask          */
N
N#define SYS_BODCTL_BOD20_RST_EN_Pos      (5)                                               /*!< SYS_T::BODCTL: BOD20_RST_EN Position      */
N#define SYS_BODCTL_BOD20_RST_EN_Msk      (0x1ul << SYS_BODCTL_BOD20_RST_EN_Pos)            /*!< SYS_T::BODCTL: BOD20_RST_EN Mask          */
N
N#define SYS_BODCTL_BOD25_RST_EN_Pos      (6)                                               /*!< SYS_T::BODCTL: BOD25_RST_EN Position      */
N#define SYS_BODCTL_BOD25_RST_EN_Msk      (0x1ul << SYS_BODCTL_BOD25_RST_EN_Pos)            /*!< SYS_T::BODCTL: BOD25_RST_EN Mask          */
N
N#define SYS_BODCTL_BOD17_INT_EN_Pos      (8)                                               /*!< SYS_T::BODCTL: BOD17_INT_EN Position      */
N#define SYS_BODCTL_BOD17_INT_EN_Msk      (0x1ul << SYS_BODCTL_BOD17_INT_EN_Pos)            /*!< SYS_T::BODCTL: BOD17_INT_EN Mask          */
N
N#define SYS_BODCTL_BOD20_INT_EN_Pos      (9)                                               /*!< SYS_T::BODCTL: BOD20_INT_EN Position      */
N#define SYS_BODCTL_BOD20_INT_EN_Msk      (0x1ul << SYS_BODCTL_BOD20_INT_EN_Pos)            /*!< SYS_T::BODCTL: BOD20_INT_EN Mask          */
N
N#define SYS_BODCTL_BOD25_INT_EN_Pos      (10)                                              /*!< SYS_T::BODCTL: BOD25_INT_EN Position      */
N#define SYS_BODCTL_BOD25_INT_EN_Msk      (0x1ul << SYS_BODCTL_BOD25_INT_EN_Pos)            /*!< SYS_T::BODCTL: BOD25_INT_EN Mask          */
N
N#define SYS_BODSTS_BOD_INT_Pos           (0)                                               /*!< SYS_T::BODSTS: BOD_INT Position           */
N#define SYS_BODSTS_BOD_INT_Msk           (0x1ul << SYS_BODSTS_BOD_INT_Pos)                 /*!< SYS_T::BODSTS: BOD_INT Mask               */
N
N#define SYS_BODSTS_BOD17_drop_Pos        (1)                                               /*!< SYS_T::BODSTS: BOD17_drop Position        */
N#define SYS_BODSTS_BOD17_drop_Msk        (0x1ul << SYS_BODSTS_BOD17_drop_Pos)              /*!< SYS_T::BODSTS: BOD17_drop Mask            */
N
N#define SYS_BODSTS_BOD20_drop_Pos        (2)                                               /*!< SYS_T::BODSTS: BOD20_drop Position        */
N#define SYS_BODSTS_BOD20_drop_Msk        (0x1ul << SYS_BODSTS_BOD20_drop_Pos)              /*!< SYS_T::BODSTS: BOD20_drop Mask            */
N
N#define SYS_BODSTS_BOD25_drop_Pos        (3)                                               /*!< SYS_T::BODSTS: BOD25_drop Position        */
N#define SYS_BODSTS_BOD25_drop_Msk        (0x1ul << SYS_BODSTS_BOD25_drop_Pos)              /*!< SYS_T::BODSTS: BOD25_drop Mask            */
N
N#define SYS_BODSTS_BOD17_rise_Pos        (4)                                               /*!< SYS_T::BODSTS: BOD17_rise Position        */
N#define SYS_BODSTS_BOD17_rise_Msk        (0x1ul << SYS_BODSTS_BOD17_rise_Pos)              /*!< SYS_T::BODSTS: BOD17_rise Mask            */
N
N#define SYS_BODSTS_BOD20_rise_Pos        (5)                                               /*!< SYS_T::BODSTS: BOD20_rise Position        */
N#define SYS_BODSTS_BOD20_rise_Msk        (0x1ul << SYS_BODSTS_BOD20_rise_Pos)              /*!< SYS_T::BODSTS: BOD20_rise Mask            */
N
N#define SYS_BODSTS_BOD25_rise_Pos        (6)                                               /*!< SYS_T::BODSTS: BOD25_rise Position        */
N#define SYS_BODSTS_BOD25_rise_Msk        (0x1ul << SYS_BODSTS_BOD25_rise_Pos)              /*!< SYS_T::BODSTS: BOD25_rise Mask            */
N
N#define SYS_VREFCTL_BGP_EN_Pos           (0)                                               /*!< SYS_T::VREFCTL: BGP_EN Position           */
N#define SYS_VREFCTL_BGP_EN_Msk           (0x1ul << SYS_VREFCTL_BGP_EN_Pos)                 /*!< SYS_T::VREFCTL: BGP_EN Mask               */
N
N#define SYS_VREFCTL_REG_EN_Pos           (1)                                               /*!< SYS_T::VREFCTL: REG_EN Position           */
N#define SYS_VREFCTL_REG_EN_Msk           (0x1ul << SYS_VREFCTL_REG_EN_Pos)                 /*!< SYS_T::VREFCTL: REG_EN Mask               */
N
N#define SYS_VREFCTL_SEL25_Pos            (2)                                               /*!< SYS_T::VREFCTL: SEL25 Position            */
N#define SYS_VREFCTL_SEL25_Msk            (0x1ul << SYS_VREFCTL_SEL25_Pos)                  /*!< SYS_T::VREFCTL: SEL25 Mask                */
N
N#define SYS_VREFCTL_EXT_MODE_Pos         (3)                                               /*!< SYS_T::VREFCTL: EXT_MODE Position         */
N#define SYS_VREFCTL_EXT_MODE_Msk         (0x1ul << SYS_VREFCTL_EXT_MODE_Pos)               /*!< SYS_T::VREFCTL: EXT_MODE Mask             */
N
N#define SYS_IRCTRIMCTL_TRIM_SEL_Pos      (0)                                               /*!< SYS_T::IRCTRIMCTL: TRIM_SEL Position      */
N#define SYS_IRCTRIMCTL_TRIM_SEL_Msk      (0x3ul << SYS_IRCTRIMCTL_TRIM_SEL_Pos)            /*!< SYS_T::IRCTRIMCTL: TRIM_SEL Mask          */
N
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Pos     (4)                                               /*!< SYS_T::IRCTRIMCTL: TRIM_LOOP Position     */
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Msk     (0x3ul << SYS_IRCTRIMCTL_TRIM_LOOP_Pos)           /*!< SYS_T::IRCTRIMCTL: TRIM_LOOP Mask         */
N
N#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos (6)                                              /*!< SYS_T::IRCTRIMCTL: TRIM_RETRY_CNT Position*/
N#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Msk (0x3ul << SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos)     /*!< SYS_T::IRCTRIMCTL: TRIM_RETRY_CNT Mask    */
N
N#define SYS_IRCTRIMCTL_ERR_STOP_Pos      (8)                                               /*!< SYS_T::IRCTRIMCTL: ERR_STOP Position      */
N#define SYS_IRCTRIMCTL_ERR_STOP_Msk      (0x1ul << SYS_IRCTRIMCTL_ERR_STOP_Pos)            /*!< SYS_T::IRCTRIMCTL: ERR_STOP Mask          */
N
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos (1)                                               /*!< SYS_T::IRCTRIMIEN: TRIM_FAIL_IEN Position */
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Msk (0x1ul << SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos)       /*!< SYS_T::IRCTRIMIEN: TRIM_FAIL_IEN Mask     */
N
N#define SYS_IRCTRIMIEN_32K_ERR_IEN_Pos   (2)                                               /*!< SYS_T::IRCTRIMIEN: 32K_ERR_IEN Position   */
N#define SYS_IRCTRIMIEN_32K_ERR_IEN_Msk   (0x1ul << SYS_IRCTRIMIEN_32K_ERR_IEN_Pos)         /*!< SYS_T::IRCTRIMIEN: 32K_ERR_IEN Mask       */
N
N#define SYS_IRCTRIMINT_FREQ_LOCK_Pos     (0)                                               /*!< SYS_T::IRCTRIMINT: FREQ_LOCK Position     */
N#define SYS_IRCTRIMINT_FREQ_LOCK_Msk     (0x1ul << SYS_IRCTRIMINT_FREQ_LOCK_Pos)           /*!< SYS_T::IRCTRIMINT: FREQ_LOCK Mask         */
N
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos (1)                                               /*!< SYS_T::IRCTRIMINT: TRIM_FAIL_INT Position */
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Msk (0x1ul << SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos)       /*!< SYS_T::IRCTRIMINT: TRIM_FAIL_INT Mask     */
N
N#define SYS_IRCTRIMINT_32K_ERR_INT_Pos   (2)                                               /*!< SYS_T::IRCTRIMINT: 32K_ERR_INT Position   */
N#define SYS_IRCTRIMINT_32K_ERR_INT_Msk   (0x1ul << SYS_IRCTRIMINT_32K_ERR_INT_Pos)         /*!< SYS_T::IRCTRIMINT: 32K_ERR_INT Mask       */
N
N#define SYS_RegLockAddr_RegUnLock_Pos    (0)                                               /*!< SYS_T::RegLockAddr: RegUnLock Position    */
N#define SYS_RegLockAddr_RegUnLock_Msk    (0x1ul << SYS_RegLockAddr_RegUnLock_Pos)          /*!< SYS_T::RegLockAddr: RegUnLock Mask        */
N
N/**@}*/ /* SYS_CONST */
N/**@}*/ /* end of SYS register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * PMD
N     * ===================================================================================================
N     * Offset: 0x00  GPIO Port Pin I/O Mode Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |PMD0      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[3:2]   |PMD1      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[5:4]   |PMD2      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[7:6]   |PMD3      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[9:8]   |PMD4      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[11:10] |PMD5      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[13:12] |PMD6      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[15:14] |PMD7      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[17:16] |PMD8      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[19:18] |PMD9      |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[21:20] |PMD10     |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[23:22] |PMD11     |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[25:24] |PMD12     |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[27:26] |PMD13     |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[29:28] |PMD14     |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N     * |[31:30] |PMD15     |GPIO Port [X] Pin [N] Mode Control
N     * |        |          |Determine the I/O type of GPIO port [x] pin [n]
N     * |        |          |00 = GPIO port [x] pin [n] is in INPUT mode.
N     * |        |          |01 = GPIO port [x] pin [n] is in OUTPUT mode.
N     * |        |          |10 = GPIO port [x] pin [n] is in Open-Drain mode.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: For GPIOF_PMD, PMD6 ~ PMD15 are reserved.
N    */
N    __IO uint32_t PMD;
X    volatile uint32_t PMD;
N
N    /**
N     * OFFD
N     * ===================================================================================================
N     * Offset: 0x04  GPIO Port Pin OFF Digital Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:16] |OFFD      |GPIO Port [X] Pin [N] Digital Input Path Disable
N     * |        |          |Determine if the digital input path of GPIO port [x] pin [n] is disabled.
N     * |        |          |0 = Digital input path of GPIO port [x] pin [n] Enabled.
N     * |        |          |1 = Digital input path of GPIO port [x] pin [n] Disabled (tied digital input to low).
N     * |        |          |Note: For GPIOF_OFFD, bits [31:22] are reserved.
N    */
N    __IO uint32_t OFFD;
X    volatile uint32_t OFFD;
N
N    /**
N     * DOUT
N     * ===================================================================================================
N     * Offset: 0x08  GPIO Port Data Output Value Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |DOUT      |GPIO Port [X] Pin [N] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO port [x] pin [n] when the GPI/O pin is configures as output or open-drain mode
N     * |        |          |0 = GPIO port [x] Pin [n] will drive Low if the corresponding output mode enabling bit is set.
N     * |        |          |1 = GPIO port [x] Pin [n] will drive High if the corresponding output mode enabling bit is set.
N     * |        |          |Note: For GPIOF_DOUT, bits [15:6] are reserved.
N    */
N    __IO uint32_t DOUT;
X    volatile uint32_t DOUT;
N
N    /**
N     * DMASK
N     * ===================================================================================================
N     * Offset: 0x0C  GPIO Port Data Output Write Mask Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |DMASK     |GPIO Port [X] Pin [N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit [n].
N     * |        |          |When set the DMASK[n] to "1", the corresponding DOUT[n] bit is protected.
N     * |        |          |The write signal is masked, write data to the protect bit is ignored.
N     * |        |          |0 = The corresponding GPIO_DOUT bit [n] can be updated.
N     * |        |          |1 = The corresponding GPIO_DOUT bit [n] is protected.
N     * |        |          |Note: For GPIOF_DMASK, bits [15:6] are reserved.
N     * |        |          |Note: These mask bits only take effect while CPU is doing write operation to register GPIOx_DOUT.
N     * |        |          |If CPU is doing write operation to register GPIO[x][n], these mask bits will not take effect.
N    */
N    __IO uint32_t DMASK;
X    volatile uint32_t DMASK;
N
N    /**
N     * PIN
N     * ===================================================================================================
N     * Offset: 0x10  GPIO Port Pin Value Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PIN       |GPIO Port [X] Pin [N] Value
N     * |        |          |The value read from each of these bit reflects the actual status of the respective GPI/O pin
N     * |        |          |Note: For GPIOF_PIN, bits [15:6] are reserved.
N    */
N    __I  uint32_t PIN;
X    volatile const  uint32_t PIN;
N
N    /**
N     * DBEN
N     * ===================================================================================================
N     * Offset: 0x14  GPIO Port De-bounce Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |DBEN      |GPIO Port [X] Pin [N] Input Signal De-Bounce Enable
N     * |        |          |DBEN[n] used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
N     * |        |          |0 = The GPIO port [x] Pin [n] input signal de-bounce function is disabled.
N     * |        |          |1 = The GPIO port [x] Pin [n] input signal de-bounce function is enabled.
N     * |        |          |The de-bounce function is valid for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N     * |        |          |Note: For GPIOF_DBEN, bits [15:6] are reserved.
N    */
N    __IO uint32_t DBEN;
X    volatile uint32_t DBEN;
N
N    /**
N     * IMD
N     * ===================================================================================================
N     * Offset: 0x18  GPIO Port Interrupt Mode Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |IMD       |GPIO Port [X] Pin [N] Edge Or Level Detection Interrupt Control
N     * |        |          |IMD[n] used to control the interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source is control de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOX_IER.
N     * |        |          |If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N     * |        |          |Note: For GPIOF_IMD, bits [15:6] are reserved.
N    */
N    __IO uint32_t IMD;
X    volatile uint32_t IMD;
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x1C  GPIO Port Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FIER0     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[1]     |FIER1     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[2]     |FIER2     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[3]     |FIER3     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[4]     |FIER4     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[5]     |FIER5     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[6]     |FIER6     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[7]     |FIER7     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[8]     |FIER8     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[9]     |FIER9     |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[10]    |FIER10    |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[11]    |FIER11    |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[12]    |FIER12    |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[13]    |FIER13    |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[14]    |FIER14    |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[15]    |FIER15    |GPIO Port [X] Pin [N] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |FIER[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the FIER[n] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |Note: For GPIOF_IER, bits [15:6] are reserved.
N     * |[16]    |RIER0     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[17]    |RIER1     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[18]    |RIER2     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[19]    |RIER3     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[20]    |RIER4     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[21]    |RIER5     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[22]    |RIER6     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[23]    |RIER7     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[24]    |RIER8     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[25]    |RIER9     |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[26]    |RIER10    |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[27]    |RIER11    |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[28]    |RIER12    |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[29]    |RIER13    |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[30]    |RIER14    |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N     * |[31]    |RIER15    |GPIO Port [X] Pin [N] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |RIER[x] used to enable the interrupt for each of the corresponding input GPIO_PIN[x].
N     * |        |          |Set bit "1" also enable the pin wake-up function.
N     * |        |          |When set the RIER[x] bit "1":
N     * |        |          |If the interrupt is level mode trigger, the input PIN[x] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge mode trigger, the input PIN[x] state change from "low-to-high" will generate the interrupt.
N     * |        |          |1 = PIN[x] level-high or low-to-high interrupt Enabled.
N     * |        |          |0 = PIN[x] level-high or low-to-high interrupt Disabled.
N     * |        |          |Note: For GPIOF_IE, bits [31:22] are reserved.
N    */
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N
N    /**
N     * ISRC
N     * ===================================================================================================
N     * Offset: 0x20  GPIO Port Interrupt Trigger Source Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |ISRC      |GPIO Port [X] Pin [N] Interrupt Trigger Source Indicator
N     * |        |          |Read :
N     * |        |          |1 = Port x[n] generate an interrupt.
N     * |        |          |0 = No interrupt at Port x[n].
N     * |        |          |Write:
N     * |        |          |1 = Clear the correspond pending interrupt.
N     * |        |          |0 = No action.
N     * |        |          |Note: For GPIOF_ISRC, bits [15:6] are reserved.
N    */
N    __IO uint32_t ISRC;
X    volatile uint32_t ISRC;
N
N    /**
N     * PUEN
N     * ===================================================================================================
N     * Offset: 0x24  GPIO Port
N     Pull-Up Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PUEN      |GPIO Port [X] Pin [N] Pull-Up Enable Register
N     * |        |          |Read :
N     * |        |          |1 = GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Enabled.
N     * |        |          |0 = GPIO port [A/B/C/D/E/F] bit [n] pull-up resistor Disabled.
N     * |        |          |Note: For GPIOF_PUEN, bits [15:6] are reserved.
N    */
N    __IO uint32_t PUEN;
X    volatile uint32_t PUEN;
N
N} GPIO_T;
N
N
Ntypedef struct
N{
N    /**
N     * DBNCECON
N     * ===================================================================================================
N     * Offset: 0x180  De-bounce Cycle Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |PUEN      |De-Bounce Sampling Cycle Selection
N     * |        |          |0000 = Sample interrupt input once per 1 clock.
N     * |        |          |0001 = Sample interrupt input once per 2 clock.
N     * |        |          |0010 = Sample interrupt input once per 4 clock.
N     * |        |          |0011 = Sample interrupt input once per 8 clock.
N     * |        |          |0100 = Sample interrupt input once per 16 clock.
N     * |        |          |0101 = Sample interrupt input once per 32 clock.
N     * |        |          |0110 = Sample interrupt input once per 64 clock.
N     * |        |          |0111 = Sample interrupt input once per 128 clock.
N     * |        |          |1000 = Sample interrupt input once per 256 clock.
N     * |        |          |1001 = Sample interrupt input once per 512 clock.
N     * |        |          |1010 = Sample interrupt input once per 1024 clock.
N     * |        |          |1011 = Sample interrupt input once per 2048 clock.
N     * |        |          |1100 = Sample interrupt input once per 4096 clock.
N     * |        |          |1101 = Sample interrupt input once per 8192 clock.
N     * |        |          |1110 = Sample interrupt input once per 16384 clock.
N     * |        |          |1111 = Sample interrupt input once per 32768 clock.
N     * |[4]     |DBCLKSRC  |De-Bounce Counter Clock Source Selection
N     * |        |          |0 = De-bounce counter Clock Source is the HCLK.
N     * |        |          |1 = De-bounce counter Clock Source is the internal 10 kHz clock.
N     * |[5]     |DBCLK_ON  |De-Bounce Clock Enable
N     * |        |          |This bit controls if the de-bounce clock is enabled.
N     * |        |          |However, if GPI/O pin's interrupt is enabled, the de-bounce clock will be enabled automatically no matter what the DBCLK_ON value is.
N     * |        |          |If CPU is in sleep mode, this bit didn't take effect.
N     * |        |          |And only the GPI/O pin with interrupt enable could get de-bounce clock.
N     * |        |          |0 = De-bounce clock Disabled.
N     * |        |          |1 = De-bounce clock Enabled.
N    */
N    __IO uint32_t DBNCECON;
X    volatile uint32_t DBNCECON;
N} GP_DB_T;
N
N/**
N    @addtogroup GPIO_CONST GPIO Bit Field Definition
N    Constant Definitions for GPIO Controller
N@{ */
N
N#define GP_PMD_PMD0_Pos                  (0)                                               /*!< GPIO_T::PMD: PMD0 Position                  */
N#define GP_PMD_PMD0_Msk                  (0x3ul << GP_PMD_PMD0_Pos)                        /*!< GPIO_T::PMD: PMD0 Mask                      */
N
N#define GP_PMD_PMD1_Pos                  (2)                                               /*!< GPIO_T::PMD: PMD1 Position                  */
N#define GP_PMD_PMD1_Msk                  (0x3ul << GP_PMD_PMD1_Pos)                        /*!< GPIO_T::PMD: PMD1 Mask                      */
N
N#define GP_PMD_PMD2_Pos                  (4)                                               /*!< GPIO_T::PMD: PMD2 Position                  */
N#define GP_PMD_PMD2_Msk                  (0x3ul << GP_PMD_PMD2_Pos)                        /*!< GPIO_T::PMD: PMD2 Mask                      */
N
N#define GP_PMD_PMD3_Pos                  (6)                                               /*!< GPIO_T::PMD: PMD3 Position                  */
N#define GP_PMD_PMD3_Msk                  (0x3ul << GP_PMD_PMD3_Pos)                        /*!< GPIO_T::PMD: PMD3 Mask                      */
N
N#define GP_PMD_PMD4_Pos                  (8)                                               /*!< GPIO_T::PMD: PMD4 Position                  */
N#define GP_PMD_PMD4_Msk                  (0x3ul << GP_PMD_PMD4_Pos)                        /*!< GPIO_T::PMD: PMD4 Mask                      */
N
N#define GP_PMD_PMD5_Pos                  (10)                                              /*!< GPIO_T::PMD: PMD5 Position                  */
N#define GP_PMD_PMD5_Msk                  (0x3ul << GP_PMD_PMD5_Pos)                        /*!< GPIO_T::PMD: PMD5 Mask                      */
N
N#define GP_PMD_PMD6_Pos                  (12)                                              /*!< GPIO_T::PMD: PMD6 Position                  */
N#define GP_PMD_PMD6_Msk                  (0x3ul << GP_PMD_PMD6_Pos)                        /*!< GPIO_T::PMD: PMD6 Mask                      */
N
N#define GP_PMD_PMD7_Pos                  (14)                                              /*!< GPIO_T::PMD: PMD7 Position                  */
N#define GP_PMD_PMD7_Msk                  (0x3ul << GP_PMD_PMD7_Pos)                        /*!< GPIO_T::PMD: PMD7 Mask                      */
N
N#define GP_PMD_PMD8_Pos                  (16)                                              /*!< GPIO_T::PMD: PMD8 Position                  */
N#define GP_PMD_PMD8_Msk                  (0x3ul << GP_PMD_PMD8_Pos)                        /*!< GPIO_T::PMD: PMD8 Mask                      */
N
N#define GP_PMD_PMD9_Pos                  (18)                                              /*!< GPIO_T::PMD: PMD9 Position                  */
N#define GP_PMD_PMD9_Msk                  (0x3ul << GP_PMD_PMD9_Pos)                        /*!< GPIO_T::PMD: PMD9 Mask                      */
N
N#define GP_PMD_PMD10_Pos                 (20)                                              /*!< GPIO_T::PMD: PMD10 Position                 */
N#define GP_PMD_PMD10_Msk                 (0x3ul << GP_PMD_PMD10_Pos)                       /*!< GPIO_T::PMD: PMD10 Mask                     */
N
N#define GP_PMD_PMD11_Pos                 (22)                                              /*!< GPIO_T::PMD: PMD11 Position                 */
N#define GP_PMD_PMD11_Msk                 (0x3ul << GP_PMD_PMD11_Pos)                       /*!< GPIO_T::PMD: PMD11 Mask                     */
N
N#define GP_PMD_PMD12_Pos                 (24)                                              /*!< GPIO_T::PMD: PMD12 Position                 */
N#define GP_PMD_PMD12_Msk                 (0x3ul << GP_PMD_PMD12_Pos)                       /*!< GPIO_T::PMD: PMD12 Mask                     */
N
N#define GP_PMD_PMD13_Pos                 (26)                                              /*!< GPIO_T::PMD: PMD13 Position                 */
N#define GP_PMD_PMD13_Msk                 (0x3ul << GP_PMD_PMD13_Pos)                       /*!< GPIO_T::PMD: PMD13 Mask                     */
N
N#define GP_PMD_PMD14_Pos                 (28)                                              /*!< GPIO_T::PMD: PMD14 Position                 */
N#define GP_PMD_PMD14_Msk                 (0x3ul << GP_PMD_PMD14_Pos)                       /*!< GPIO_T::PMD: PMD14 Mask                     */
N
N#define GP_PMD_PMD15_Pos                 (30)                                              /*!< GPIO_T::PMD: PMD15 Position                 */
N#define GP_PMD_PMD15_Msk                 (0x3ul << GP_PMD_PMD15_Pos)                       /*!< GPIO_T::PMD: PMD15 Mask                     */
N
N#define GP_OFFD_OFFD_Pos                 (16)                                              /*!< GPIO_T::OFFD: OFFD Position                 */
N#define GP_OFFD_OFFD_Msk                 (0xfffful << GP_OFFD_OFFD_Pos)                    /*!< GPIO_T::OFFD: OFFD Mask                     */
N
N#define GP_DOUT_DOUT_Pos                 (0)                                               /*!< GPIO_T::DOUT: DOUT Position                 */
N#define GP_DOUT_DOUT_Msk                 (0xfffful << GP_DOUT_DOUT_Pos)                    /*!< GPIO_T::DOUT: DOUT Mask                     */
N
N#define GP_DMASK_DMASK_Pos               (0)                                               /*!< GPIO_T::DMASK: DMASK Position               */
N#define GP_DMASK_DMASK_Msk               (0xfffful << GP_DMASK_DMASK_Pos)                  /*!< GPIO_T::DMASK: DMASK Mask                   */
N
N#define GP_PIN_PIN_Pos                   (0)                                               /*!< GPIO_T::PIN: PIN Position                   */
N#define GP_PIN_PIN_Msk                   (0xfffful << GP_PIN_PIN_Pos)                      /*!< GPIO_T::PIN: PIN Mask                       */
N
N#define GP_DBEN_DBEN_Pos                 (0)                                               /*!< GPIO_T::DBEN: DBEN Position                 */
N#define GP_DBEN_DBEN_Msk                 (0xfffful << GP_DBEN_DBEN_Pos)                    /*!< GPIO_T::DBEN: DBEN Mask                     */
N
N#define GP_IMD_IMD_Pos                   (0)                                               /*!< GPIO_T::IMD: IMD Position                   */
N#define GP_IMD_IMD_Msk                   (0xfffful << GP_IMD_IMD_Pos)                      /*!< GPIO_T::IMD: IMD Mask                       */
N
N#define GP_IER_FIER0_Pos                 (0)                                               /*!< GPIO_T::IER: FIER0 Position                 */
N#define GP_IER_FIER0_Msk                 (0x1ul << GP_IER_FIER0_Pos)                       /*!< GPIO_T::IER: FIER0 Mask                     */
N
N#define GP_IER_FIER1_Pos                 (1)                                               /*!< GPIO_T::IER: FIER1 Position                 */
N#define GP_IER_FIER1_Msk                 (0x1ul << GP_IER_FIER1_Pos)                       /*!< GPIO_T::IER: FIER1 Mask                     */
N
N#define GP_IER_FIER2_Pos                 (2)                                               /*!< GPIO_T::IER: FIER2 Position                 */
N#define GP_IER_FIER2_Msk                 (0x1ul << GP_IER_FIER2_Pos)                       /*!< GPIO_T::IER: FIER2 Mask                     */
N
N#define GP_IER_FIER3_Pos                 (3)                                               /*!< GPIO_T::IER: FIER3 Position                 */
N#define GP_IER_FIER3_Msk                 (0x1ul << GP_IER_FIER3_Pos)                       /*!< GPIO_T::IER: FIER3 Mask                     */
N
N#define GP_IER_FIER4_Pos                 (4)                                               /*!< GPIO_T::IER: FIER4 Position                 */
N#define GP_IER_FIER4_Msk                 (0x1ul << GP_IER_FIER4_Pos)                       /*!< GPIO_T::IER: FIER4 Mask                     */
N
N#define GP_IER_FIER5_Pos                 (5)                                               /*!< GPIO_T::IER: FIER5 Position                 */
N#define GP_IER_FIER5_Msk                 (0x1ul << GP_IER_FIER5_Pos)                       /*!< GPIO_T::IER: FIER5 Mask                     */
N
N#define GP_IER_FIER6_Pos                 (6)                                               /*!< GPIO_T::IER: FIER6 Position                 */
N#define GP_IER_FIER6_Msk                 (0x1ul << GP_IER_FIER6_Pos)                       /*!< GPIO_T::IER: FIER6 Mask                     */
N
N#define GP_IER_FIER7_Pos                 (7)                                               /*!< GPIO_T::IER: FIER7 Position                 */
N#define GP_IER_FIER7_Msk                 (0x1ul << GP_IER_FIER7_Pos)                       /*!< GPIO_T::IER: FIER7 Mask                     */
N
N#define GP_IER_FIER8_Pos                 (8)                                               /*!< GPIO_T::IER: FIER8 Position                 */
N#define GP_IER_FIER8_Msk                 (0x1ul << GP_IER_FIER8_Pos)                       /*!< GPIO_T::IER: FIER8 Mask                     */
N
N#define GP_IER_FIER9_Pos                 (9)                                               /*!< GPIO_T::IER: FIER9 Position                 */
N#define GP_IER_FIER9_Msk                 (0x1ul << GP_IER_FIER9_Pos)                       /*!< GPIO_T::IER: FIER9 Mask                     */
N
N#define GP_IER_FIER10_Pos                (10)                                              /*!< GPIO_T::IER: FIER10 Position                */
N#define GP_IER_FIER10_Msk                (0x1ul << GP_IER_FIER10_Pos)                      /*!< GPIO_T::IER: FIER10 Mask                    */
N
N#define GP_IER_FIER11_Pos                (11)                                              /*!< GPIO_T::IER: FIER11 Position                */
N#define GP_IER_FIER11_Msk                (0x1ul << GP_IER_FIER11_Pos)                      /*!< GPIO_T::IER: FIER11 Mask                    */
N
N#define GP_IER_FIER12_Pos                (12)                                              /*!< GPIO_T::IER: FIER12 Position                */
N#define GP_IER_FIER12_Msk                (0x1ul << GP_IER_FIER12_Pos)                      /*!< GPIO_T::IER: FIER12 Mask                    */
N
N#define GP_IER_FIER13_Pos                (13)                                              /*!< GPIO_T::IER: FIER13 Position                */
N#define GP_IER_FIER13_Msk                (0x1ul << GP_IER_FIER13_Pos)                      /*!< GPIO_T::IER: FIER13 Mask                    */
N
N#define GP_IER_FIER14_Pos                (14)                                              /*!< GPIO_T::IER: FIER14 Position                */
N#define GP_IER_FIER14_Msk                (0x1ul << GP_IER_FIER14_Pos)                      /*!< GPIO_T::IER: FIER14 Mask                    */
N
N#define GP_IER_FIER15_Pos                (15)                                              /*!< GPIO_T::IER: FIER15 Position                */
N#define GP_IER_FIER15_Msk                (0x1ul << GP_IER_FIER15_Pos)                      /*!< GPIO_T::IER: FIER15 Mask                    */
N
N#define GP_IER_RIER0_Pos                 (16)                                              /*!< GPIO_T::IER: RIER0 Position                 */
N#define GP_IER_RIER0_Msk                 (0x1ul << GP_IER_RIER0_Pos)                       /*!< GPIO_T::IER: RIER0 Mask                     */
N
N#define GP_IER_RIER1_Pos                 (17)                                              /*!< GPIO_T::IER: RIER1 Position                 */
N#define GP_IER_RIER1_Msk                 (0x1ul << GP_IER_RIER1_Pos)                       /*!< GPIO_T::IER: RIER1 Mask                     */
N
N#define GP_IER_RIER2_Pos                 (18)                                              /*!< GPIO_T::IER: RIER2 Position                 */
N#define GP_IER_RIER2_Msk                 (0x1ul << GP_IER_RIER2_Pos)                       /*!< GPIO_T::IER: RIER2 Mask                     */
N
N#define GP_IER_RIER3_Pos                 (19)                                              /*!< GPIO_T::IER: RIER3 Position                 */
N#define GP_IER_RIER3_Msk                 (0x1ul << GP_IER_RIER3_Pos)                       /*!< GPIO_T::IER: RIER3 Mask                     */
N
N#define GP_IER_RIER4_Pos                 (20)                                              /*!< GPIO_T::IER: RIER4 Position                 */
N#define GP_IER_RIER4_Msk                 (0x1ul << GP_IER_RIER4_Pos)                       /*!< GPIO_T::IER: RIER4 Mask                     */
N
N#define GP_IER_RIER5_Pos                 (21)                                              /*!< GPIO_T::IER: RIER5 Position                 */
N#define GP_IER_RIER5_Msk                 (0x1ul << GP_IER_RIER5_Pos)                       /*!< GPIO_T::IER: RIER5 Mask                     */
N
N#define GP_IER_RIER6_Pos                 (22)                                              /*!< GPIO_T::IER: RIER6 Position                 */
N#define GP_IER_RIER6_Msk                 (0x1ul << GP_IER_RIER6_Pos)                       /*!< GPIO_T::IER: RIER6 Mask                     */
N
N#define GP_IER_RIER7_Pos                 (23)                                              /*!< GPIO_T::IER: RIER7 Position                 */
N#define GP_IER_RIER7_Msk                 (0x1ul << GP_IER_RIER7_Pos)                       /*!< GPIO_T::IER: RIER7 Mask                     */
N
N#define GP_IER_RIER8_Pos                 (24)                                              /*!< GPIO_T::IER: RIER8 Position                 */
N#define GP_IER_RIER8_Msk                 (0x1ul << GP_IER_RIER8_Pos)                       /*!< GPIO_T::IER: RIER8 Mask                     */
N
N#define GP_IER_RIER9_Pos                 (25)                                              /*!< GPIO_T::IER: RIER9 Position                 */
N#define GP_IER_RIER9_Msk                 (0x1ul << GP_IER_RIER9_Pos)                       /*!< GPIO_T::IER: RIER9 Mask                     */
N
N#define GP_IER_RIER10_Pos                (26)                                              /*!< GPIO_T::IER: RIER10 Position                */
N#define GP_IER_RIER10_Msk                (0x1ul << GP_IER_RIER10_Pos)                      /*!< GPIO_T::IER: RIER10 Mask                    */
N
N#define GP_IER_RIER11_Pos                (27)                                              /*!< GPIO_T::IER: RIER11 Position                */
N#define GP_IER_RIER11_Msk                (0x1ul << GP_IER_RIER11_Pos)                      /*!< GPIO_T::IER: RIER11 Mask                    */
N
N#define GP_IER_RIER12_Pos                (28)                                              /*!< GPIO_T::IER: RIER12 Position                */
N#define GP_IER_RIER12_Msk                (0x1ul << GP_IER_RIER12_Pos)                      /*!< GPIO_T::IER: RIER12 Mask                    */
N
N#define GP_IER_RIER13_Pos                (29)                                              /*!< GPIO_T::IER: RIER13 Position                */
N#define GP_IER_RIER13_Msk                (0x1ul << GP_IER_RIER13_Pos)                      /*!< GPIO_T::IER: RIER13 Mask                    */
N
N#define GP_IER_RIER14_Pos                (30)                                              /*!< GPIO_T::IER: RIER14 Position                */
N#define GP_IER_RIER14_Msk                (0x1ul << GP_IER_RIER14_Pos)                      /*!< GPIO_T::IER: RIER14 Mask                    */
N
N#define GP_IER_RIER15_Pos                (31)                                              /*!< GPIO_T::IER: RIER15 Position                */
N#define GP_IER_RIER15_Msk                (0x1ul << GP_IER_RIER15_Pos)                      /*!< GPIO_T::IER: RIER15 Mask                    */
N
N#define GP_ISRC_ISRC_Pos                 (0)                                               /*!< GPIO_T::ISRC: ISRC Position                 */
N#define GP_ISRC_ISRC_Msk                 (0xfffful << GP_ISRC_ISRC_Pos)                    /*!< GPIO_T::ISRC: ISRC Mask                     */
N
N#define GP_PUEN_PUEN_Pos                 (0)                                               /*!< GPIO_T::PUEN: PUEN Position                 */
N#define GP_PUEN_PUEN_Msk                 (0xfffful << GP_PUEN_PUEN_Pos)                    /*!< GPIO_T::PUEN: PUEN Mask                     */
N/**@}*/ /* GPIO_CONST */
N
N/**
N    @addtogroup GP_DB_CONST GP_DB Bit Field Definition
N    Constant Definitions for GP_DB Controller
N@{ */
N#define GP_DBNCECON_DBCLKSEL_Pos         (0)                                               /*!< GP_DB_T::DBNCECON: DBCLKSEL Position             */
N#define GP_DBNCECON_DBCLKSEL_Msk         (0xful << GP_DBNCECON_DBCLKSEL_Pos)               /*!< GP_DB_T::DBNCECON: DBCLKSEL Mask                 */
N
N#define GP_DBNCECON_DBCLKSRC_Pos         (4)                                               /*!< GP_DB_T::DBNCECON: DBCLKSRC Position         */
N#define GP_DBNCECON_DBCLKSRC_Msk         (0x1ul << GP_DBNCECON_DBCLKSRC_Pos)               /*!< GP_DB_T::DBNCECON: DBCLKSRC Mask             */
N
N#define GP_DBNCECON_DBCLK_ON_Pos         (5)                                               /*!< GP_DB_T::DBNCECON: DBCLK_ON Position         */
N#define GP_DBNCECON_DBCLK_ON_Msk         (0x1ul << GP_DBNCECON_DBCLK_ON_Pos)               /*!< GP_DB_T::DBNCECON: DBCLK_ON Mask             */
N
N
N/**@}*/ /* GP_DB_CONST */
N/**@}*/ /* end of GP register group */
N
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * CON
N     * ===================================================================================================
N     * Offset: 0x00  I2C Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |IPEN      |I2C Function Enable
N     * |        |          |When this bit is set to 1, the I2C serial function is enabled.
N     * |        |          |0 = I2C function Disabled.
N     * |        |          |1 = I2C function Enabled.
N     * |[1]     |ACK       |Assert Acknowledge Control Bit
N     * |        |          |0 =: When this bit is set to 0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse.
N     * |        |          |1 = When this bit is set to 1 prior to address or data received, an acknowledged will be returned during the acknowledge clock pulse on the SCL line when.
N     * |        |          |a. A slave is acknowledging the address sent from master
N     * |        |          |b. The receiver devices are acknowledging the data sent by transmitter.
N     * |[2]     |STOP      |I2C STOP Control Bit
N     * |        |          |In Master mode, set this bit to 1 to transmit a STOP condition to bus then the controller will check the bus condition if a STOP condition is detected and this bit will be cleared by hardware automatically.
N     * |        |          |In Slave mode, set this bit to 1 to reset the controller to the defined "not addressed" Slave mode.
N     * |        |          |This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
N     * |        |          |0 = Will be cleared by hardware automatically if a STOP condition is detected.
N     * |        |          |1 = Sends a STOP condition to bus in Master mode or reset the controller to "not addressed" in Slave mode.
N     * |[3]     |START     |I2C START Command
N     * |        |          |Setting this bit to 1 to enter Master mode, the device sends a START or repeat START condition to bus when the bus is free and it will be cleared to 0 after the START command is active and the STATUS has been updated.
N     * |        |          |0 = After START or repeat START is active.
N     * |        |          |1 = Sends a START or repeat START condition to bus.
N     * |[4]     |I2C_STS   |I2C Status
N     * |        |          |When a new state is present in the I2CSTATUS register, this bit will be set automatically, and if the INTEN bit is set, the I2C interrupt is requested.
N     * |        |          |It must be cleared by software by writing one to this bit and the I2C protocol function will go ahead until the STOP is active or the IPEN is disabled.
N     * |        |          |0 = I2C's Status disabled and the I2C protocol function will go ahead.
N     * |        |          |1 = I2C's Status active.
N     * |[7]     |INTEN     |Interrupt Enable
N     * |        |          |0 = I2C interrupt Disabled.
N     * |        |          |1 = I2C interrupt Enabled.
N    */
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x04  I2C Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INTSTS    |I2C STATUS's Interrupt Status
N     * |        |          |When a new state is present in the I2CSTATUS register, this bit will be set automatically, and if INTEN bit is set, the I2C interrupt is requested.
N     * |        |          |Software can write 1 to cleat this bit.
N     * |[1]     |TIF       |Time-Out Status
N     * |        |          |0 = No Time-out flag. Software can cleat this flag.
N     * |        |          |1 = Time-Out flag active and it is set by hardware. It can interrupt CPU when INTEN bit is set.
N    */
N    __IO uint32_t INTSTS;
X    volatile uint32_t INTSTS;
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x08  I2C Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |STATUS    |I2C Status Register
N     * |        |          |This is a read only register.
N     * |        |          |The three least significant bits are always 0.
N     * |        |          |The five most significant bits contain the status code.
N     * |        |          |When each of these states is entered, a status interrupt and I2C_STS are requested (I2C_STS = 1 and STAINTSTS = 1).
N     * |        |          |A valid status code is present in STATUS one machine cycle after I2C_STS is set by hardware and is still present one machine cycle after I2C_STS has been reset by software.
N     * |        |          |In addition, states 00H stands for a 'Bus Error'.
N     * |        |          |A 'Bus Error' occurs when a START or STOP condition is present at an illegal position in the formation frame.
N     * |        |          |Example of illegal position: a data byte or an acknowledge bit is present during the serial transfer of an address byte.
N     * |        |          |To recover I2C from bus error, STOP should be set and I2C_STS should be cleared to enter not addressed Slave mode.
N     * |        |          |Then clear STOP to release the bus and to wait new communication.
N     * |        |          |I2C bus can not recognize stop condition during this action when bus error occurs.
N    */
N    __I  uint32_t STATUS;
X    volatile const  uint32_t STATUS;
N
N    /**
N     * DIV
N     * ===================================================================================================
N     * Offset: 0x0C  I2C clock divided Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CLK_DIV   |I2C Clock Divider Control Register
N     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = PCLK /( 4 x ( CLK_DIV + 1)).
N     * |        |          |Note: the minimum value of CLK_DIV is 4.
N    */
N    __IO uint32_t DIV;
X    volatile uint32_t DIV;
N
N    /**
N     * TOUT
N     * ===================================================================================================
N     * Offset: 0x10  I2C Time-out control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TOUTEN    |Time-Out Counter Enable/Disable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |When set this bit to enable, the 14 bits time-out counter will start counting when STAINTSTS is cleared.
N     * |        |          |Setting flag STAINTSTS to high or the falling edge of I2C clock or stop signal will reset counter and re-start up counting after STAINTSTS is cleared.
N     * |[1]     |DIV4      |Time-Out Counter Input Clock Divider By 4
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |When this bit is set enabled, the Time-Out period is prolonging 4 times.
N    */
N    __IO uint32_t TOUT;
X    volatile uint32_t TOUT;
N
N    /**
N     * DATA
N     * ===================================================================================================
N     * Offset: 0x14  I2C DATA Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DATA      |I2C Data Register
N     * |        |          |The DATA contains a byte of serial data to be transmitted or a byte which has just been received.
N     * |        |          |The user can read from or write to this 8-bit I2CDATA register directly while it is not in the process of shifting a byte.
N     * |        |          |This occurs when the serial interrupt flag is set.
N     * |        |          |Data in DATA remains stable as long as I2C_STS bit is set.
N     * |        |          |While data is being shifted out, data on the bus is simultaneously being shifted in; The DATA always contains the last data byte present on the bus.
N     * |        |          |Thus, in the event of arbitration lost, the transition from master transmitter to slave receiver is made with the correct data in DATA.
N     * |        |          |DATA and the acknowledge bit form a 9-bit shift register, the acknowledge bit is controlled by the device hardware and cannot be accessed by the user.
N     * |        |          |Serial data is shifted through the acknowledge bit into DATA on the rising edges of serial clock pulses on the SCL line.
N     * |        |          |When a byte has been shifted into DATA, the serial data is available in DATA, and the acknowledge bit (ACK or NACK) is returned by the control logic during the ninth clock pulse.
N    */
N    __IO uint32_t DATA;
X    volatile uint32_t DATA;
N
N    /**
N     * SADDR0
N     * ===================================================================================================
N     * Offset: 0x18  I2C Slave address Register0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GCALL     |General Call Function
N     * |        |          |The I2C controller supports the "General Call" function.
N     * |        |          |If the GCALL bit is set, the controller will respond to General Call address (00H).
N     * |        |          |When GCALL bit is set, the controller is in Slave mode, it can receive the general call address by 00H after Master send general call address to the I2C bus, then it will follow status of GCALL mode.
N     * |        |          |If it is in Master mode, the ACK bit must be cleared when it will send general call address of 00H to I2C bus.
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |SADDR     |I2C Salve Address Register
N     * |        |          |The content of this register is irrelevant when the device is in Master mode.
N     * |        |          |In the Slave mode, the seven most significant bits must be loaded with the device's own address.
N     * |        |          |The device will react if either of the address is matched.
N    */
N    __IO uint32_t SADDR0;
X    volatile uint32_t SADDR0;
N
N    /**
N     * SADDR1
N     * ===================================================================================================
N     * Offset: 0x1C  I2C Slave address Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GCALL     |General Call Function
N     * |        |          |The I2C controller supports the "General Call" function.
N     * |        |          |If the GCALL bit is set, the controller will respond to General Call address (00H).
N     * |        |          |When GCALL bit is set, the controller is in Slave mode, it can receive the general call address by 00H after Master send general call address to the I2C bus, then it will follow status of GCALL mode.
N     * |        |          |If it is in Master mode, the ACK bit must be cleared when it will send general call address of 00H to I2C bus.
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |SADDR     |I2C Salve Address Register
N     * |        |          |The content of this register is irrelevant when the device is in Master mode.
N     * |        |          |In the Slave mode, the seven most significant bits must be loaded with the device's own address.
N     * |        |          |The device will react if either of the address is matched.
N    */
N    __IO uint32_t SADDR1;
X    volatile uint32_t SADDR1;
N    uint32_t RESERVE0[2];
N
N
N    /**
N     * SAMASK0
N     * ===================================================================================================
N     * Offset: 0x28  I2C Slave address Mask Register0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |SAMASK    |I2C Slave Address Mask Register
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with two address mask registers.
N     * |        |          |When the bit in the address mask register is set to b'1, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to b'0, that means the received corresponding register bit should be exact the same as address register.
N    */
N    __IO uint32_t SAMASK0;
X    volatile uint32_t SAMASK0;
N
N    /**
N     * SAMASK1
N     * ===================================================================================================
N     * Offset: 0x2C  I2C Slave address Mask Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |SAMASK    |I2C Slave Address Mask Register
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with two address mask registers.
N     * |        |          |When the bit in the address mask register is set to b'1, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to b'0, that means the received corresponding register bit should be exact the same as address register.
N    */
N    __IO uint32_t SAMASK1;
X    volatile uint32_t SAMASK1;
N    uint32_t RESERVE1[4];
N
N
N    /**
N     * WKUPCON
N     * ===================================================================================================
N     * Offset: 0x40  I2C Wake-up Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKUPEN    |I2C Wake-Up Function Enable
N     * |        |          |0 = I2C wake-up function Disabled.
N     * |        |          |1 = I2C wake-up function Enabled.
N    */
N    __IO uint32_t WKUPCON;
X    volatile uint32_t WKUPCON;
N
N    /**
N     * WKUPSTS
N     * ===================================================================================================
N     * Offset: 0x44  I2C Wake-up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKUPIF    |Wake-Up Interrupt Flag
N     * |        |          |0 = Wake-up flag inactive.
N     * |        |          |1 = Wake-up flag active.
N     * |        |          |Software can write 1 to clear this flag
N    */
N    __IO  uint32_t WKUPSTS;
X    volatile  uint32_t WKUPSTS;
N
N} I2C_T;
N
N/**
N    @addtogroup I2C_CONST I2C Bit Field Definition
N    Constant Definitions for I2C Controller
N@{ */
N
N#define I2C_CON_IPEN_Pos              (0)                                               /*!< I2C_T::CON: IPEN Position              */
N#define I2C_CON_IPEN_Msk              (0x1ul << I2C_CON_IPEN_Pos)                       /*!< I2C_T::CON: IPEN Mask                  */
N
N#define I2C_CON_ACK_Pos               (1)                                               /*!< I2C_T::CON: ACK Position               */
N#define I2C_CON_ACK_Msk               (0x1ul << I2C_CON_ACK_Pos)                        /*!< I2C_T::CON: ACK Mask                   */
N
N#define I2C_CON_STOP_Pos              (2)                                               /*!< I2C_T::CON: STOP Position              */
N#define I2C_CON_STOP_Msk              (0x1ul << I2C_CON_STOP_Pos)                       /*!< I2C_T::CON: STOP Mask                  */
N
N#define I2C_CON_START_Pos             (3)                                               /*!< I2C_T::CON: START Position             */
N#define I2C_CON_START_Msk             (0x1ul << I2C_CON_START_Pos)                      /*!< I2C_T::CON: START Mask                 */
N
N#define I2C_CON_I2C_STS_Pos           (4)                                               /*!< I2C_T::CON: I2C_STS Position           */
N#define I2C_CON_I2C_STS_Msk           (0x1ul << I2C_CON_I2C_STS_Pos)                    /*!< I2C_T::CON: I2C_STS Mask               */
N
N#define I2C_CON_INTEN_Pos             (7)                                               /*!< I2C_T::CON: INTEN Position             */
N#define I2C_CON_INTEN_Msk             (0x1ul << I2C_CON_INTEN_Pos)                      /*!< I2C_T::CON: INTEN Mask                 */
N
N#define I2C_INTSTS_INTSTS_Pos         (0)                                               /*!< I2C_T::INTSTS: INTSTS Position         */
N#define I2C_INTSTS_INTSTS_Msk         (0x1ul << I2C_INTSTS_INTSTS_Pos)                  /*!< I2C_T::INTSTS: INTSTS Mask             */
N
N#define I2C_INTSTS_TIF_Pos            (1)                                               /*!< I2C_T::INTSTS: TIF Position            */
N#define I2C_INTSTS_TIF_Msk            (0x1ul << I2C_INTSTS_TIF_Pos)                     /*!< I2C_T::INTSTS: TIF Mask                */
N
N#define I2C_STATUS_STATUS_Pos         (0)                                               /*!< I2C_T::STATUS: STATUS Position         */
N#define I2C_STATUS_STATUS_Msk         (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C_T::STATUS: STATUS Mask             */
N
N#define I2C_DIV_CLK_DIV_Pos           (0)                                               /*!< I2C_T::DIV: CLK_DIV Position           */
N#define I2C_DIV_CLK_DIV_Msk           (0xfful << I2C_DIV_CLK_DIV_Pos)                   /*!< I2C_T::DIV: CLK_DIV Mask               */
N
N#define I2C_TOUT_TOUTEN_Pos           (0)                                               /*!< I2C_T::TOUT: TOUTEN Position           */
N#define I2C_TOUT_TOUTEN_Msk           (0x1ul << I2C_TOUT_TOUTEN_Pos)                    /*!< I2C_T::TOUT: TOUTEN Mask               */
N
N#define I2C_TOUT_DIV4_Pos             (1)                                               /*!< I2C_T::TOUT: DIV4 Position             */
N#define I2C_TOUT_DIV4_Msk             (0x1ul << I2C_TOUT_DIV4_Pos)                      /*!< I2C_T::TOUT: DIV4 Mask                 */
N
N#define I2C_DATA_DATA_Pos             (0)                                               /*!< I2C_T::DATA: DATA Position             */
N#define I2C_DATA_DATA_Msk             (0xfful << I2C_DATA_DATA_Pos)                     /*!< I2C_T::DATA: DATA Mask                 */
N
N#define I2C_SADDR0_GCALL_Pos          (0)                                               /*!< I2C_T::SADDR0: GCALL Position          */
N#define I2C_SADDR0_GCALL_Msk          (0x1ul << I2C_SADDR0_GCALL_Pos)                   /*!< I2C_T::SADDR0: GCALL Mask              */
N
N#define I2C_SADDR0_SADDR_Pos          (1)                                               /*!< I2C_T::SADDR0: SADDR Position          */
N#define I2C_SADDR0_SADDR_Msk          (0x7ful << I2C_SADDR0_SADDR_Pos)                  /*!< I2C_T::SADDR0: SADDR Mask              */
N
N#define I2C_SADDR1_GCALL_Pos          (0)                                               /*!< I2C_T::SADDR1: GCALL Position          */
N#define I2C_SADDR1_GCALL_Msk          (0x1ul << I2C_SADDR1_GCALL_Pos)                   /*!< I2C_T::SADDR1: GCALL Mask              */
N
N#define I2C_SADDR1_SADDR_Pos          (1)                                               /*!< I2C_T::SADDR1: SADDR Position          */
N#define I2C_SADDR1_SADDR_Msk          (0x7ful << I2C_SADDR1_SADDR_Pos)                  /*!< I2C_T::SADDR1: SADDR Mask              */
N
N#define I2C_SAMASK0_SAMASK_Pos        (1)                                               /*!< I2C_T::SAMASK0: SAMASK Position        */
N#define I2C_SAMASK0_SAMASK_Msk        (0x7ful << I2C_SAMASK0_SAMASK_Pos)                /*!< I2C_T::SAMASK0: SAMASK Mask            */
N
N#define I2C_SAMASK1_SAMASK_Pos        (1)                                               /*!< I2C_T::SAMASK1: SAMASK Position        */
N#define I2C_SAMASK1_SAMASK_Msk        (0x7ful << I2C_SAMASK1_SAMASK_Pos)                /*!< I2C_T::SAMASK1: SAMASK Mask            */
N
N#define I2C_WKUPCON_WKUPEN_Pos        (0)                                               /*!< I2C_T::WKUPCON: WKUPEN Position        */
N#define I2C_WKUPCON_WKUPEN_Msk        (0x1ul << I2C_WKUPCON_WKUPEN_Pos)                 /*!< I2C_T::WKUPCON: WKUPEN Mask            */
N
N#define I2C_WKUPSTS_WKUPIF_Pos        (0)                                               /*!< I2C_T::WKUPSTS: WKUPIF Position        */
N#define I2C_WKUPSTS_WKUPIF_Msk        (0x1ul << I2C_WKUPSTS_WKUPIF_Pos)                 /*!< I2C_T::WKUPSTS: WKUPIF Mask            */
N
N/**@}*/ /* I2C_CONST */
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- I2S Interface Controller -------------------------*/
N/**
N    @addtogroup I2S I2S Interface Controller(I2S)
N    Memory Mapped Structure for I2S Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * CTRL
N     * ===================================================================================================
N     * Offset: 0x00  I2S Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |I2SEN     |I2S Controller Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[1]     |TXEN      |Transmit Enable
N     * |        |          |0 = Data transmitting Disabled.
N     * |        |          |1 = Data transmitting Enabled.
N     * |[2]     |RXEN      |Receive Enable
N     * |        |          |0 = Data receiving Disabled.
N     * |        |          |1 = Data receiving Enabled.
N     * |[3]     |MUTE      |Transmitting Mute Enable
N     * |        |          |0 = Transmit data in buffer to channel.
N     * |        |          |1 = Transmit '0' to channel.
N     * |[5:4]   |WORDWIDTH |Word Width
N     * |        |          |00 = Data is 8 bit.
N     * |        |          |01 = Data is 16 bit.
N     * |        |          |10 = Data is 24 bit.
N     * |        |          |11 = Data is 32 bit.
N     * |[6]     |MONO      |Monaural Data
N     * |        |          |0 = Data is stereo format.
N     * |        |          |1 = Data is monaural format and gets the right channel data from I2S bus when this mode is enabled.
N     * |[7]     |FORMAT    |Data Format
N     * |        |          |0 = I2S data format.
N     * |        |          |1 = MSB justified data format.
N     * |[8]     |SLAVE     |Slave Mode
N     * |        |          |I2S can operate as master or Slave mode.
N     * |        |          |For Master mode, I2S_BCLK and I2S_LRCLK pins are output mode and also outputs I2S_BCLK and I2S_LRCLK signals to the audio CODEC.
N     * |        |          |When act as Slave mode, I2S_BCLK and I2S_LRCLK pins are input mode and I2S_BCLK and I2S_LRCLK signals are received from the outer audio CODEC chip.
N     * |        |          |0 = Master mode.
N     * |        |          |1 = Slave mode.
N     * |[11:9]  |TXTH      |Transmit FIFO Threshold Level
N     * |        |          |If remain data word (32 bits) in transmitting FIFO is the same or less than threshold level then TXTHF flag is set.
N     * |        |          |000 = 1 word data in transmitting FIFO.
N     * |        |          |001 = 2 word data in transmitting FIFO.
N     * |        |          |010 = 3 word data in transmitting FIFO.
N     * |        |          |011 = 4 word data in transmitting FIFO.
N     * |        |          |100 = 5 word data in transmitting FIFO.
N     * |        |          |101 = 6 word data in transmitting FIFO.
N     * |        |          |110 = 7 word data in transmitting FIFO.
N     * |        |          |111 = 8 word data in transmitting FIFO.
N     * |[14:12] |RXTH      |Receiving FIFO Threshold Level
N     * |        |          |When received data word(s) in buffer is equal to or higher than threshold level, the RXTHF flag is set.
N     * |        |          |000 = 1 word data in receiving FIFO.
N     * |        |          |001 = 2 word data in receiving FIFO.
N     * |        |          |010 = 3 word data in receiving FIFO.
N     * |        |          |011 = 4 word data in receiving FIFO.
N     * |        |          |100 = 5 word data in receiving FIFO.
N     * |        |          |101 = 6 word data in receiving FIFO.
N     * |        |          |110 = 7 word data in receiving FIFO.
N     * |        |          |111 = 8 word data in receiving FIFO.
N     * |[15]    |MCLKEN    |Master Clock Enable
N     * |        |          |Enable master MCLK timing output to the external audio codec device.
N     * |        |          |The output frequency is according to MCLK_DIV[2:0] in the I2S_CLKDIV register.
N     * |        |          |0 = Master Clock Disabled.
N     * |        |          |1 = Master Clock Enabled.
N     * |[16]    |RCHZCEN   |Right Channel Zero Cross Detect Enable
N     * |        |          |If this bit is set to "1", when right channel data sign bit is changed or next shift data bits are all zero then RZCF flag in I2S_STATUS register is set to "1".
N     * |        |          |It works on transmitting mode only.
N     * |        |          |0 = Right channel zero cross detection Disabled.
N     * |        |          |1 = Right channel zero cross detection Enabled.
N     * |[17]    |LCHZCEN   |Left Channel Zero Cross Detect Enable
N     * |        |          |If this bit is set to "1", when left channel data sign bit is changed or next shift data bits are all zero then LZCF flag in I2S_STATUS register is set to "1".
N     * |        |          |It works on transmitting mode only.
N     * |        |          |0 = Left channel zero cross detection Disabled.
N     * |        |          |1 = Left channel zero cross detection Enabled.
N     * |[18]    |CLR_TXFIFO|Clear Transmit FIFO
N     * |        |          |Write "1" to clear transmitting FIFO, internal pointer is reset to FIFO start point, TX_LEVEL[3:0] returns to zero and transmitting FIFO becomes empty but data in transmit FIFO is not changed.
N     * |        |          |This bit is cleared by hardware automatically, read it to return zero.
N     * |[19]    |CLR_RXFIFO|Clear Receiving FIFO
N     * |        |          |Write "1" to clear receiving FIFO, internal pointer is reset to FIFO start point, and RX_LEVEL[3:0] returns to zero and receiving FIFO becomes empty.
N     * |        |          |This bit is cleared by hardware automatically, and read it return zero.
N     * |[20]    |TXDMA     |Enable Transmit DMA
N     * |        |          |When TX DMA is enabled, I2S requests PDMA to transfer data from memory to transmitting FIFO if FIFO is not full
N     * |        |          |0 = TX DMA Disabled.
N     * |        |          |1 = TX DMA Enabled.
N     * |[21]    |RXDMA     |Enable Receive DMA
N     * |        |          |When RX DMA is enabled, I2S requests PDMA to transfer data from receiving FIFO to memory if FIFO is not empty.
N     * |        |          |0 = RX DMA Disabled.
N     * |        |          |1 = RX DMA Enabled.
N     * |[23]    |RXLCH     |Receive Left Channel Enable
N     * |        |          |When monaural format is selected (MONO = 1), I2S will receive right channel data if RXLCH is set to 0, and receive left channel data if RXLCH is set to 1.
N     * |        |          |0 = Receives right channel data when monaural format is selected.
N     * |        |          |1 = Receives left channel data when monaural format is selected.
N    */
N    __IO uint32_t CTRL;
X    volatile uint32_t CTRL;
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x04  I2S Clock Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |MCLK_DIV  |Master Clock Divider
N     * |        |          |If the external crystal frequency is (2xMCLK_DIV)*256fs then software can program these bits to generate 256fs clock frequency to audio CODEC chip.
N     * |        |          |If MCLK_DIV is set to "0", MCLK is the same as external clock input.
N     * |        |          |For example, sampling rate is 48 kHz and the external crystal clock is 12.288 MHz, set MCLK_DIV=0.
N     * |        |          |MCLK = I2SCLK/(2x(MCLK_DIV)).
N     * |[15:8]  |BCLK_DIV  |Bit Clock Divider
N     * |        |          |If I2S is operated in Master mode, bit clock is provided by this chip.
N     * |        |          |Software can program these bits to generate sampling rate clock frequency.
N     * |        |          |BCLK = I2SCLK /(2x(BCLK_DIV + 1)).
N    */
N    __IO uint32_t CLKDIV;
X    volatile uint32_t CLKDIV;
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x08  I2S Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXUDFIE   |Receiving FIFO Underflow Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to "1" and receiving FIFO underflow flag is set to "1".
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N     * |[1]     |RXOVFIE   |Receiving FIFO Overflow Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to "1" and receiving FIFO overflow flag is set to "1"
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N     * |[2]     |RXTHIE    |Receiving FIFO Threshold Level Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to "1" and data words in receiving FIFO is less than RXTH[2:0].
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N     * |[8]     |TXUDFIE   |Transmitting FIFO Underflow Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to "1" and transmitting FIFO underflow flag is set to "1".
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N     * |[9]     |TXOVFIE   |Transmitting FIFO Overflow Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to "1" and transmitting FIFO overflow flag is set to "1"
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N     * |[10]    |TXTHIE    |Transmitting FIFO Threshold Level Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to "1" and data words in transmitting FIFO is less than TXTH[2:0].
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N     * |[11]    |RZCIE     |Right Channel Zero Cross Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to "1" and right channel is zero crossing.
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N     * |[12]    |LZCIE     |Left Channel Zero Cross Interrupt Enable
N     * |        |          |Interrupt occurs if this bit is set to "1" and left channel is zero crossing.
N     * |        |          |0 = Interrupt Disabled.
N     * |        |          |1 = Interrupt Enabled.
N    */
N    __IO uint32_t INTEN;
X    volatile uint32_t INTEN;
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x0C  I2S Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |I2SINT    |I2S Interrupt Flag
N     * |        |          |0 = No I2S interrupt.
N     * |        |          |1 = I2S interrupt occurred.
N     * |        |          |It is wire-OR of I2STXINT and I2SRXINT bits.
N     * |        |          |This bit is read only.
N     * |[1]     |I2SRXINT  |I2S Receiving Interrupt
N     * |        |          |0 = No receiving interrupt occurred.
N     * |        |          |1 = Receiving interrupt occurred.
N     * |        |          |This bit is read only
N     * |[2]     |I2STXINT  |I2S Transmit Interrupt
N     * |        |          |0 = No transmit interrupt occurred.
N     * |        |          |1 = Transmit interrupt occurred.
N     * |        |          |This bit is read only
N     * |[3]     |RIGHT     |Right Channel
N     * |        |          |This bit indicates the current transmitting data is belong to right channel
N     * |        |          |0 = Left channel.
N     * |        |          |1 = Right channel.
N     * |        |          |This bit is read only
N     * |[8]     |RXUDF     |Receiving FIFO Underflow Flag
N     * |        |          |Read the receiving FIFO when it is empty, this bit set to "1" indicate underflow occur.
N     * |        |          |0 = No underflow occurred.
N     * |        |          |1 = Underflow occurred.
N     * |        |          |This bit is cleared by writing 1.
N     * |[9]     |RXOVF     |Receiving FIFO Overflow Flag
N     * |        |          |When the receiving FIFO is full and receiving hardware attempts to write data into receiving FIFO then this bit is set to "1".
N     * |        |          |Data in 1st buffer is overwritten.
N     * |        |          |0 = No overflow occurred.
N     * |        |          |1 = Overflow occurred.
N     * |        |          |This bit is cleared by writing 1.
N     * |[10]    |RXTHF     |Receiving FIFO Threshold Flag
N     * |        |          |When data word(s) in the receiving FIFO is equal to or higher than threshold value set in RXTH[2:0], the RXTHF bit becomes to "1".
N     * |        |          |It keeps at "1" till RX_LEVEL[3:0] less than RXTH[1:0] after software reads data from the RXFIFO register.
N     * |        |          |0 = Data word(s) in receiving FIFO is lower than threshold level.
N     * |        |          |1 = Data word(s) in receiving FIFO is equal to or higher than threshold level.
N     * |        |          |This bit is read only
N     * |[11]    |RXFULL    |Receiving FIFO Full
N     * |        |          |This bit reflect data word number in the receiving FIFO is 8
N     * |        |          |0 = Not full.
N     * |        |          |1 = Full.
N     * |        |          |This bit is read only
N     * |[12]    |RXEMPTY   |Receiving FIFO Empty
N     * |        |          |This bit reflect data word number in the receiving FIFO is zero
N     * |        |          |0 = Empty.
N     * |        |          |1 = Not empty.
N     * |        |          |This bit is read only.
N     * |[16]    |TXUDF     |Transmitting FIFO Underflow Flag
N     * |        |          |When the transmitting FIFO is empty and shift logic hardware read data from the data FIFO causes this set to "1".
N     * |        |          |0 = No underflow.
N     * |        |          |1 = Underflow.
N     * |        |          |This bit is cleared by writing 1.
N     * |[17]    |TXOVF     |Transmit FIFO Overflow Flag
N     * |        |          |Write data to the transmitting FIFO when it is full and this bit will set to "1"
N     * |        |          |0 = No overflow.
N     * |        |          |1 = Overflow.
N     * |        |          |This bit is cleared by writing 1.
N     * |[18]    |TXTHF     |Transmitting FIFO Threshold Flag
N     * |        |          |When data word(s) in the transmitting FIFO is equal to or lower than threshold value set in TXTH[2:0],the TXTHF bit becomes to "1".
N     * |        |          |It keeps at 1 till TX_LEVEL[3:0] is higher than TXTH[1:0] after software writes data into the TXFIFO register.
N     * |        |          |0 = Data word(s) in transmitting FIFO is higher than threshold level.
N     * |        |          |1 = Data word(s) in transmitting FIFO is equal to or lower than threshold level.
N     * |        |          |This bit is read only
N     * |[19]    |TXFULL    |Transmitting FIFO Full
N     * |        |          |This bit reflect data word number in the transmitting FIFO is 8
N     * |        |          |0 = Full.
N     * |        |          |1 = Not full.
N     * |        |          |This bit is read only
N     * |[20]    |TXEMPTY   |Transmitting FIFO Empty
N     * |        |          |This bit reflect data word number in the transmitting FIFO is zero
N     * |        |          |0 = Empty.
N     * |        |          |1 = Not empty.
N     * |        |          |This bit is read only.
N     * |[21]    |TXBUSY    |Transmitting Busy
N     * |        |          |This bit is cleared to 0 when all data in the transmitting FIFO and shift buffer is shifted out.
N     * |        |          |Set this bit to 1 when 1st data is loading to shift buffer.
N     * |        |          |0 = Transmit shift buffer is empty.
N     * |        |          |1 = Transmit shift buffer is busy.
N     * |        |          |This bit is read only.
N     * |[22]    |RZCF      |Right Channel Zero Cross Flag
N     * |        |          |It indicates the data sign of right channel next sample data is changed or all data bits are zero.
N     * |        |          |0 = No zero cross.
N     * |        |          |1 = Right channel zero cross is detected.
N     * |        |          |This bit is cleared by writing 1.
N     * |[23]    |LZCF      |Left Channel Zero Cross Flag
N     * |        |          |It indicates the next sample data sign bit of left channel is changed or all data bits are zero.
N     * |        |          |0 = No zero cross.
N     * |        |          |1 = Left channel zero cross is detected.
N     * |        |          |This bit is cleared by writing 1.
N     * |[27:24] |RX_LEVEL  |Receive FIFO Level
N     * |        |          |These bits indicate the number of word(s) in the receiving FIFO
N     * |[31:28] |TX_LEVEL  |Transmitting FIFO Level
N     * |        |          |These bits indicate the number of word(s) in the transmitting FIFO
N    */
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N
N    /**
N     * TXFIFO
N     * ===================================================================================================
N     * Offset: 0x10  I2S Transmit FIFO Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |TXFIFO    |Transmitting FIFO Register
N     * |        |          |I2S contains 8 words (8x32-bit) data buffer for data transmitting.
N     * |        |          |Write data to this register in order to prepare data for transmitting.
N     * |        |          |The remaining word number is indicated by TX_LEVEL[3:0] in the I2S_STATUS register.
N     * |        |          |This register is write only.
N    */
N    __O  uint32_t TXFIFO;
X    volatile  uint32_t TXFIFO;
N
N    /**
N     * RXFIFO
N     * ===================================================================================================
N     * Offset: 0x14  I2S Receive FIFO Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RXFIFO    |Receiving FIFO Register
N     * |        |          |I2S contains 8 words (8x32-bit) data buffer for data receiving.
N     * |        |          |Read this register to get data in FIFO.
N     * |        |          |The remaining data word number is indicated by RX_LEVEL[3:0] in the I2S_STATUS register.
N     * |        |          |This register is read only.
N    */
N    __I  uint32_t RXFIFO;
X    volatile const  uint32_t RXFIFO;
N
N} I2S_T;
N
N/**
N    @addtogroup I2S_CONST I2S Bit Field Definition
N    Constant Definitions for I2S Controller
N@{ */
N
N#define I2S_CTRL_I2SEN_Pos               (0)                                               /*!< I2S_T::CTRL: I2SEN Position               */
N#define I2S_CTRL_I2SEN_Msk               (0x1ul << I2S_CTRL_I2SEN_Pos)                     /*!< I2S_T::CTRL: I2SEN Mask                   */
N
N#define I2S_CTRL_TXEN_Pos                (1)                                               /*!< I2S_T::CTRL: TXEN Position                */
N#define I2S_CTRL_TXEN_Msk                (0x1ul << I2S_CTRL_TXEN_Pos)                      /*!< I2S_T::CTRL: TXEN Mask                    */
N
N#define I2S_CTRL_RXEN_Pos                (2)                                               /*!< I2S_T::CTRL: RXEN Position                */
N#define I2S_CTRL_RXEN_Msk                (0x1ul << I2S_CTRL_RXEN_Pos)                      /*!< I2S_T::CTRL: RXEN Mask                    */
N
N#define I2S_CTRL_MUTE_Pos                (3)                                               /*!< I2S_T::CTRL: MUTE Position                */
N#define I2S_CTRL_MUTE_Msk                (0x1ul << I2S_CTRL_MUTE_Pos)                      /*!< I2S_T::CTRL: MUTE Mask                    */
N
N#define I2S_CTRL_WORDWIDTH_Pos           (4)                                               /*!< I2S_T::CTRL: WORDWIDTH Position           */
N#define I2S_CTRL_WORDWIDTH_Msk           (0x3ul << I2S_CTRL_WORDWIDTH_Pos)                 /*!< I2S_T::CTRL: WORDWIDTH Mask               */
N
N#define I2S_CTRL_MONO_Pos                (6)                                               /*!< I2S_T::CTRL: MONO Position                */
N#define I2S_CTRL_MONO_Msk                (0x1ul << I2S_CTRL_MONO_Pos)                      /*!< I2S_T::CTRL: MONO Mask                    */
N
N#define I2S_CTRL_FORMAT_Pos              (7)                                               /*!< I2S_T::CTRL: FORMAT Position              */
N#define I2S_CTRL_FORMAT_Msk              (0x1ul << I2S_CTRL_FORMAT_Pos)                    /*!< I2S_T::CTRL: FORMAT Mask                  */
N
N#define I2S_CTRL_SLAVE_Pos               (8)                                               /*!< I2S_T::CTRL: SLAVE Position               */
N#define I2S_CTRL_SLAVE_Msk               (0x1ul << I2S_CTRL_SLAVE_Pos)                     /*!< I2S_T::CTRL: SLAVE Mask                   */
N
N#define I2S_CTRL_TXTH_Pos                (9)                                               /*!< I2S_T::CTRL: TXTH Position                */
N#define I2S_CTRL_TXTH_Msk                (0x7ul << I2S_CTRL_TXTH_Pos)                      /*!< I2S_T::CTRL: TXTH Mask                    */
N
N#define I2S_CTRL_RXTH_Pos                (12)                                              /*!< I2S_T::CTRL: RXTH Position                */
N#define I2S_CTRL_RXTH_Msk                (0x7ul << I2S_CTRL_RXTH_Pos)                      /*!< I2S_T::CTRL: RXTH Mask                    */
N
N#define I2S_CTRL_MCLKEN_Pos              (15)                                              /*!< I2S_T::CTRL: MCLKEN Position              */
N#define I2S_CTRL_MCLKEN_Msk              (0x1ul << I2S_CTRL_MCLKEN_Pos)                    /*!< I2S_T::CTRL: MCLKEN Mask                  */
N
N#define I2S_CTRL_RCHZCEN_Pos             (16)                                              /*!< I2S_T::CTRL: RCHZCEN Position             */
N#define I2S_CTRL_RCHZCEN_Msk             (0x1ul << I2S_CTRL_RCHZCEN_Pos)                   /*!< I2S_T::CTRL: RCHZCEN Mask                 */
N
N#define I2S_CTRL_LCHZCEN_Pos             (17)                                              /*!< I2S_T::CTRL: LCHZCEN Position             */
N#define I2S_CTRL_LCHZCEN_Msk             (0x1ul << I2S_CTRL_LCHZCEN_Pos)                   /*!< I2S_T::CTRL: LCHZCEN Mask                 */
N
N#define I2S_CTRL_CLR_TXFIFO_Pos          (18)                                              /*!< I2S_T::CTRL: CLR_TXFIFO Position          */
N#define I2S_CTRL_CLR_TXFIFO_Msk          (0x1ul << I2S_CTRL_CLR_TXFIFO_Pos)                /*!< I2S_T::CTRL: CLR_TXFIFO Mask              */
N
N#define I2S_CTRL_CLR_RXFIFO_Pos          (19)                                              /*!< I2S_T::CTRL: CLR_RXFIFO Position          */
N#define I2S_CTRL_CLR_RXFIFO_Msk          (0x1ul << I2S_CTRL_CLR_RXFIFO_Pos)                /*!< I2S_T::CTRL: CLR_RXFIFO Mask              */
N
N#define I2S_CTRL_TXDMA_Pos               (20)                                              /*!< I2S_T::CTRL: TXDMA Position               */
N#define I2S_CTRL_TXDMA_Msk               (0x1ul << I2S_CTRL_TXDMA_Pos)                     /*!< I2S_T::CTRL: TXDMA Mask                   */
N
N#define I2S_CTRL_RXDMA_Pos               (21)                                              /*!< I2S_T::CTRL: RXDMA Position               */
N#define I2S_CTRL_RXDMA_Msk               (0x1ul << I2S_CTRL_RXDMA_Pos)                     /*!< I2S_T::CTRL: RXDMA Mask                   */
N
N#define I2S_CTRL_RXLCH_Pos               (23)                                              /*!< I2S_T::CTRL: RXLCH Position               */
N#define I2S_CTRL_RXLCH_Msk               (0x1ul << I2S_CTRL_RXLCH_Pos)                     /*!< I2S_T::CTRL: RXLCH Mask                   */
N
N#define I2S_CLKDIV_MCLK_DIV_Pos          (0)                                               /*!< I2S_T::CLKDIV: MCLK_DIV Position          */
N#define I2S_CLKDIV_MCLK_DIV_Msk          (0x7ul << I2S_CLKDIV_MCLK_DIV_Pos)                /*!< I2S_T::CLKDIV: MCLK_DIV Mask              */
N
N#define I2S_CLKDIV_BCLK_DIV_Pos          (8)                                               /*!< I2S_T::CLKDIV: BCLK_DIV Position          */
N#define I2S_CLKDIV_BCLK_DIV_Msk          (0xfful << I2S_CLKDIV_BCLK_DIV_Pos)               /*!< I2S_T::CLKDIV: BCLK_DIV Mask              */
N
N#define I2S_INTEN_RXUDFIE_Pos            (0)                                               /*!< I2S_T::INTEN: RXUDFIE Position            */
N#define I2S_INTEN_RXUDFIE_Msk            (0x1ul << I2S_INTEN_RXUDFIE_Pos)                  /*!< I2S_T::INTEN: RXUDFIE Mask                */
N
N#define I2S_INTEN_RXOVFIE_Pos            (1)                                               /*!< I2S_T::INTEN: RXOVFIE Position            */
N#define I2S_INTEN_RXOVFIE_Msk            (0x1ul << I2S_INTEN_RXOVFIE_Pos)                  /*!< I2S_T::INTEN: RXOVFIE Mask                */
N
N#define I2S_INTEN_RXTHIE_Pos             (2)                                               /*!< I2S_T::INTEN: RXTHIE Position             */
N#define I2S_INTEN_RXTHIE_Msk             (0x1ul << I2S_INTEN_RXTHIE_Pos)                   /*!< I2S_T::INTEN: RXTHIE Mask                 */
N
N#define I2S_INTEN_TXUDFIE_Pos            (8)                                               /*!< I2S_T::INTEN: TXUDFIE Position            */
N#define I2S_INTEN_TXUDFIE_Msk            (0x1ul << I2S_INTEN_TXUDFIE_Pos)                  /*!< I2S_T::INTEN: TXUDFIE Mask                */
N
N#define I2S_INTEN_TXOVFIE_Pos            (9)                                               /*!< I2S_T::INTEN: TXOVFIE Position            */
N#define I2S_INTEN_TXOVFIE_Msk            (0x1ul << I2S_INTEN_TXOVFIE_Pos)                  /*!< I2S_T::INTEN: TXOVFIE Mask                */
N
N#define I2S_INTEN_TXTHIE_Pos             (10)                                              /*!< I2S_T::INTEN: TXTHIE Position             */
N#define I2S_INTEN_TXTHIE_Msk             (0x1ul << I2S_INTEN_TXTHIE_Pos)                   /*!< I2S_T::INTEN: TXTHIE Mask                 */
N
N#define I2S_INTEN_RZCIE_Pos              (11)                                              /*!< I2S_T::INTEN: RZCIE Position              */
N#define I2S_INTEN_RZCIE_Msk              (0x1ul << I2S_INTEN_RZCIE_Pos)                    /*!< I2S_T::INTEN: RZCIE Mask                  */
N
N#define I2S_INTEN_LZCIE_Pos              (12)                                              /*!< I2S_T::INTEN: LZCIE Position              */
N#define I2S_INTEN_LZCIE_Msk              (0x1ul << I2S_INTEN_LZCIE_Pos)                    /*!< I2S_T::INTEN: LZCIE Mask                  */
N
N#define I2S_STATUS_I2SINT_Pos            (0)                                               /*!< I2S_T::STATUS: I2SINT Position            */
N#define I2S_STATUS_I2SINT_Msk            (0x1ul << I2S_STATUS_I2SINT_Pos)                  /*!< I2S_T::STATUS: I2SINT Mask                */
N
N#define I2S_STATUS_I2SRXINT_Pos          (1)                                               /*!< I2S_T::STATUS: I2SRXINT Position          */
N#define I2S_STATUS_I2SRXINT_Msk          (0x1ul << I2S_STATUS_I2SRXINT_Pos)                /*!< I2S_T::STATUS: I2SRXINT Mask              */
N
N#define I2S_STATUS_I2STXINT_Pos          (2)                                               /*!< I2S_T::STATUS: I2STXINT Position          */
N#define I2S_STATUS_I2STXINT_Msk          (0x1ul << I2S_STATUS_I2STXINT_Pos)                /*!< I2S_T::STATUS: I2STXINT Mask              */
N
N#define I2S_STATUS_RIGHT_Pos             (3)                                               /*!< I2S_T::STATUS: RIGHT Position             */
N#define I2S_STATUS_RIGHT_Msk             (0x1ul << I2S_STATUS_RIGHT_Pos)                   /*!< I2S_T::STATUS: RIGHT Mask                 */
N
N#define I2S_STATUS_RXUDF_Pos             (8)                                               /*!< I2S_T::STATUS: RXUDF Position             */
N#define I2S_STATUS_RXUDF_Msk             (0x1ul << I2S_STATUS_RXUDF_Pos)                   /*!< I2S_T::STATUS: RXUDF Mask                 */
N
N#define I2S_STATUS_RXOVF_Pos             (9)                                               /*!< I2S_T::STATUS: RXOVF Position             */
N#define I2S_STATUS_RXOVF_Msk             (0x1ul << I2S_STATUS_RXOVF_Pos)                   /*!< I2S_T::STATUS: RXOVF Mask                 */
N
N#define I2S_STATUS_RXTHF_Pos             (10)                                              /*!< I2S_T::STATUS: RXTHF Position             */
N#define I2S_STATUS_RXTHF_Msk             (0x1ul << I2S_STATUS_RXTHF_Pos)                   /*!< I2S_T::STATUS: RXTHF Mask                 */
N
N#define I2S_STATUS_RXFULL_Pos            (11)                                              /*!< I2S_T::STATUS: RXFULL Position            */
N#define I2S_STATUS_RXFULL_Msk            (0x1ul << I2S_STATUS_RXFULL_Pos)                  /*!< I2S_T::STATUS: RXFULL Mask                */
N
N#define I2S_STATUS_RXEMPTY_Pos           (12)                                              /*!< I2S_T::STATUS: RXEMPTY Position           */
N#define I2S_STATUS_RXEMPTY_Msk           (0x1ul << I2S_STATUS_RXEMPTY_Pos)                 /*!< I2S_T::STATUS: RXEMPTY Mask               */
N
N#define I2S_STATUS_TXUDF_Pos             (16)                                              /*!< I2S_T::STATUS: TXUDF Position             */
N#define I2S_STATUS_TXUDF_Msk             (0x1ul << I2S_STATUS_TXUDF_Pos)                   /*!< I2S_T::STATUS: TXUDF Mask                 */
N
N#define I2S_STATUS_TXOVF_Pos             (17)                                              /*!< I2S_T::STATUS: TXOVF Position             */
N#define I2S_STATUS_TXOVF_Msk             (0x1ul << I2S_STATUS_TXOVF_Pos)                   /*!< I2S_T::STATUS: TXOVF Mask                 */
N
N#define I2S_STATUS_TXTHF_Pos             (18)                                              /*!< I2S_T::STATUS: TXTHF Position             */
N#define I2S_STATUS_TXTHF_Msk             (0x1ul << I2S_STATUS_TXTHF_Pos)                   /*!< I2S_T::STATUS: TXTHF Mask                 */
N
N#define I2S_STATUS_TXFULL_Pos            (19)                                              /*!< I2S_T::STATUS: TXFULL Position            */
N#define I2S_STATUS_TXFULL_Msk            (0x1ul << I2S_STATUS_TXFULL_Pos)                  /*!< I2S_T::STATUS: TXFULL Mask                */
N
N#define I2S_STATUS_TXEMPTY_Pos           (20)                                              /*!< I2S_T::STATUS: TXEMPTY Position           */
N#define I2S_STATUS_TXEMPTY_Msk           (0x1ul << I2S_STATUS_TXEMPTY_Pos)                 /*!< I2S_T::STATUS: TXEMPTY Mask               */
N
N#define I2S_STATUS_TXBUSY_Pos            (21)                                              /*!< I2S_T::STATUS: TXBUSY Position            */
N#define I2S_STATUS_TXBUSY_Msk            (0x1ul << I2S_STATUS_TXBUSY_Pos)                  /*!< I2S_T::STATUS: TXBUSY Mask                */
N
N#define I2S_STATUS_RZCF_Pos              (22)                                              /*!< I2S_T::STATUS: RZCF Position              */
N#define I2S_STATUS_RZCF_Msk              (0x1ul << I2S_STATUS_RZCF_Pos)                    /*!< I2S_T::STATUS: RZCF Mask                  */
N
N#define I2S_STATUS_LZCF_Pos              (23)                                              /*!< I2S_T::STATUS: LZCF Position              */
N#define I2S_STATUS_LZCF_Msk              (0x1ul << I2S_STATUS_LZCF_Pos)                    /*!< I2S_T::STATUS: LZCF Mask                  */
N
N#define I2S_STATUS_RX_LEVEL_Pos          (24)                                              /*!< I2S_T::STATUS: RX_LEVEL Position          */
N#define I2S_STATUS_RX_LEVEL_Msk          (0xful << I2S_STATUS_RX_LEVEL_Pos)                /*!< I2S_T::STATUS: RX_LEVEL Mask              */
N
N#define I2S_STATUS_TX_LEVEL_Pos          (28)                                              /*!< I2S_T::STATUS: TX_LEVEL Position          */
N#define I2S_STATUS_TX_LEVEL_Msk          (0xful << I2S_STATUS_TX_LEVEL_Pos)                /*!< I2S_T::STATUS: TX_LEVEL Mask              */
N
N#define I2S_TXFIFO_TXFIFO_Pos            (0)                                               /*!< I2S_T::TXFIFO: TXFIFO Position            */
N#define I2S_TXFIFO_TXFIFO_Msk            (0xfffffffful << I2S_TXFIFO_TXFIFO_Pos)           /*!< I2S_T::TXFIFO: TXFIFO Mask                */
N
N#define I2S_RXFIFO_RXFIFO_Pos            (0)                                               /*!< I2S_T::RXFIFO: RXFIFO Position            */
N#define I2S_RXFIFO_RXFIFO_Msk            (0xfffffffful << I2S_RXFIFO_RXFIFO_Pos)           /*!< I2S_T::RXFIFO: RXFIFO Mask                */
N
N/**@}*/ /* I2S_CONST */
N/**@}*/ /* end of I2S register group */
N
N
N/*---------------------- Interrupt Controller -------------------------*/
N/**
N    @addtogroup INT Interrupt Controller (INTR)
N    Memory Mapped Structure for INT Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * IRQ0SRC ~ IRQ31SRC
N     * ===================================================================================================
N     * Offset: 0x00 ~0x7C IRQ0~IRQ31 Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N    */
N    __I  uint32_t IRQSRC[32];
X    volatile const  uint32_t IRQSRC[32];
N
N
N    /**
N     * NMI_SEL
N     * ===================================================================================================
N     * Offset: 0x80  NMI Source Interrupt Select Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |NMI_SEL   |The NMI interrupt to Cortex-M0 can be selected from one of the interrupt[31:0]
N     * |        |          |The NMI_SEL bit[4:0] used to select the NMI interrupt source
N    */
N    __IO uint32_t NMI_SEL;
X    volatile uint32_t NMI_SEL;
N
N    /**
N     * MCU_IRQ
N     * ===================================================================================================
N     * Offset: 0x84  MCU IRQ Number Identity Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |MCU_IRQ   |MCU IRQ Source Register
N     * |        |          |The IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0 core.
N     * |        |          |There are two modes to generate interrupt to Cortex-M0 - the normal mode and test mode.
N     * |        |          |In Normal mode (control by NMI_SEL register bit [7] = 0) The MCU_IRQ collects all interrupts from each peripheral
N     * |        |          |and synchronizes  them and then interrupts  the Cortex-M0.
N     * |        |          |In Test mode, all the interrupts from peripheral are blocked, and the interrupts sent to
N     * |        |          |MCU are replaced by set the bit31~bit0.
N     * |        |          |When the IRQ[n] is 0, setting IRQ[n] to 1 will generate an interrupt to Cortex-M0 NVIC[n].
N     * |        |          |When the IRQ[n] is 1 (mean an interrupt is assert), setting 1 to the MCU_bit[n] will clear the interrupt and setting IRQ[n] 0 has no effect.
N    */
N    __IO uint32_t MCU_IRQ;
X    volatile uint32_t MCU_IRQ;
N
N} INTR_T;
N
N/**
N    @addtogroup INT_CONST INT Bit Field Definition
N    Constant Definitions for INT Controller
N@{ */
N
N#define INTR_IRQSRC_INT_SRC_Pos           (0)                                               /*!< INTR_T::IRQSRC: INT_SRC Position           */
N#define INTR_IRQSRC_INT_SRC_Msk           (0xful << INTR_IRQ0SRC_INT_SRC_Pos)               /*!< INTR_T::IRQSRC: INT_SRC Mask               */
N
N#define INTR_NMI_SEL_NMISEL_Pos           (0)                                               /*!< INTR_T::NMI_SEL: NMISEL Position           */
N#define INTR_NMI_SEL_NMISEL_Msk           (0x1ful << INTR_NMI_SEL_NMISEL_Pos)               /*!< INTR_T::NMI_SEL: NMISEL Mask               */
N
N#define INTR_MCU_IRQ_MCU_IRQ_Pos          (0)                                               /*!< INTR_T::MCU_IRQ: MCU_IRQ Position          */
N#define INTR_MCU_IRQ_MCU_IRQ_Msk          (0xfffffffful << INTR_MCU_IRQ_MCU_IRQ_Pos)        /*!< INTR_T::MCU_IRQ: MCU_IRQ Mask              */
N
N/**@}*/ /* INTR_CONST */
N/**@}*/ /* end of INTR register group */
N
N
N/*---------------------- LCD Controller -------------------------*/
N/**
N    @addtogroup LCD LCD Controller(LCD)
N    Memory Mapped Structure for LCD Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  LCD Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |EN        |LCD Enable
N     * |        |          |0 = LCD controller operation Disabled.
N     * |        |          |1 = LCD controller operation Enabled.
N     * |[3:1]   |MUX       |Mux Select
N     * |        |          |000 = Static.
N     * |        |          |001 = 1/2 duty.
N     * |        |          |010 = 1/3 duty.
N     * |        |          |011 = 1/4 duty.
N     * |        |          |100 = 1/5 duty.
N     * |        |          |101 = 1/6 duty.
N     * |        |          |110 = Reserved.
N     * |        |          |111 = Reserved.
N     * |        |          |Note : User does not need to set PD_H_MFP bit field, but only to set the MUX bit field to switch LCD_SEG0 and LCD_SEG1 to LCD_COM4 and LCD_COM5 for Nano110 and Nano130 series.
N     * |[6:4]   |FREQ      |LCD Frequency Selection
N     * |        |          |000 = LCDCLK Divided by 32.
N     * |        |          |001 = LCDCLK Divided by 64.
N     * |        |          |010 = LCDCLK Divided by 96.
N     * |        |          |011 = LCDCLK Divided by 128.
N     * |        |          |100 = LCDCLK Divided by 192.
N     * |        |          |101 = LCDCLK Divided by 256.
N     * |        |          |110 = LCDCLK Divided by 384.
N     * |        |          |111 = LCDCLK Divided by 512.
N     * |[7]     |BLINK     |LCD Blinking Enable
N     * |        |          |0 = Blinking Disabled.
N     * |        |          |1 = Blinking Enabled.
N     * |[8]     |PDDISP_EN |Power Down Display Enable
N     * |        |          |The LCD can be programmed to be displayed or not be displayed at power down state by PDDISP_EN setting.
N     * |        |          |0 = LCD display Disabled ( LCD is put out) at power down state.
N     * |        |          |1 = LCD display Enabled (LCD keeps the display) at power down state.
N     * |[9]     |PDINT_EN  |Power Down Interrupt Enable
N     * |        |          |If the power down request is triggered from system management, LCD controller will execute the frame completely to avoid the DC component.
N     * |        |          |When the frame is executed completely, the LCD power down interrupt signal is generated to inform system management that LCD controller is ready to enter power down state, if PDINT_EN is set to 1.
N     * |        |          |Otherwise, if PDINT_EN is set to 0, the LCD power down interrupt signal is blocked and the interrupt is disabled to send to system management.
N     * |        |          |0 = Power Down Interrupt Disabled.
N     * |        |          |1 = Power Down Interrupt Enabled.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * DISPCTL
N     * ===================================================================================================
N     * Offset: 0x04  LCD Display Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CPUMP_EN  |Charge Pump Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[2:1]   |BIAS_SEL  |Bias Selection
N     * |        |          |00 = Static.
N     * |        |          |01 = 1/2 Bias.
N     * |        |          |10 = 1/3 Bias.
N     * |        |          |11 = Reserved.
N     * |[4]     |IBRL_EN   |Internal Bias Reference Ladder Enable
N     * |        |          |0 = Bias reference ladder Disabled.
N     * |        |          |1 = Bias reference ladder Enabled.
N     * |[6]     |BV_SEL    |Bias Voltage Type Selection
N     * |        |          |0 = C-Type bias mode. Bias voltage source from internal bias generator.
N     * |        |          |1 = R-Type bias mode. Bias voltage source from external bias generator.
N     * |        |          |Note: The external resistor ladder should be connected to the V1 pin, V2 pin, V3 pin and VSS.
N     * |        |          |The VLCD pin should also be connected to VDD.
N     * |[10:8]  |CPUMP_VOL_SET|Charge Pump Voltage Selection
N     * |        |          |000 = 2.7V.
N     * |        |          |001 = 2.8V.
N     * |        |          |010 = 2.9V.
N     * |        |          |011 = 3.0V.
N     * |        |          |100 = 3.1V.
N     * |        |          |101 = 3.2V.
N     * |        |          |110 = 3.3V.
N     * |        |          |111 = 3.4V.
N     * |[13:11] |CPUMP_FREQ|Charge Pump Frequency Selection
N     * |        |          |000 = LCDCLK.
N     * |        |          |001 = LCDCLK/2.
N     * |        |          |010 = LCDCLK/4.
N     * |        |          |011 = LCDCLK/8.
N     * |        |          |100 = LCDCLK/16.
N     * |        |          |101 = LCDCLK/32.
N     * |        |          |110 = LCDCLK/64.
N     * |        |          |111 = LCDCLK/128.
N    */
N    __IO uint32_t DISPCTL;
X    volatile uint32_t DISPCTL;
N
N    /**
N     * MEM_0
N     * ===================================================================================================
N     * Offset: 0x08  LCD SEG3 ~ SEG0 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_0;
X    volatile uint32_t MEM_0;
N
N    /**
N     * MEM_1
N     * ===================================================================================================
N     * Offset: 0x0C  LCD SEG7 ~ SEG4 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_1;
X    volatile uint32_t MEM_1;
N
N    /**
N     * MEM_2
N     * ===================================================================================================
N     * Offset: 0x10  LCD SEG11 ~ SEG8 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_2;
X    volatile uint32_t MEM_2;
N
N    /**
N     * MEM_3
N     * ===================================================================================================
N     * Offset: 0x14  LCD SEG15 ~ SEG12 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_3;
X    volatile uint32_t MEM_3;
N
N    /**
N     * MEM_4
N     * ===================================================================================================
N     * Offset: 0x18  LCD SEG19 ~ SEG16 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_4;
X    volatile uint32_t MEM_4;
N
N    /**
N     * MEM_5
N     * ===================================================================================================
N     * Offset: 0x1C  LCD SEG23 ~ SEG20 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_5;
X    volatile uint32_t MEM_5;
N
N    /**
N     * MEM_6
N     * ===================================================================================================
N     * Offset: 0x20  LCD SEG27 ~ SEG24 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_6;
X    volatile uint32_t MEM_6;
N
N    /**
N     * MEM_7
N     * ===================================================================================================
N     * Offset: 0x24  LCD SEG31 ~ SEG28 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_7;
X    volatile uint32_t MEM_7;
N
N    /**
N     * MEM_8
N     * ===================================================================================================
N     * Offset: 0x28  LCD SEG35 ~ SEG32 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_8;
X    volatile uint32_t MEM_8;
N
N    /**
N     * MEM_9
N     * ===================================================================================================
N     * Offset: 0x2C  LCD SEG39 ~ SEG36 data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |SEG_0_4x  |SEG_0_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[14:8]  |SEG_1_4x  |SEG_1_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[21:16] |SEG_2_4x  |SEG_2_4x DATA for COM(x= 0 ~ 9)
N     * |        |          |LCD display data
N     * |[29:24] |SEG_3_4x  |SEG_3_4x DATA for COM (x = 0 ~ 9)
N     * |        |          |LCD display data
N    */
N    __IO uint32_t MEM_9;
X    volatile uint32_t MEM_9;
N
N    /**
N     * FCR
N     * ===================================================================================================
N     * Offset: 0x30  LCD frame counter control register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FCEN      |LCD Frame Counter Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[1]     |FCINTEN   |LCD Frame Counter Interrupt Enable
N     * |        |          |0 = Frame counter interrupt Disabled.
N     * |        |          |1 = Frame counter interrupt Enabled.
N     * |[3:2]   |PRESCL    |Frame Counter Pre-Scaler Value
N     * |        |          |00 = CLKframe/1.
N     * |        |          |01 = CLKframe/2.
N     * |        |          |10 = CLKframe/4.
N     * |        |          |11 = CLKframe/8.
N     * |[9:4]   |FCV       |Frame Counter Top Value
N     * |        |          |These 6 bits contain the top value of the Frame counter.
N    */
N    __IO uint32_t FCR;
X    volatile uint32_t FCR;
N
N    /**
N     * FCSTS
N     * ===================================================================================================
N     * Offset: 0x34  LCD frame counter status
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FCSTS     |LCD Frame Counter Status
N     * |        |          |0 = Frame counter value does not reach FCV (Frame Count TOP value).
N     * |        |          |1 = Frame counter value reaches FCV (Frame Count TOP value).
N     * |        |          |If the FCINTEN is s enabled, the frame counter overflow Interrupt is generated.
N     * |[1]     |PDSTS     |Power-Down Interrupt Status
N     * |        |          |0 = Inform system manager that LCD controller is not ready to enter power-down state until this bit becomes 1 if power down is set and one frame is not executed completely.
N     * |        |          |1 = Inform system manager that LCD controller is ready to enter power-down state if power down is set and one frame is executed completely
N    */
N    __IO uint32_t FCSTS;
X    volatile uint32_t FCSTS;
N
N} LCD_T;
N
N/**
N    @addtogroup LCD_CONST LCD Bit Field Definition
N    Constant Definitions for LCD Controller
N@{ */
N
N#define LCD_CTL_EN_Pos                   (0)                                               /*!< LCD_T::CTL: EN Position                   */
N#define LCD_CTL_EN_Msk                   (0x1ul << LCD_CTL_EN_Pos)                         /*!< LCD_T::CTL: EN Mask                       */
N
N#define LCD_CTL_MUX_Pos                  (1)                                               /*!< LCD_T::CTL: MUX Position                  */
N#define LCD_CTL_MUX_Msk                  (0x7ul << LCD_CTL_MUX_Pos)                        /*!< LCD_T::CTL: MUX Mask                      */
N
N#define LCD_CTL_FREQ_Pos                 (4)                                               /*!< LCD_T::CTL: FREQ Position                 */
N#define LCD_CTL_FREQ_Msk                 (0x7ul << LCD_CTL_FREQ_Pos)                       /*!< LCD_T::CTL: FREQ Mask                     */
N
N#define LCD_CTL_BLINK_Pos                (7)                                               /*!< LCD_T::CTL: BLINK Position                */
N#define LCD_CTL_BLINK_Msk                (0x1ul << LCD_CTL_BLINK_Pos)                      /*!< LCD_T::CTL: BLINK Mask                    */
N
N#define LCD_CTL_PDDISP_EN_Pos            (8)                                               /*!< LCD_T::CTL: PDDISP_EN Position            */
N#define LCD_CTL_PDDISP_EN_Msk            (0x1ul << LCD_CTL_PDDISP_EN_Pos)                  /*!< LCD_T::CTL: PDDISP_EN Mask                */
N
N#define LCD_CTL_PDINT_EN_Pos             (9)                                               /*!< LCD_T::CTL: PDINT_EN Position             */
N#define LCD_CTL_PDINT_EN_Msk             (0x1ul << LCD_CTL_PDINT_EN_Pos)                   /*!< LCD_T::CTL: PDINT_EN Mask                 */
N
N#define LCD_DISPCTL_CPUMP_EN_Pos         (0)                                               /*!< LCD_T::DISPCTL: CPUMP_EN Position         */
N#define LCD_DISPCTL_CPUMP_EN_Msk         (0x1ul << LCD_DISPCTL_CPUMP_EN_Pos)               /*!< LCD_T::DISPCTL: CPUMP_EN Mask             */
N
N#define LCD_DISPCTL_BIAS_SEL_Pos         (1)                                               /*!< LCD_T::DISPCTL: BIAS_SEL Position         */
N#define LCD_DISPCTL_BIAS_SEL_Msk         (0x3ul << LCD_DISPCTL_BIAS_SEL_Pos)               /*!< LCD_T::DISPCTL: BIAS_SEL Mask             */
N
N#define LCD_DISPCTL_IBRL_EN_Pos          (4)                                               /*!< LCD_T::DISPCTL: IBRL_EN Position          */
N#define LCD_DISPCTL_IBRL_EN_Msk          (0x1ul << LCD_DISPCTL_IBRL_EN_Pos)                /*!< LCD_T::DISPCTL: IBRL_EN Mask              */
N
N#define LCD_DISPCTL_BV_SEL_Pos           (6)                                               /*!< LCD_T::DISPCTL: BV_SEL Position           */
N#define LCD_DISPCTL_BV_SEL_Msk           (0x1ul << LCD_DISPCTL_BV_SEL_Pos)                 /*!< LCD_T::DISPCTL: BV_SEL Mask               */
N
N#define LCD_DISPCTL_CPUMP_VOL_SET_Pos    (8)                                               /*!< LCD_T::DISPCTL: CPUMP_VOL_SET Position    */
N#define LCD_DISPCTL_CPUMP_VOL_SET_Msk    (0x7ul << LCD_DISPCTL_CPUMP_VOL_SET_Pos)          /*!< LCD_T::DISPCTL: CPUMP_VOL_SET Mask        */
N
N#define LCD_DISPCTL_CPUMP_FREQ_Pos       (11)                                              /*!< LCD_T::DISPCTL: CPUMP_FREQ Position       */
N#define LCD_DISPCTL_CPUMP_FREQ_Msk       (0x7ul << LCD_DISPCTL_CPUMP_FREQ_Pos)             /*!< LCD_T::DISPCTL: CPUMP_FREQ Mask           */
N
N#define LCD_MEM_0_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_0: SEG_0_4x Position           */
N#define LCD_MEM_0_SEG_0_4x_Msk           (0x3ful << LCD_MEM_0_SEG_0_4x_Pos)                /*!< LCD_T::MEM_0: SEG_0_4x Mask               */
N
N#define LCD_MEM_0_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_0: SEG_1_4x Position           */
N#define LCD_MEM_0_SEG_1_4x_Msk           (0x7ful << LCD_MEM_0_SEG_1_4x_Pos)                /*!< LCD_T::MEM_0: SEG_1_4x Mask               */
N
N#define LCD_MEM_0_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_0: SEG_2_4x Position           */
N#define LCD_MEM_0_SEG_2_4x_Msk           (0x3ful << LCD_MEM_0_SEG_2_4x_Pos)                /*!< LCD_T::MEM_0: SEG_2_4x Mask               */
N
N#define LCD_MEM_0_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_0: SEG_3_4x Position           */
N#define LCD_MEM_0_SEG_3_4x_Msk           (0x3ful << LCD_MEM_0_SEG_3_4x_Pos)                /*!< LCD_T::MEM_0: SEG_3_4x Mask               */
N
N#define LCD_MEM_1_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_1: SEG_0_4x Position           */
N#define LCD_MEM_1_SEG_0_4x_Msk           (0x3ful << LCD_MEM_1_SEG_0_4x_Pos)                /*!< LCD_T::MEM_1: SEG_0_4x Mask               */
N
N#define LCD_MEM_1_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_1: SEG_1_4x Position           */
N#define LCD_MEM_1_SEG_1_4x_Msk           (0x7ful << LCD_MEM_1_SEG_1_4x_Pos)                /*!< LCD_T::MEM_1: SEG_1_4x Mask               */
N
N#define LCD_MEM_1_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_1: SEG_2_4x Position           */
N#define LCD_MEM_1_SEG_2_4x_Msk           (0x3ful << LCD_MEM_1_SEG_2_4x_Pos)                /*!< LCD_T::MEM_1: SEG_2_4x Mask               */
N
N#define LCD_MEM_1_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_1: SEG_3_4x Position           */
N#define LCD_MEM_1_SEG_3_4x_Msk           (0x3ful << LCD_MEM_1_SEG_3_4x_Pos)                /*!< LCD_T::MEM_1: SEG_3_4x Mask               */
N
N#define LCD_MEM_2_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_2: SEG_0_4x Position           */
N#define LCD_MEM_2_SEG_0_4x_Msk           (0x3ful << LCD_MEM_2_SEG_0_4x_Pos)                /*!< LCD_T::MEM_2: SEG_0_4x Mask               */
N
N#define LCD_MEM_2_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_2: SEG_1_4x Position           */
N#define LCD_MEM_2_SEG_1_4x_Msk           (0x7ful << LCD_MEM_2_SEG_1_4x_Pos)                /*!< LCD_T::MEM_2: SEG_1_4x Mask               */
N
N#define LCD_MEM_2_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_2: SEG_2_4x Position           */
N#define LCD_MEM_2_SEG_2_4x_Msk           (0x3ful << LCD_MEM_2_SEG_2_4x_Pos)                /*!< LCD_T::MEM_2: SEG_2_4x Mask               */
N
N#define LCD_MEM_2_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_2: SEG_3_4x Position           */
N#define LCD_MEM_2_SEG_3_4x_Msk           (0x3ful << LCD_MEM_2_SEG_3_4x_Pos)                /*!< LCD_T::MEM_2: SEG_3_4x Mask               */
N
N#define LCD_MEM_3_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_3: SEG_0_4x Position           */
N#define LCD_MEM_3_SEG_0_4x_Msk           (0x3ful << LCD_MEM_3_SEG_0_4x_Pos)                /*!< LCD_T::MEM_3: SEG_0_4x Mask               */
N
N#define LCD_MEM_3_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_3: SEG_1_4x Position           */
N#define LCD_MEM_3_SEG_1_4x_Msk           (0x7ful << LCD_MEM_3_SEG_1_4x_Pos)                /*!< LCD_T::MEM_3: SEG_1_4x Mask               */
N
N#define LCD_MEM_3_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_3: SEG_2_4x Position           */
N#define LCD_MEM_3_SEG_2_4x_Msk           (0x3ful << LCD_MEM_3_SEG_2_4x_Pos)                /*!< LCD_T::MEM_3: SEG_2_4x Mask               */
N
N#define LCD_MEM_3_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_3: SEG_3_4x Position           */
N#define LCD_MEM_3_SEG_3_4x_Msk           (0x3ful << LCD_MEM_3_SEG_3_4x_Pos)                /*!< LCD_T::MEM_3: SEG_3_4x Mask               */
N
N#define LCD_MEM_4_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_4: SEG_0_4x Position           */
N#define LCD_MEM_4_SEG_0_4x_Msk           (0x3ful << LCD_MEM_4_SEG_0_4x_Pos)                /*!< LCD_T::MEM_4: SEG_0_4x Mask               */
N
N#define LCD_MEM_4_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_4: SEG_1_4x Position           */
N#define LCD_MEM_4_SEG_1_4x_Msk           (0x7ful << LCD_MEM_4_SEG_1_4x_Pos)                /*!< LCD_T::MEM_4: SEG_1_4x Mask               */
N
N#define LCD_MEM_4_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_4: SEG_2_4x Position           */
N#define LCD_MEM_4_SEG_2_4x_Msk           (0x3ful << LCD_MEM_4_SEG_2_4x_Pos)                /*!< LCD_T::MEM_4: SEG_2_4x Mask               */
N
N#define LCD_MEM_4_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_4: SEG_3_4x Position           */
N#define LCD_MEM_4_SEG_3_4x_Msk           (0x3ful << LCD_MEM_4_SEG_3_4x_Pos)                /*!< LCD_T::MEM_4: SEG_3_4x Mask               */
N
N#define LCD_MEM_5_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_5: SEG_0_4x Position           */
N#define LCD_MEM_5_SEG_0_4x_Msk           (0x3ful << LCD_MEM_5_SEG_0_4x_Pos)                /*!< LCD_T::MEM_5: SEG_0_4x Mask               */
N
N#define LCD_MEM_5_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_5: SEG_1_4x Position           */
N#define LCD_MEM_5_SEG_1_4x_Msk           (0x7ful << LCD_MEM_5_SEG_1_4x_Pos)                /*!< LCD_T::MEM_5: SEG_1_4x Mask               */
N
N#define LCD_MEM_5_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_5: SEG_2_4x Position           */
N#define LCD_MEM_5_SEG_2_4x_Msk           (0x3ful << LCD_MEM_5_SEG_2_4x_Pos)                /*!< LCD_T::MEM_5: SEG_2_4x Mask               */
N
N#define LCD_MEM_5_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_5: SEG_3_4x Position           */
N#define LCD_MEM_5_SEG_3_4x_Msk           (0x3ful << LCD_MEM_5_SEG_3_4x_Pos)                /*!< LCD_T::MEM_5: SEG_3_4x Mask               */
N
N#define LCD_MEM_6_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_6: SEG_0_4x Position           */
N#define LCD_MEM_6_SEG_0_4x_Msk           (0x3ful << LCD_MEM_6_SEG_0_4x_Pos)                /*!< LCD_T::MEM_6: SEG_0_4x Mask               */
N
N#define LCD_MEM_6_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_6: SEG_1_4x Position           */
N#define LCD_MEM_6_SEG_1_4x_Msk           (0x7ful << LCD_MEM_6_SEG_1_4x_Pos)                /*!< LCD_T::MEM_6: SEG_1_4x Mask               */
N
N#define LCD_MEM_6_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_6: SEG_2_4x Position           */
N#define LCD_MEM_6_SEG_2_4x_Msk           (0x3ful << LCD_MEM_6_SEG_2_4x_Pos)                /*!< LCD_T::MEM_6: SEG_2_4x Mask               */
N
N#define LCD_MEM_6_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_6: SEG_3_4x Position           */
N#define LCD_MEM_6_SEG_3_4x_Msk           (0x3ful << LCD_MEM_6_SEG_3_4x_Pos)                /*!< LCD_T::MEM_6: SEG_3_4x Mask               */
N
N#define LCD_MEM_7_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_7: SEG_0_4x Position           */
N#define LCD_MEM_7_SEG_0_4x_Msk           (0x3ful << LCD_MEM_7_SEG_0_4x_Pos)                /*!< LCD_T::MEM_7: SEG_0_4x Mask               */
N
N#define LCD_MEM_7_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_7: SEG_1_4x Position           */
N#define LCD_MEM_7_SEG_1_4x_Msk           (0x7ful << LCD_MEM_7_SEG_1_4x_Pos)                /*!< LCD_T::MEM_7: SEG_1_4x Mask               */
N
N#define LCD_MEM_7_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_7: SEG_2_4x Position           */
N#define LCD_MEM_7_SEG_2_4x_Msk           (0x3ful << LCD_MEM_7_SEG_2_4x_Pos)                /*!< LCD_T::MEM_7: SEG_2_4x Mask               */
N
N#define LCD_MEM_7_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_7: SEG_3_4x Position           */
N#define LCD_MEM_7_SEG_3_4x_Msk           (0x3ful << LCD_MEM_7_SEG_3_4x_Pos)                /*!< LCD_T::MEM_7: SEG_3_4x Mask               */
N
N#define LCD_MEM_8_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_8: SEG_0_4x Position           */
N#define LCD_MEM_8_SEG_0_4x_Msk           (0x3ful << LCD_MEM_8_SEG_0_4x_Pos)                /*!< LCD_T::MEM_8: SEG_0_4x Mask               */
N
N#define LCD_MEM_8_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_8: SEG_1_4x Position           */
N#define LCD_MEM_8_SEG_1_4x_Msk           (0x7ful << LCD_MEM_8_SEG_1_4x_Pos)                /*!< LCD_T::MEM_8: SEG_1_4x Mask               */
N
N#define LCD_MEM_8_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_8: SEG_2_4x Position           */
N#define LCD_MEM_8_SEG_2_4x_Msk           (0x3ful << LCD_MEM_8_SEG_2_4x_Pos)                /*!< LCD_T::MEM_8: SEG_2_4x Mask               */
N
N#define LCD_MEM_8_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_8: SEG_3_4x Position           */
N#define LCD_MEM_8_SEG_3_4x_Msk           (0x3ful << LCD_MEM_8_SEG_3_4x_Pos)                /*!< LCD_T::MEM_8: SEG_3_4x Mask               */
N
N#define LCD_MEM_9_SEG_0_4x_Pos           (0)                                               /*!< LCD_T::MEM_9: SEG_0_4x Position           */
N#define LCD_MEM_9_SEG_0_4x_Msk           (0x3ful << LCD_MEM_9_SEG_0_4x_Pos)                /*!< LCD_T::MEM_9: SEG_0_4x Mask               */
N
N#define LCD_MEM_9_SEG_1_4x_Pos           (8)                                               /*!< LCD_T::MEM_9: SEG_1_4x Position           */
N#define LCD_MEM_9_SEG_1_4x_Msk           (0x7ful << LCD_MEM_9_SEG_1_4x_Pos)                /*!< LCD_T::MEM_9: SEG_1_4x Mask               */
N
N#define LCD_MEM_9_SEG_2_4x_Pos           (16)                                              /*!< LCD_T::MEM_9: SEG_2_4x Position           */
N#define LCD_MEM_9_SEG_2_4x_Msk           (0x3ful << LCD_MEM_9_SEG_2_4x_Pos)                /*!< LCD_T::MEM_9: SEG_2_4x Mask               */
N
N#define LCD_MEM_9_SEG_3_4x_Pos           (24)                                              /*!< LCD_T::MEM_9: SEG_3_4x Position           */
N#define LCD_MEM_9_SEG_3_4x_Msk           (0x3ful << LCD_MEM_9_SEG_3_4x_Pos)                /*!< LCD_T::MEM_9: SEG_3_4x Mask               */
N
N#define LCD_FCR_FCEN_Pos                 (0)                                               /*!< LCD_T::FCR: FCEN Position                 */
N#define LCD_FCR_FCEN_Msk                 (0x1ul << LCD_FCR_FCEN_Pos)                       /*!< LCD_T::FCR: FCEN Mask                     */
N
N#define LCD_FCR_FCINTEN_Pos              (1)                                               /*!< LCD_T::FCR: FCINTEN Position              */
N#define LCD_FCR_FCINTEN_Msk              (0x1ul << LCD_FCR_FCINTEN_Pos)                    /*!< LCD_T::FCR: FCINTEN Mask                  */
N
N#define LCD_FCR_PRESCL_Pos               (2)                                               /*!< LCD_T::FCR: PRESCL Position               */
N#define LCD_FCR_PRESCL_Msk               (0x3ul << LCD_FCR_PRESCL_Pos)                     /*!< LCD_T::FCR: PRESCL Mask                   */
N
N#define LCD_FCR_FCV_Pos                  (4)                                               /*!< LCD_T::FCR: FCV Position                  */
N#define LCD_FCR_FCV_Msk                  (0x3ful << LCD_FCR_FCV_Pos)                       /*!< LCD_T::FCR: FCV Mask                      */
N
N#define LCD_FCSTS_FCSTS_Pos              (0)                                               /*!< LCD_T::FCSTS: FCSTS Position              */
N#define LCD_FCSTS_FCSTS_Msk              (0x1ul << LCD_FCSTS_FCSTS_Pos)                    /*!< LCD_T::FCSTS: FCSTS Mask                  */
N
N#define LCD_FCSTS_PDSTS_Pos              (1)                                               /*!< LCD_T::FCSTS: PDSTS Position              */
N#define LCD_FCSTS_PDSTS_Msk              (0x1ul << LCD_FCSTS_PDSTS_Pos)                    /*!< LCD_T::FCSTS: PDSTS Mask                  */
N
N/**@}*/ /* LCD_CONST */
N/**@}*/ /* end of LCD register group */
N
N
N/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup DMA Direct Memory Access Controller(DMA)
N    Memory Mapped Structure for DMA Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  DMA CRC Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CRCCEN    |CRC Channel Enable
N     * |        |          |Setting this bit to 1 enables CRC's operation.
N     * |        |          |When operating in CRC DMA mode (TRIG_EN = 1), if user clear this bit, the DMA operation will be continuous until all CRC DMA operation done, and the TRIG_EN bit will asserted until all CRC DMA operation done.
N     * |        |          |But in this case, the CRC_DMAISR [BLKD_IF] flag will inactive, user can read CRC result by reading CRC_CHECKSUM register when TRIG_EN = 0.
N     * |        |          |When operating in CRC DMA mode (TRIG_EN = 1), if user want to stop the transfer immediately, user can write 1 to CRC_RST bit to stop the transmission.
N     * |[1]     |CRC_RST   |CRC Engine Reset
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit will reset the internal CRC state machine and internal buffer.
N     * |        |          |The contents of control register will not be cleared.
N     * |        |          |This bit will be auto cleared after few clock cycles.
N     * |        |          |Note: When operating in CPU PIO mode, setting this bit will reload the initial seed value
N     * |[23]    |TRIG_EN   |Trigger Enable
N     * |        |          |0 = No effect.
N     * |        |          |1 = CRC DMA data read or write transfer Enabled.
N     * |        |          |Note1: If this bit assert that indicates the CRC engine operation in CRC DMA mode, so don't filled any data in CRC_WDATA register.
N     * |        |          |Note2: When CRC DMA transfer completed, this bit will be cleared automatically.
N     * |        |          |Note3: If the bus error occurs, all CRC DMA transfer will be stopped.
N     * |        |          |Software must reset all DMA channel, and then trigger again.
N     * |[24]    |WDATA_RVS |Write Data Order Reverse
N     * |        |          |0 = No bit order reverse for CRC write data in.
N     * |        |          |1 = Bit order reverse for CRC write data in (per byre).
N     * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB
N     * |[25]    |CHECKSUM_RVS|Checksum Reverse
N     * |        |          |0 = No bit order reverse for CRC checksum.
N     * |        |          |1 = Bit order reverse for CRC checksum.
N     * |        |          |Note: If the checksum data is 0XDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB
N     * |[26]    |WDATA_COM |Write Data Complement
N     * |        |          |0 = No bit order reverse for CRC write data in.
N     * |        |          |1 = 1's complement for CRC write data in.
N     * |[27]    |CHECKSUM_COM|Checksum Complement
N     * |        |          |0 = No bit order reverse for CRC checksum.
N     * |        |          |1 = 1's complement for CRC checksum.
N     * |[29:28] |CPU_WDLEN |CPU Write Data Length
N     * |        |          |When operating in CPU PIO mode (CRCCEN= 1, TRIG_EN = 0), this field indicates the write data length.
N     * |        |          |00 = The data length is 8-bit mode
N     * |        |          |01 = The data length is 16-bit mode
N     * |        |          |10 = The data length is 32-bit mode
N     * |        |          |11 = Reserved
N     * |        |          |Note1: This field is only used for CPU PIO mode.
N     * |        |          |Note2: When the data length is 8-bit mode, the valid data is CRC_WDATA [7:0], and if the data length is 16 bit mode, the valid data is CRC_WDATA [15:0].
N     * |[31:30] |CRC_MODE  |CRC Polynomial Mode
N     * |        |          |00 = CRC-CCITT Polynomial Mode
N     * |        |          |01 = CRC-8 Polynomial Mode
N     * |        |          |10 = CRC-16 Polynomial Mode
N     * |        |          |11 = CRC-32 Polynomial Mode
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * DMASAR
N     * ===================================================================================================
N     * Offset: 0x04  DMA CRC Source Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |CRC_DMASAR|CRC DMA Transfer Source Address Register
N     * |        |          |This field indicates a 32-bit source address of CRC DMA.
N     * |        |          |Note : The source address must be word alignment
N    */
N    __IO uint32_t DMASAR;
X    volatile uint32_t DMASAR;
N    uint32_t RESERVE0[1];
N
N
N    /**
N     * DMABCR
N     * ===================================================================================================
N     * Offset: 0x0C  DMA CRC Transfer Byte Count Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRC_DMABCR|CRC DMA Transfer Byte Count Register
N     * |        |          |This field indicates a 16-bit transfer byte count number of CRC DMA
N    */
N    __IO uint32_t DMABCR;
X    volatile uint32_t DMABCR;
N    uint32_t RESERVE1[1];
N
N
N    /**
N     * DMACSAR
N     * ===================================================================================================
N     * Offset: 0x14  DMA CRC Current Source Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |CRC_DMACSAR|CRC DMA Current Source Address Register (Read Only)
N     * |        |          |This field indicates the source address where the CRC DMA transfer is just occurring.
N    */
N    __I  uint32_t DMACSAR;
X    volatile const  uint32_t DMACSAR;
N    uint32_t RESERVE2[1];
N
N
N    /**
N     * DMACBCR
N     * ===================================================================================================
N     * Offset: 0x1C  DMA CRC Current Transfer Byte Count Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRC_DMACBCR|CRC DMA Current Byte Count Register (Read Only)
N     * |        |          |This field indicates the current remained byte count of CRC_DMA.
N     * |        |          |Note: CRC_RST will clear this register value.
N    */
N    __I  uint32_t DMACBCR;
X    volatile const  uint32_t DMACBCR;
N
N    /**
N     * DMAIER
N     * ===================================================================================================
N     * Offset: 0x20  DMA CRC Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TABORT_IE |CRC DMA Read/Write Target Abort Interrupt Enable
N     * |        |          |0 = Target abort interrupt generation Disabled during CRC DMA transfer.
N     * |        |          |1 = Target abort interrupt generation Enabled during CRC DMA transfer.
N     * |[1]     |BLKD_IE   |CRC DMA Transfer Done Interrupt Enable
N     * |        |          |0 = Interrupt generator Disabled during CRC DMA transfer done.
N     * |        |          |1 = Interrupt generator Enabled during CRC DMA transfer done.
N    */
N    __IO uint32_t DMAIER;
X    volatile uint32_t DMAIER;
N
N    /**
N     * DMAISR
N     * ===================================================================================================
N     * Offset: 0x24  DMA CRC Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TABORT_IF |CRC DMA Read/Write Target Abort Interrupt Flag
N     * |        |          |0 = No bus ERROR response received.
N     * |        |          |1 = Bus ERROR response received.
N     * |        |          |Software can write 1 to clear this bit to zero
N     * |        |          |Note: The CRC_DMAISR [TABORT_IF] indicate bus master received ERROR response or not.
N     * |        |          |If bus master received ERROR response, it means that target abort is happened.
N     * |        |          |DMA will stop transfer and respond this event to software then go to IDLE state.
N     * |        |          |When target abort occurred, software must reset DMA, and then transfer those data again.
N     * |[1]     |BLKD_IF   |Block Transfer Done Interrupt Flag
N     * |        |          |This bit indicates that CRC DMA has finished all transfer.
N     * |        |          |0 = Not finished yet.
N     * |        |          |1 = Done.
N     * |        |          |Software can write 1 to clear this bit to zero
N    */
N    __IO uint32_t DMAISR;
X    volatile uint32_t DMAISR;
N    uint32_t RESERVE3[22];
N
N
N    /**
N     * WDATA
N     * ===================================================================================================
N     * Offset: 0x80  DMA CRC Write Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |CRC_WDATA |CRC Write Data Register
N     * |        |          |When operating in CPU PIO (CRC_CTL [CRCCEN] = 1, CRC_CTL [TRIG_EN] = 0) mode, software can write data to this field to perform CRC operation;.
N     * |        |          |When operating in CRC DMA mode (CRC_CTL [CRCCEN] = 1, CRC_CTL [TRIG_EN] = 0), this field will be used for DMA internal buffer.
N     * |        |          |Note1: When operating in CRC DMA mode, so don't filled any data in this field.
N     * |        |          |Note2:The CRC_CTL [WDATA_COM] and CRC_CTL [WDATA_RVS] bit setting will affected this field; For example, if WDATA_RVS = 1, if the write data in CRC_WDATA register is 0xAABBCCDD, the read data from CRC_WDATA register will be 0x55DD33BB
N    */
N    __IO uint32_t WDATA;
X    volatile uint32_t WDATA;
N
N    /**
N     * SEED
N     * ===================================================================================================
N     * Offset: 0x84  DMA CRC Seed Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |CRC_SEED  |CRC Seed Register
N     * |        |          |This field indicates the CRC seed value.
N    */
N    __IO uint32_t SEED;
X    volatile uint32_t SEED;
N
N    /**
N     * CHECKSUM
N     * ===================================================================================================
N     * Offset: 0x88  DMA CRC Check Sum Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |CRC_CHECKSUM|CRC Checksum Register
N     * |        |          |This field indicates the CRC checksum
N    */
N    __I  uint32_t CHECKSUM;
X    volatile const  uint32_t CHECKSUM;
N
N} DMA_CRC_T;
N
N
Ntypedef struct
N{
N
N
N    /**
N     * GCRCSR
N     * ===================================================================================================
N     * Offset: 0x00  DMA Global Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |CLK0_EN   |DMA Controller Channel 0 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[9]     |CLK1_EN   |DMA Controller Channel 1 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[10]    |CLK2_EN   |DMA Controller Channel 2 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[11]    |CLK3_EN   |DMA Controller Channel 3 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[12]    |CLK4_EN   |DMA Controller Channel 4 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[13]    |CLK5_EN   |DMA Controller Channel 5 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[14]    |CLK6_EN   |DMA Controller Channel 6 Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[24]    |CRC_CLK_EN|CRC Controller Clock Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N    */
N    __IO uint32_t GCRCSR;
X    volatile uint32_t GCRCSR;
N
N    /**
N     * DSSR0
N     * ===================================================================================================
N     * Offset: 0x04  DMA Service Selection Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[12:8]  |CH1_SEL   |Channel 1 Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 1.
N     * |        |          |Software can configure the peripheral by setting CH1_SEL.
N     * |        |          |00000 = Connect to SPI0_TX.
N     * |        |          |00001 = Connect to SPI1_TX.
N     * |        |          |00010 = Connect to UART0_TX.
N     * |        |          |00011 = Connect to UART1_TX.
N     * |        |          |00100 = Connect to USB_TX.
N     * |        |          |00101 = Connect to I2S_TX.
N     * |        |          |00110 = Connect to DAC0_TX.
N     * |        |          |00111 = Connect to DAC1_TX.
N     * |        |          |01000 = Connect to SPI2_TX.
N     * |        |          |01001 = Connect to TMR0.
N     * |        |          |01010 = Connect to TMR1.
N     * |        |          |01011 = Connect to TMR2.
N     * |        |          |01100 = Connect to TMR3.
N     * |        |          |10000 = Connect to SPI0_RX.
N     * |        |          |10001 = Connect to SPI1_RX.
N     * |        |          |10010 = Connect to UART0_RX.
N     * |        |          |10011 = Connect to UART1_RX.
N     * |        |          |10100 = Connect to USB_RX.
N     * |        |          |10101 = Connect to I2S_RX.
N     * |        |          |10110 = Connect to ADC.
N     * |        |          |11000 = Connect to SPI2_RX.
N     * |        |          |11001 = Connect to PWM0_CH0.
N     * |        |          |11010 = Connect to PWM0_CH2.
N     * |        |          |11011 = Connect to PWM1_CH0.
N     * |        |          |11100 = Connect to PWM1_CH2.
N     * |[20:16] |CH2_SEL   |Channel 2 Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 2.
N     * |        |          |Software can configure the peripheral setting by CH2_SEL.
N     * |        |          |The channel configuration is the same as CH1_SEL field.
N     * |        |          |Please refer to the explanation of CH1_SEL.
N     * |[28:24] |CH3_SEL   |Channel 3 Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 3.
N     * |        |          |Software can configure the peripheral setting by CH3_SEL.
N     * |        |          |The channel configuration is the same as CH1_SEL field.
N     * |        |          |Please refer to the explanation of CH1_SEL.
N    */
N    __IO uint32_t DSSR0;
X    volatile uint32_t DSSR0;
N
N    /**
N     * DSSR1
N     * ===================================================================================================
N     * Offset: 0x08  DMA Service Selection Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |CH4_SEL   |Channel 4 Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 4.
N     * |        |          |Software can configure the peripheral by setting CH4_SEL.
N     * |        |          |The channel configuration is the same as CH1_SEL field.
N     * |        |          |Please refer to the explanation of CH1_SEL.
N     * |[12:8]  |CH5_SEL   |Channel 5 Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 5.
N     * |        |          |Software can configure the peripheral setting by CH5_SEL.
N     * |        |          |The channel configuration is the same as CH1_SEL field.
N     * |        |          |Please refer to the explanation of CH1_SEL.
N     * |[20:16] |CH6_SEL   |Channel 6 Selection
N     * |        |          |This filed defines which peripheral is connected to PDMA channel 6.
N     * |        |          |Software can configure the peripheral setting by CH6_SEL.
N     * |        |          |The channel configuration is the same as CH1_SEL field.
N     * |        |          |Please refer to the explanation of CH1_SEL.
N    */
N    __IO uint32_t DSSR1;
X    volatile uint32_t DSSR1;
N
N    /**
N     * GCRISR
N     * ===================================================================================================
N     * Offset: 0x0C  DMA Global Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INTR0     |Interrupt Pin Status Of Channel 0 (Read Only)
N     * |        |          |This bit is the Interrupt pin status of DMA channel0.
N     * |        |          |Note: This bit is read only
N     * |[1]     |INTR1     |Interrupt Pin Status Of Channel 1 (Read Only)
N     * |        |          |This bit is the Interrupt pin status of DMA channel1.
N     * |        |          |Note: This bit is read only
N     * |[2]     |INTR2     |Interrupt Pin Status Of Channel 2 (Read Only)
N     * |        |          |This bit is the Interrupt pin status of DMA channel2.
N     * |        |          |Note: This bit is read only
N     * |[3]     |INTR3     |Interrupt Pin Status Of Channel 3 (Read Only)
N     * |        |          |This bit is the Interrupt pin status of DMA channel3.
N     * |        |          |Note: This bit is read only
N     * |[4]     |INTR4     |Interrupt Pin Status Of Channel 4 (Read Only)
N     * |        |          |This bit is the Interrupt pin status of DMA channel4.
N     * |        |          |Note: This bit is read only
N     * |[5]     |INTR5     |Interrupt Pin Status Of Channel 5 (Read Only)
N     * |        |          |This bit is the Interrupt pin status of DMA channel4.
N     * |        |          |Note: This bit is read only
N     * |[6]     |INTR6     |Interrupt Pin Status Of Channel 6 (Read Only)
N     * |        |          |This bit is the Interrupt pin status of DMA channel4.
N     * |        |          |Note: This bit is read only
N     * |[16]    |CRC_INTR  |Interrupt Pin Status Of CRC Controller
N     * |        |          |This bit is the Interrupt status of CRC controller
N     * |        |          |Note: This bit is read only
N    */
N    __I  uint32_t GCRISR;
X    volatile const  uint32_t GCRISR;
N
N} DMA_GCR_T;
N
N
Ntypedef struct
N{
N    /**
N     * CSR
N     * ===================================================================================================
N     * Offset: 0x00  PDMA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PDMACEN   |PDMA Channel Enable
N     * |        |          |Setting this bit to "1" enables PDMA's operation.
N     * |        |          |If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
N     * |        |          |Note: SW_RST will clear this bit.
N     * |[1]     |SW_RST    |Software Engine Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the internal state machine and pointers.
N     * |        |          |The contents of control register will not be cleared.
N     * |        |          |This bit will be auto cleared after few clock cycles.
N     * |[3:2]   |MODE_SEL  |PDMA Mode Select
N     * |        |          |00 = Memory to Memory mode (Memory-to-Memory).
N     * |        |          |01 = IP to Memory mode (APB-to-Memory)
N     * |        |          |10 = Memory to IP mode (Memory-to-APB).
N     * |        |          |11 = Reserved.
N     * |[5:4]   |SAD_SEL   |Transfer Source Address Direction Selection
N     * |        |          |00 = Transfer Source address is incremented successively.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
N     * |        |          |11 = Transfer Source address is wrap around (When the PDMA_CBCR is equal to zero, the PDMA_CSAR and PDMA_CBCR register will be updated by PDMA_SAR and PDMA_BCR automatically.
N     * |        |          |PDMA will start another transfer without software trigger until PDMA_EN disabled.
N     * |        |          |When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address).
N     * |[7:6]   |DAD_SEL   |Transfer Destination Address Direction Selection
N     * |        |          |00 = Transfer Destination address is incremented successively
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination)
N     * |        |          |11 = Transfer Destination address is wrapped around (When the PDMA_CBCR is equal to zero, the PDMA_CDAR and PDMA_CBCR register will be updated by PDMA_DAR and PDMA_BCR automatically.
N     * |        |          |PDMA will start another transfer without software trigger until PDMA_EN disabled.
N     * |        |          |When the PDMA_EN is disabled, the PDMA will complete the active transfer but the remained data which in the PDMA_BUF will not transfer to destination address).
N     * |[12]    |TO_EN     |Time-Out Enable
N     * |        |          |This bit will enable PDMA internal counter. While this counter counts to zero, the TO_IS will be set.
N     * |        |          |0 = PDMA internal counter Disabled.
N     * |        |          |1 = PDMA internal counter Enabled.
N     * |[20:19] |APB_TWS   |Peripheral Transfer Width Selection
N     * |        |          |00 = One word (32 bits) is transferred for every PDMA operation.
N     * |        |          |01 = One byte (8 bits) is transferred for every PDMA operation.
N     * |        |          |10 = One half-word (16 bits) is transferred for every PDMA operation.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).
N     * |[23]    |TRIG_EN   |TRIG_EN
N     * |        |          |0 = No effect.
N     * |        |          |1 = PDMA data read or write transfer Enabled.
N     * |        |          |Note1: When PDMA transfer completed, this bit will be cleared automatically.
N     * |        |          |Note2: If the bus error occurs, all PDMA transfer will be stopped.
N     * |        |          |Software must reset all PDMA channel, and then trig again.
N    */
N    __IO uint32_t CSR;
X    volatile uint32_t CSR;
N
N    /**
N     * SAR
N     * ===================================================================================================
N     * Offset: 0x04  PDMA Source Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDMA_SAR  |PDMA Transfer Source Address Register
N     * |        |          |This field indicates a 32-bit source address of PDMA.
N     * |        |          |Note: The source address must be word alignment.
N    */
N    __IO uint32_t SAR;
X    volatile uint32_t SAR;
N
N    /**
N     * DAR
N     * ===================================================================================================
N     * Offset: 0x08  PDMA Destination Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDMA_DAR  |PDMA Transfer Destination Address Register
N     * |        |          |This field indicates a 32-bit destination address of PDMA.
N     * |        |          |Note : The destination address must be word alignment
N    */
N    __IO uint32_t DAR;
X    volatile uint32_t DAR;
N
N    /**
N     * BCR
N     * ===================================================================================================
N     * Offset: 0x0C  PDMA Transfer Byte Count Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDMA_BCR  |PDMA Transfer Byte Count Register
N     * |        |          |This field indicates a 16-bit transfer byte count of PDMA.
N     * |        |          |Note: In Memory-to-memory (PDMA_CSR [MODE_SEL] = 00) mode, the transfer byte count must be word alignment.
N    */
N    __IO uint32_t BCR;
X    volatile uint32_t BCR;
N    uint32_t RESERVE0[1];
N
N
N    /**
N     * CSAR
N     * ===================================================================================================
N     * Offset: 0x14  PDMA Current Source Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDMA_CSAR |PDMA Current Source Address Register (Read Only)
N     * |        |          |This field indicates the source address where the PDMA transfer is just occurring.
N    */
N    __I  uint32_t CSAR;
X    volatile const  uint32_t CSAR;
N
N    /**
N     * CDAR
N     * ===================================================================================================
N     * Offset: 0x18  PDMA Current Destination Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDMA_CDAR |PDMA Current Destination Address Register (Read Only)
N     * |        |          |This field indicates the destination address where the PDMA transfer is just occurring.
N    */
N    __I  uint32_t CDAR;
X    volatile const  uint32_t CDAR;
N
N    /**
N     * CBCR
N     * ===================================================================================================
N     * Offset: 0x1C  PDMA Current Transfer Byte Count Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |PDMA_CBCR |PDMA Current Byte Count Register (Read Only)
N     * |        |          |This field indicates the current remained byte count of PDMA.
N     * |        |          |Note: These fields will be changed when PDMA finish data transfer (data transfer to destination address),
N    */
N    __I  uint32_t CBCR;
X    volatile const  uint32_t CBCR;
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x20  PDMA Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TABORT_IE |PDMA Read/Write Target Abort Interrupt Enable
N     * |        |          |0 = Target abort interrupt generation Disabled during PDMA transfer.
N     * |        |          |1 = Target abort interrupt generation Enabled during PDMA transfer.
N     * |[1]     |TD_IE     |PDMA Transfer Done Interrupt Enable
N     * |        |          |0 = Interrupt generator Disabled when PDMA transfer is done.
N     * |        |          |1 = Interrupt generator Enabled when PDMA transfer is done.
N     * |[5:2]   |WRA_BCR_IE|Wrap Around Byte Count Interrupt Enable
N     * |        |          |0001 = Interrupt enable of PDMA_CBCR equals 0
N     * |        |          |0100 = Interrupt enable of PDMA_CBCR equals 1/2 PDMA_BCR.
N     * |[6]     |TO_IE     |Time-Out Interrupt Enable
N     * |        |          |0 = Time-out interrupt Disabled.
N     * |        |          |1 = Time-out interrupt Enabled.
N    */
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N
N    /**
N     * ISR
N     * ===================================================================================================
N     * Offset: 0x24  PDMA Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TABORT_IS |PDMA Read/Write Target Abort Interrupt Status Flag
N     * |        |          |0 = No bus ERROR response received.
N     * |        |          |1 = Bus ERROR response received.
N     * |        |          |Note1: This bit is cleared by writing "1" to itself.
N     * |        |          |Note2: The PDMA_ISR [TABORT_IF] indicate bus master received ERROR response or not, if bus master received occur it means that target abort is happened.
N     * |        |          |PDMA controller will stop transfer and respond this event to software then go to IDLE state.
N     * |        |          |When target abort occurred, software must reset PDMA controller, and then transfer those data again.
N     * |[1]     |TD_IS     |Transfer Done Interrupt Status Flag
N     * |        |          |This bit indicates that PDMA has finished all transfer.
N     * |        |          |0 = Not finished yet.
N     * |        |          |1 = Done.
N     * |        |          |Note: This bit is cleared by writing "1" to itself.
N     * |[5:2]   |WRA_BCR_IS|Wrap Around Transfer Byte Count Interrupt Status Flag
N     * |        |          |WAR_)CR_IS [0] (xxx1) = PDMA_CBCR equal 0 flag.
N     * |        |          |WAR_BCR_IS [2] (x1xx) = PDMA_CBCR equal 1/2 PDMA_BCR flag.
N     * |        |          |Note: Each bit is cleared by writing "1" to itself.
N     * |        |          |This field is only valid in wrap around mode.
N     * |        |          |(PDMA_CSR[DAD_SEL] =11 or PDMA_CSR[SAD_SEL] =11).
N     * |[6]     |TO_IS     |Time-Out Interrupt Status Flag
N     * |        |          |This flag indicated that PDMA has waited peripheral request for a period defined by PDMA_TCR.
N     * |        |          |0 = No time-out flag.
N     * |        |          |1 = Time-out flag.
N     * |        |          |Note: This bit is cleared by writing "1" to itself.
N    */
N    __IO uint32_t ISR;
X    volatile uint32_t ISR;
N
N    /**
N     * TCR
N     * ===================================================================================================
N     * Offset: 0x28  PDMA Timer Counter Setting Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDMA_TCR  |PDMA Timer Count Setting Register
N     * |        |          |Each PDMA channel contains an internal counter.
N     * |        |          |The internal counter loads the value of PDAM_TCR and starts counting down when setting PDMA_CSRx [TO_EN] register.
N     * |        |          |PDMA will request interrupt when this internal counter reaches zero and PDMA_IERx[TO_IE] is high.
N     * |        |          |This internal counter will reload and start counting when completing each peripheral request service.
N    */
N    __IO uint32_t TCR;
X    volatile uint32_t TCR;
N
N} PDMA_T;
N
N
N
Ntypedef struct
N{
N
N
N    /**
N     * CSR
N     * ===================================================================================================
N     * Offset: 0x00  VDMA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |VDMACEN   |VDMA Channel Enable
N     * |        |          |Setting this bit to "1" enables VDMA's operation.
N     * |        |          |If this bit is cleared, VDMA will ignore all VDMA request and force Bus Master into IDLE state.
N     * |        |          |Note: SW_RST will clear this bit.
N     * |[1]     |SW_RST    |Software Engine Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the internal state machine and pointers.
N     * |        |          |The contents of control register will not be cleared.
N     * |        |          |This bit will be auto cleared after few clock cycles.
N     * |[10]    |STRIDE_EN |Stride Mode Enable
N     * |        |          |0 = Stride transfer mode Disabled.
N     * |        |          |1 = Stride transfer mode Enabled.
N     * |[11]    |DIR_SEL   |Transfer Source/Destination Address Direction Select
N     * |        |          |0 = Transfer address is incremented successively.
N     * |        |          |1 = Transfer address is decremented successively.
N     * |[23]    |TRIG_EN   |TRIG_EN
N     * |        |          |0 = No effect.
N     * |        |          |1 = VDMA data read or write transfer Enabled.
N     * |        |          |Note1: When VDMA transfer is completed, this bit will be cleared automatically.
N     * |        |          |Note2: If the bus error occurs, all VDMA transfer will be stopped.
N     * |        |          |Software must reset all VDMA channel, and then trig again.
N    */
N    __IO uint32_t CSR;
X    volatile uint32_t CSR;
N
N    /**
N     * SAR
N     * ===================================================================================================
N     * Offset: 0x04  VDMA Source Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |VDMA_SAR  |VDMA Transfer Source Address Register
N     * |        |          |This field indicates a 32-bit source address of VDMA.
N    */
N    __IO uint32_t SAR;
X    volatile uint32_t SAR;
N
N    /**
N     * DAR
N     * ===================================================================================================
N     * Offset: 0x08  VDMA Destination Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |VDMA_DAR  |VDMA Transfer Destination Address Register
N     * |        |          |This field indicates a 32-bit destination address of VDMA.
N    */
N    __IO uint32_t DAR;
X    volatile uint32_t DAR;
N
N    /**
N     * BCR
N     * ===================================================================================================
N     * Offset: 0x0C  VDMA Transfer Byte Count Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |VDMA_BCR  |VDMA Transfer Byte Count Register
N     * |        |          |This field indicates a 16-bit transfer byte count of VDMA.
N     * |        |          |Note: In Stride Enable mode (VDMA_CSR [10] = "0"]), the transfer byte count (VDMA_BCR) must be an integer multiple of STBC (VDMA_SASOCR [31:16]).
N    */
N    __IO uint32_t BCR;
X    volatile uint32_t BCR;
N    uint32_t RESERVE0[1];
N
N
N    /**
N     * CSAR
N     * ===================================================================================================
N     * Offset: 0x14  VDMA Current Source Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |VDMA_CSAR |VDMA Current Source Address Register (Read Only)
N     * |        |          |This field indicates the source address where the VDMA transfer is just occurring.
N    */
N    __I  uint32_t CSAR;
X    volatile const  uint32_t CSAR;
N
N    /**
N     * CDAR
N     * ===================================================================================================
N     * Offset: 0x18  VDMA Current Destination Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |VDMA_CDAR |VDMA Current Destination Address Register (Read Only)
N     * |        |          |This field indicates the destination address where the VDMA transfer is just occurring.
N    */
N    __I  uint32_t CDAR;
X    volatile const  uint32_t CDAR;
N
N    /**
N     * CBCR
N     * ===================================================================================================
N     * Offset: 0x1C  VDMA Current Transfer Byte Count Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |VDMA_CBCR |VDMA Current Byte Count Register (Read Only)
N     * |        |          |This field indicates the current remained byte count of VDMA.
N    */
N    __I  uint32_t CBCR;
X    volatile const  uint32_t CBCR;
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x20  VDMA Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TABORT_IE |VDMA Read/Write Target Abort Interrupt Enable
N     * |        |          |0 = Disabled target abort interrupt generation during VDMA transfer.
N     * |        |          |1 = Enabled target abort interrupt generation during VDMA transfer.
N     * |[1]     |TD_IE     |VDMA Transfer Done Interrupt Enable
N     * |        |          |0 = Disabled interrupt generator during VDMA transfer done.
N     * |        |          |1 = Enabled interrupt generator during VDMA transfer done.
N    */
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N
N    /**
N     * ISR
N     * ===================================================================================================
N     * Offset: 0x24  VDMA Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TABORT_IS |VDMA Read/Write Target Abort Interrupt Status Flag
N     * |        |          |0 = No bus ERROR response received.
N     * |        |          |1 = Bus ERROR response received.
N     * |        |          |Note1: This bit is cleared by writing "1" to itself.
N     * |        |          |Note2: The VDMA_ISR [TABORT_IF] indicate bus master received ERROR response or not, if bus master received occur it means that target abort is happened.
N     * |        |          |VDMA controller will stop transfer and respond this event to software then go to IDLE state.
N     * |        |          |When target abort occurred, software must reset VDMA controller, and then transfer those data again.
N     * |[1]     |TD_IS     |Transfer Done Interrupt Status Flag
N     * |        |          |This bit indicates that VDMA has finished all transfer.
N     * |        |          |0 = Not finished yet.
N     * |        |          |1 = Done.
N     * |        |          |Note: This bit is cleared by writing "1" to itself.
N    */
N    __IO uint32_t ISR;
X    volatile uint32_t ISR;
N    uint32_t RESERVE1[1];
N
N
N    /**
N     * SASOCR
N     * ===================================================================================================
N     * Offset: 0x2C  VDMA Source Address Stride Offset Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |SASTOBL   |VDMA Source Address Stride Offset Byte Length
N     * |        |          |The 16-bit register defines the source address stride transfer offset count of each row.
N     * |[31:16] |STBC      |VDMA Stride Transfer Byte Count
N     * |        |          |The 16-bit register defines the stride transfer byte count of each row.
N    */
N    __IO uint32_t SASOCR;
X    volatile uint32_t SASOCR;
N
N    /**
N     * DASOCR
N     * ===================================================================================================
N     * Offset: 0x30  VDMA Destination Address Stride Offset Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |DASTOBL   |VDMA Destination Address Stride Offset Byte Length
N     * |        |          |The 16-bit register defines the destination address stride transfer offset count of each row.
N    */
N    __IO uint32_t DASOCR;
X    volatile uint32_t DASOCR;
N
N} VDMA_T;
N
N
N/**
N    @addtogroup DMA_CRC_CONST DMA_CRC Bit Field Definition
N    Constant Definitions for DMA_CRC Controller
N@{ */
N
N#define DMA_CRC_CTL_CRCCEN_Pos           (0)                                               /*!< DMA_CRC_T::CTL: CRCCEN Position           */
N#define DMA_CRC_CTL_CRCCEN_Msk           (0x1ul << DMA_CRC_CTL_CRCCEN_Pos)                 /*!< DMA_CRC_T::CTL: CRCCEN Mask               */
N
N#define DMA_CRC_CTL_CRC_RST_Pos          (1)                                               /*!< DMA_CRC_T::CTL: CRC_RST Position          */
N#define DMA_CRC_CTL_CRC_RST_Msk          (0x1ul << DMA_CRC_CTL_CRC_RST_Pos)                /*!< DMA_CRC_T::CTL: CRC_RST Mask              */
N
N#define DMA_CRC_CTL_TRIG_EN_Pos          (23)                                              /*!< DMA_CRC_T::CTL: TRIG_EN Position          */
N#define DMA_CRC_CTL_TRIG_EN_Msk          (0x1ul << DMA_CRC_CTL_TRIG_EN_Pos)                /*!< DMA_CRC_T::CTL: TRIG_EN Mask              */
N
N#define DMA_CRC_CTL_WDATA_RVS_Pos        (24)                                              /*!< DMA_CRC_T::CTL: WDATA_RVS Position        */
N#define DMA_CRC_CTL_WDATA_RVS_Msk        (0x1ul << DMA_CRC_CTL_WDATA_RVS_Pos)              /*!< DMA_CRC_T::CTL: WDATA_RVS Mask            */
N
N#define DMA_CRC_CTL_CHECKSUM_RVS_Pos     (25)                                              /*!< DMA_CRC_T::CTL: CHECKSUM_RVS Position     */
N#define DMA_CRC_CTL_CHECKSUM_RVS_Msk     (0x1ul << DMA_CRC_CTL_CHECKSUM_RVS_Pos)           /*!< DMA_CRC_T::CTL: CHECKSUM_RVS Mask         */
N
N#define DMA_CRC_CTL_WDATA_COM_Pos        (26)                                              /*!< DMA_CRC_T::CTL: WDATA_COM Position        */
N#define DMA_CRC_CTL_WDATA_COM_Msk        (0x1ul << DMA_CRC_CTL_WDATA_COM_Pos)              /*!< DMA_CRC_T::CTL: WDATA_COM Mask            */
N
N#define DMA_CRC_CTL_CHECKSUM_COM_Pos     (27)                                              /*!< DMA_CRC_T::CTL: CHECKSUM_COM Position     */
N#define DMA_CRC_CTL_CHECKSUM_COM_Msk     (0x1ul << DMA_CRC_CTL_CHECKSUM_COM_Pos)           /*!< DMA_CRC_T::CTL: CHECKSUM_COM Mask         */
N
N#define DMA_CRC_CTL_CPU_WDLEN_Pos        (28)                                              /*!< DMA_CRC_T::CTL: CPU_WDLEN Position        */
N#define DMA_CRC_CTL_CPU_WDLEN_Msk        (0x3ul << DMA_CRC_CTL_CPU_WDLEN_Pos)              /*!< DMA_CRC_T::CTL: CPU_WDLEN Mask            */
N
N#define DMA_CRC_CTL_CRC_MODE_Pos         (30)                                              /*!< DMA_CRC_T::CTL: CRC_MODE Position         */
N#define DMA_CRC_CTL_CRC_MODE_Msk         (0x3ul << DMA_CRC_CTL_CRC_MODE_Pos)               /*!< DMA_CRC_T::CTL: CRC_MODE Mask             */
N
N#define DMA_CRC_DMASAR_CRC_DMASAR_Pos    (0)                                               /*!< DMA_CRC_T::DMASAR: CRC_DMASAR Position    */
N#define DMA_CRC_DMASAR_CRC_DMASAR_Msk    (0xfffffffful << DMA_CRC_DMASAR_CRC_DMASAR_Pos)   /*!< DMA_CRC_T::DMASAR: CRC_DMASAR Mask        */
N
N#define DMA_CRC_DMABCR_CRC_DMABCR_Pos    (0)                                               /*!< DMA_CRC_T::DMABCR: CRC_DMABCR Position    */
N#define DMA_CRC_DMABCR_CRC_DMABCR_Msk    (0xfffful << DMA_CRC_DMABCR_CRC_DMABCR_Pos)       /*!< DMA_CRC_T::DMABCR: CRC_DMABCR Mask        */
N
N#define DMA_CRC_DMACSAR_CRC_DMACSAR_Pos  (0)                                               /*!< DMA_CRC_T::DMACSAR: CRC_DMACSAR Position  */
N#define DMA_CRC_DMACSAR_CRC_DMACSAR_Msk  (0xfffffffful << DMA_CRC_DMACSAR_CRC_DMACSAR_Pos) /*!< DMA_CRC_T::DMACSAR: CRC_DMACSAR Mask      */
N
N#define DMA_CRC_DMACBCR_CRC_DMACBCR_Pos  (0)                                               /*!< DMA_CRC_T::DMACBCR: CRC_DMACBCR Position  */
N#define DMA_CRC_DMACBCR_CRC_DMACBCR_Msk  (0xfffful << DMA_CRC_DMACBCR_CRC_DMACBCR_Pos)     /*!< DMA_CRC_T::DMACBCR: CRC_DMACBCR Mask      */
N
N#define DMA_CRC_DMAIER_TABORT_IE_Pos     (0)                                               /*!< DMA_CRC_T::DMAIER: TABORT_IE Position     */
N#define DMA_CRC_DMAIER_TABORT_IE_Msk     (0x1ul << DMA_CRC_DMAIER_TABORT_IE_Pos)           /*!< DMA_CRC_T::DMAIER: TABORT_IE Mask         */
N
N#define DMA_CRC_DMAIER_BLKD_IE_Pos       (1)                                               /*!< DMA_CRC_T::DMAIER: BLKD_IE Position       */
N#define DMA_CRC_DMAIER_BLKD_IE_Msk       (0x1ul << DMA_CRC_DMAIER_BLKD_IE_Pos)             /*!< DMA_CRC_T::DMAIER: BLKD_IE Mask           */
N
N#define DMA_CRC_DMAISR_TABORT_IF_Pos     (0)                                               /*!< DMA_CRC_T::DMAISR: TABORT_IF Position     */
N#define DMA_CRC_DMAISR_TABORT_IF_Msk     (0x1ul << DMA_CRC_DMAISR_TABORT_IF_Pos)           /*!< DMA_CRC_T::DMAISR: TABORT_IF Mask         */
N
N#define DMA_CRC_DMAISR_BLKD_IF_Pos       (1)                                               /*!< DMA_CRC_T::DMAISR: BLKD_IF Position       */
N#define DMA_CRC_DMAISR_BLKD_IF_Msk       (0x1ul << DMA_CRC_DMAISR_BLKD_IF_Pos)             /*!< DMA_CRC_T::DMAISR: BLKD_IF Mask           */
N
N#define DMA_CRC_WDATA_CRC_WDATA_Pos      (0)                                               /*!< DMA_CRC_T::WDATA: CRC_WDATA Position      */
N#define DMA_CRC_WDATA_CRC_WDATA_Msk      (0xfffffffful << DMA_CRC_WDATA_CRC_WDATA_Pos)     /*!< DMA_CRC_T::WDATA: CRC_WDATA Mask          */
N
N#define DMA_CRC_SEED_CRC_SEED_Pos        (0)                                               /*!< DMA_CRC_T::SEED: CRC_SEED Position        */
N#define DMA_CRC_SEED_CRC_SEED_Msk        (0xfffffffful << DMA_CRC_SEED_CRC_SEED_Pos)       /*!< DMA_CRC_T::SEED: CRC_SEED Mask            */
N
N#define DMA_CRC_CHECKSUM_CRC_CHECKSUM_Pos (0)                                              /*!< DMA_CRC_T::CHECKSUM: CRC_CHECKSUM Position*/
N#define DMA_CRC_CHECKSUM_CRC_CHECKSUM_Msk (0xfffffffful << DMA_CRC_CHECKSUM_CRC_CHECKSUM_Pos) /*!< DMA_CRC_T::CHECKSUM: CRC_CHECKSUM Mask    */
N
N/**@}*/ /* DMA_CRC_CONST */
N
N
N/**
N    @addtogroup DMA_GCR_CONST DMA_GCR Bit Field Definition
N    Constant Definitions for DMA_GCR Controller
N@{ */
N
N#define DMA_GCR_GCRCSR_CLK0_EN_Pos       (8)                                               /*!< DMA_GCR_T::GCRCSR: CLK0_EN Position       */
N#define DMA_GCR_GCRCSR_CLK0_EN_Msk       (0x1ul << DMA_GCR_GCRCSR_CLK0_EN_Pos)             /*!< DMA_GCR_T::GCRCSR: CLK0_EN Mask           */
N
N#define DMA_GCR_GCRCSR_CLK1_EN_Pos       (9)                                               /*!< DMA_GCR_T::GCRCSR: CLK1_EN Position       */
N#define DMA_GCR_GCRCSR_CLK1_EN_Msk       (0x1ul << DMA_GCR_GCRCSR_CLK1_EN_Pos)             /*!< DMA_GCR_T::GCRCSR: CLK1_EN Mask           */
N
N#define DMA_GCR_GCRCSR_CLK2_EN_Pos       (10)                                              /*!< DMA_GCR_T::GCRCSR: CLK2_EN Position       */
N#define DMA_GCR_GCRCSR_CLK2_EN_Msk       (0x1ul << DMA_GCR_GCRCSR_CLK2_EN_Pos)             /*!< DMA_GCR_T::GCRCSR: CLK2_EN Mask           */
N
N#define DMA_GCR_GCRCSR_CLK3_EN_Pos       (11)                                              /*!< DMA_GCR_T::GCRCSR: CLK3_EN Position       */
N#define DMA_GCR_GCRCSR_CLK3_EN_Msk       (0x1ul << DMA_GCR_GCRCSR_CLK3_EN_Pos)             /*!< DMA_GCR_T::GCRCSR: CLK3_EN Mask           */
N
N#define DMA_GCR_GCRCSR_CLK4_EN_Pos       (12)                                              /*!< DMA_GCR_T::GCRCSR: CLK4_EN Position       */
N#define DMA_GCR_GCRCSR_CLK4_EN_Msk       (0x1ul << DMA_GCR_GCRCSR_CLK4_EN_Pos)             /*!< DMA_GCR_T::GCRCSR: CLK4_EN Mask           */
N
N#define DMA_GCR_GCRCSR_CLK5_EN_Pos       (13)                                              /*!< DMA_GCR_T::GCRCSR: CLK5_EN Position       */
N#define DMA_GCR_GCRCSR_CLK5_EN_Msk       (0x1ul << DMA_GCR_GCRCSR_CLK5_EN_Pos)             /*!< DMA_GCR_T::GCRCSR: CLK5_EN Mask           */
N
N#define DMA_GCR_GCRCSR_CLK6_EN_Pos       (14)                                              /*!< DMA_GCR_T::GCRCSR: CLK6_EN Position       */
N#define DMA_GCR_GCRCSR_CLK6_EN_Msk       (0x1ul << DMA_GCR_GCRCSR_CLK6_EN_Pos)             /*!< DMA_GCR_T::GCRCSR: CLK6_EN Mask           */
N
N#define DMA_GCR_GCRCSR_CRC_CLK_EN_Pos    (24)                                              /*!< DMA_GCR_T::GCRCSR: CRC_CLK_EN Position    */
N#define DMA_GCR_GCRCSR_CRC_CLK_EN_Msk    (0x1ul << DMA_GCR_GCRCSR_CRC_CLK_EN_Pos)          /*!< DMA_GCR_T::GCRCSR: CRC_CLK_EN Mask        */
N
N#define DMA_GCR_DSSR0_CH1_SEL_Pos        (8)                                               /*!< DMA_GCR_T::DSSR0: CH1_SEL Position        */
N#define DMA_GCR_DSSR0_CH1_SEL_Msk        (0x1ful << DMA_GCR_DSSR0_CH1_SEL_Pos)             /*!< DMA_GCR_T::DSSR0: CH1_SEL Mask            */
N
N#define DMA_GCR_DSSR0_CH2_SEL_Pos        (16)                                              /*!< DMA_GCR_T::DSSR0: CH2_SEL Position        */
N#define DMA_GCR_DSSR0_CH2_SEL_Msk        (0x1ful << DMA_GCR_DSSR0_CH2_SEL_Pos)             /*!< DMA_GCR_T::DSSR0: CH2_SEL Mask            */
N
N#define DMA_GCR_DSSR0_CH3_SEL_Pos        (24)                                              /*!< DMA_GCR_T::DSSR0: CH3_SEL Position        */
N#define DMA_GCR_DSSR0_CH3_SEL_Msk        (0x1ful << DMA_GCR_DSSR0_CH3_SEL_Pos)             /*!< DMA_GCR_T::DSSR0: CH3_SEL Mask            */
N
N#define DMA_GCR_DSSR1_CH4_SEL_Pos        (0)                                               /*!< DMA_GCR_T::DSSR1: CH4_SEL Position        */
N#define DMA_GCR_DSSR1_CH4_SEL_Msk        (0x1ful << DMA_GCR_DSSR1_CH4_SEL_Pos)             /*!< DMA_GCR_T::DSSR1: CH4_SEL Mask            */
N
N#define DMA_GCR_DSSR1_CH5_SEL_Pos        (8)                                               /*!< DMA_GCR_T::DSSR1: CH5_SEL Position        */
N#define DMA_GCR_DSSR1_CH5_SEL_Msk        (0x1ful << DMA_GCR_DSSR1_CH5_SEL_Pos)             /*!< DMA_GCR_T::DSSR1: CH5_SEL Mask            */
N
N#define DMA_GCR_DSSR1_CH6_SEL_Pos        (16)                                              /*!< DMA_GCR_T::DSSR1: CH6_SEL Position        */
N#define DMA_GCR_DSSR1_CH6_SEL_Msk        (0x1ful << DMA_GCR_DSSR1_CH6_SEL_Pos)             /*!< DMA_GCR_T::DSSR1: CH6_SEL Mask            */
N
N#define DMA_GCR_GCRISR_INTR0_Pos         (0)                                               /*!< DMA_GCR_T::GCRISR: INTR0 Position         */
N#define DMA_GCR_GCRISR_INTR0_Msk         (0x1ul << DMA_GCR_GCRISR_INTR0_Pos)               /*!< DMA_GCR_T::GCRISR: INTR0 Mask             */
N
N#define DMA_GCR_GCRISR_INTR1_Pos         (1)                                               /*!< DMA_GCR_T::GCRISR: INTR1 Position         */
N#define DMA_GCR_GCRISR_INTR1_Msk         (0x1ul << DMA_GCR_GCRISR_INTR1_Pos)               /*!< DMA_GCR_T::GCRISR: INTR1 Mask             */
N
N#define DMA_GCR_GCRISR_INTR2_Pos         (2)                                               /*!< DMA_GCR_T::GCRISR: INTR2 Position         */
N#define DMA_GCR_GCRISR_INTR2_Msk         (0x1ul << DMA_GCR_GCRISR_INTR2_Pos)               /*!< DMA_GCR_T::GCRISR: INTR2 Mask             */
N
N#define DMA_GCR_GCRISR_INTR3_Pos         (3)                                               /*!< DMA_GCR_T::GCRISR: INTR3 Position         */
N#define DMA_GCR_GCRISR_INTR3_Msk         (0x1ul << DMA_GCR_GCRISR_INTR3_Pos)               /*!< DMA_GCR_T::GCRISR: INTR3 Mask             */
N
N#define DMA_GCR_GCRISR_INTR4_Pos         (4)                                               /*!< DMA_GCR_T::GCRISR: INTR4 Position         */
N#define DMA_GCR_GCRISR_INTR4_Msk         (0x1ul << DMA_GCR_GCRISR_INTR4_Pos)               /*!< DMA_GCR_T::GCRISR: INTR4 Mask             */
N
N#define DMA_GCR_GCRISR_INTR5_Pos         (5)                                               /*!< DMA_GCR_T::GCRISR: INTR5 Position         */
N#define DMA_GCR_GCRISR_INTR5_Msk         (0x1ul << DMA_GCR_GCRISR_INTR5_Pos)               /*!< DMA_GCR_T::GCRISR: INTR5 Mask             */
N
N#define DMA_GCR_GCRISR_INTR6_Pos         (6)                                               /*!< DMA_GCR_T::GCRISR: INTR6 Position         */
N#define DMA_GCR_GCRISR_INTR6_Msk         (0x1ul << DMA_GCR_GCRISR_INTR6_Pos)               /*!< DMA_GCR_T::GCRISR: INTR6 Mask             */
N
N#define DMA_GCR_GCRISR_CRC_INTR_Pos      (16)                                              /*!< DMA_GCR_T::GCRISR: CRC_INTR Position      */
N#define DMA_GCR_GCRISR_CRC_INTR_Msk      (0x1ul << DMA_GCR_GCRISR_CRC_INTR_Pos)            /*!< DMA_GCR_T::GCRISR: CRC_INTR Mask          */
N
N/**@}*/ /* DMA_GCR_CONST */
N
N
N/**
N    @addtogroup PDMA_CONST PDMA Bit Field Definition
N    Constant Definitions for PDMA Controller
N@{ */
N
N#define PDMA_CSR_PDMACEN_Pos             (0)                                               /*!< PDMA_T::CSR: PDMACEN Position             */
N#define PDMA_CSR_PDMACEN_Msk             (0x1ul << PDMA_CSR_PDMACEN_Pos)                   /*!< PDMA_T::CSR: PDMACEN Mask                 */
N
N#define PDMA_CSR_SW_RST_Pos              (1)                                               /*!< PDMA_T::CSR: SW_RST Position              */
N#define PDMA_CSR_SW_RST_Msk              (0x1ul << PDMA_CSR_SW_RST_Pos)                    /*!< PDMA_T::CSR: SW_RST Mask                  */
N
N#define PDMA_CSR_MODE_SEL_Pos            (2)                                               /*!< PDMA_T::CSR: MODE_SEL Position            */
N#define PDMA_CSR_MODE_SEL_Msk            (0x3ul << PDMA_CSR_MODE_SEL_Pos)                  /*!< PDMA_T::CSR: MODE_SEL Mask                */
N
N#define PDMA_CSR_SAD_SEL_Pos             (4)                                               /*!< PDMA_T::CSR: SAD_SEL Position             */
N#define PDMA_CSR_SAD_SEL_Msk             (0x3ul << PDMA_CSR_SAD_SEL_Pos)                   /*!< PDMA_T::CSR: SAD_SEL Mask                 */
N
N#define PDMA_CSR_DAD_SEL_Pos             (6)                                               /*!< PDMA_T::CSR: DAD_SEL Position             */
N#define PDMA_CSR_DAD_SEL_Msk             (0x3ul << PDMA_CSR_DAD_SEL_Pos)                   /*!< PDMA_T::CSR: DAD_SEL Mask                 */
N
N#define PDMA_CSR_TO_EN_Pos               (12)                                              /*!< PDMA_T::CSR: TO_EN Position               */
N#define PDMA_CSR_TO_EN_Msk               (0x1ul << PDMA_CSR_TO_EN_Pos)                     /*!< PDMA_T::CSR: TO_EN Mask                   */
N
N#define PDMA_CSR_APB_TWS_Pos             (19)                                              /*!< PDMA_T::CSR: APB_TWS Position             */
N#define PDMA_CSR_APB_TWS_Msk             (0x3ul << PDMA_CSR_APB_TWS_Pos)                   /*!< PDMA_T::CSR: APB_TWS Mask                 */
N
N#define PDMA_CSR_TRIG_EN_Pos             (23)                                              /*!< PDMA_T::CSR: TRIG_EN Position             */
N#define PDMA_CSR_TRIG_EN_Msk             (0x1ul << PDMA_CSR_TRIG_EN_Pos)                   /*!< PDMA_T::CSR: TRIG_EN Mask                 */
N
N#define PDMA_SAR_PDMA_SAR_Pos            (0)                                               /*!< PDMA_T::SAR: PDMA_SAR Position            */
N#define PDMA_SAR_PDMA_SAR_Msk            (0xfffffffful << PDMA_SAR_PDMA_SAR_Pos)           /*!< PDMA_T::SAR: PDMA_SAR Mask                */
N
N#define PDMA_DAR_PDMA_DAR_Pos            (0)                                               /*!< PDMA_T::DAR: PDMA_DAR Position            */
N#define PDMA_DAR_PDMA_DAR_Msk            (0xfffffffful << PDMA_DAR_PDMA_DAR_Pos)           /*!< PDMA_T::DAR: PDMA_DAR Mask                */
N
N#define PDMA_BCR_PDMA_BCR_Pos            (0)                                               /*!< PDMA_T::BCR: PDMA_BCR Position            */
N#define PDMA_BCR_PDMA_BCR_Msk            (0xfffful << PDMA_BCR_PDMA_BCR_Pos)               /*!< PDMA_T::BCR: PDMA_BCR Mask                */
N
N#define PDMA_CSAR_PDMA_CSAR_Pos          (0)                                               /*!< PDMA_T::CSAR: PDMA_CSAR Position          */
N#define PDMA_CSAR_PDMA_CSAR_Msk          (0xfffffffful << PDMA_CSAR_PDMA_CSAR_Pos)         /*!< PDMA_T::CSAR: PDMA_CSAR Mask              */
N
N#define PDMA_CDAR_PDMA_CDAR_Pos          (0)                                               /*!< PDMA_T::CDAR: PDMA_CDAR Position          */
N#define PDMA_CDAR_PDMA_CDAR_Msk          (0xfffffffful << PDMA_CDAR_PDMA_CDAR_Pos)         /*!< PDMA_T::CDAR: PDMA_CDAR Mask              */
N
N#define PDMA_CBCR_PDMA_CBCR_Pos          (0)                                               /*!< PDMA_T::CBCR: PDMA_CBCR Position          */
N#define PDMA_CBCR_PDMA_CBCR_Msk          (0xfffffful << PDMA_CBCR_PDMA_CBCR_Pos)           /*!< PDMA_T::CBCR: PDMA_CBCR Mask              */
N
N#define PDMA_IER_TABORT_IE_Pos           (0)                                               /*!< PDMA_T::IER: TABORT_IE Position           */
N#define PDMA_IER_TABORT_IE_Msk           (0x1ul << PDMA_IER_TABORT_IE_Pos)                 /*!< PDMA_T::IER: TABORT_IE Mask               */
N
N#define PDMA_IER_TD_IE_Pos               (1)                                               /*!< PDMA_T::IER: TD_IE Position               */
N#define PDMA_IER_TD_IE_Msk               (0x1ul << PDMA_IER_TD_IE_Pos)                     /*!< PDMA_T::IER: TD_IE Mask                   */
N
N#define PDMA_IER_WRA_BCR_IE_Pos          (2)                                               /*!< PDMA_T::IER: WRA_BCR_IE Position          */
N#define PDMA_IER_WRA_BCR_IE_Msk          (0xful << PDMA_IER_WRA_BCR_IE_Pos)                /*!< PDMA_T::IER: WRA_BCR_IE Mask              */
N
N#define PDMA_IER_TO_IE_Pos               (6)                                               /*!< PDMA_T::IER: TO_IE Position               */
N#define PDMA_IER_TO_IE_Msk               (0x1ul << PDMA_IER_TO_IE_Pos)                     /*!< PDMA_T::IER: TO_IE Mask                   */
N
N#define PDMA_ISR_TABORT_IS_Pos           (0)                                               /*!< PDMA_T::ISR: TABORT_IS Position           */
N#define PDMA_ISR_TABORT_IS_Msk           (0x1ul << PDMA_ISR_TABORT_IS_Pos)                 /*!< PDMA_T::ISR: TABORT_IS Mask               */
N
N#define PDMA_ISR_TD_IS_Pos               (1)                                               /*!< PDMA_T::ISR: TD_IS Position               */
N#define PDMA_ISR_TD_IS_Msk               (0x1ul << PDMA_ISR_TD_IS_Pos)                     /*!< PDMA_T::ISR: TD_IS Mask                   */
N
N#define PDMA_ISR_WRA_BCR_IS_Pos          (2)                                               /*!< PDMA_T::ISR: WRA_BCR_IS Position          */
N#define PDMA_ISR_WRA_BCR_IS_Msk          (0xful << PDMA_ISR_WRA_BCR_IS_Pos)                /*!< PDMA_T::ISR: WRA_BCR_IS Mask              */
N
N#define PDMA_ISR_TO_IS_Pos               (6)                                               /*!< PDMA_T::ISR: TO_IS Position               */
N#define PDMA_ISR_TO_IS_Msk               (0x1ul << PDMA_ISR_TO_IS_Pos)                     /*!< PDMA_T::ISR: TO_IS Mask                   */
N
N#define PDMA_TCR_PDMA_TCR_Pos            (0)                                               /*!< PDMA_T::TCR: PDMA_TCR Position            */
N#define PDMA_TCR_PDMA_TCR_Msk            (0xfffful << PDMA_TCR_PDMA_TCR_Pos)               /*!< PDMA_T::TCR: PDMA_TCR Mask                */
N
N/**@}*/ /* PDMA_CONST */
N
N
N/**
N    @addtogroup VDMA_CONST VDMA Bit Field Definition
N    Constant Definitions for VDMA Controller
N@{ */
N
N#define VDMA_CSR_VDMACEN_Pos             (0)                                               /*!< VDMA_T::CSR: VDMACEN Position             */
N#define VDMA_CSR_VDMACEN_Msk             (0x1ul << VDMA_CSR_VDMACEN_Pos)                   /*!< VDMA_T::CSR: VDMACEN Mask                 */
N
N#define VDMA_CSR_SW_RST_Pos              (1)                                               /*!< VDMA_T::CSR: SW_RST Position              */
N#define VDMA_CSR_SW_RST_Msk              (0x1ul << VDMA_CSR_SW_RST_Pos)                    /*!< VDMA_T::CSR: SW_RST Mask                  */
N
N#define VDMA_CSR_STRIDE_EN_Pos           (10)                                              /*!< VDMA_T::CSR: STRIDE_EN Position           */
N#define VDMA_CSR_STRIDE_EN_Msk           (0x1ul << VDMA_CSR_STRIDE_EN_Pos)                 /*!< VDMA_T::CSR: STRIDE_EN Mask               */
N
N#define VDMA_CSR_DIR_SEL_Pos             (11)                                              /*!< VDMA_T::CSR: DIR_SEL Position             */
N#define VDMA_CSR_DIR_SEL_Msk             (0x1ul << VDMA_CSR_DIR_SEL_Pos)                   /*!< VDMA_T::CSR: DIR_SEL Mask                 */
N
N#define VDMA_CSR_TRIG_EN_Pos             (23)                                              /*!< VDMA_T::CSR: TRIG_EN Position             */
N#define VDMA_CSR_TRIG_EN_Msk             (0x1ul << VDMA_CSR_TRIG_EN_Pos)                   /*!< VDMA_T::CSR: TRIG_EN Mask                 */
N
N#define VDMA_SAR_VDMA_SAR_Pos            (0)                                               /*!< VDMA_T::SAR: VDMA_SAR Position            */
N#define VDMA_SAR_VDMA_SAR_Msk            (0xfffffffful << VDMA_SAR_VDMA_SAR_Pos)           /*!< VDMA_T::SAR: VDMA_SAR Mask                */
N
N#define VDMA_DAR_VDMA_DAR_Pos            (0)                                               /*!< VDMA_T::DAR: VDMA_DAR Position            */
N#define VDMA_DAR_VDMA_DAR_Msk            (0xfffffffful << VDMA_DAR_VDMA_DAR_Pos)           /*!< VDMA_T::DAR: VDMA_DAR Mask                */
N
N#define VDMA_BCR_VDMA_BCR_Pos            (0)                                               /*!< VDMA_T::BCR: VDMA_BCR Position            */
N#define VDMA_BCR_VDMA_BCR_Msk            (0xfffful << VDMA_BCR_VDMA_BCR_Pos)               /*!< VDMA_T::BCR: VDMA_BCR Mask                */
N
N#define VDMA_CSAR_VDMA_CSAR_Pos          (0)                                               /*!< VDMA_T::CSAR: VDMA_CSAR Position          */
N#define VDMA_CSAR_VDMA_CSAR_Msk          (0xfffffffful << VDMA_CSAR_VDMA_CSAR_Pos)         /*!< VDMA_T::CSAR: VDMA_CSAR Mask              */
N
N#define VDMA_CDAR_VDMA_CDAR_Pos          (0)                                               /*!< VDMA_T::CDAR: VDMA_CDAR Position          */
N#define VDMA_CDAR_VDMA_CDAR_Msk          (0xfffffffful << VDMA_CDAR_VDMA_CDAR_Pos)         /*!< VDMA_T::CDAR: VDMA_CDAR Mask              */
N
N#define VDMA_CBCR_VDMA_CBCR_Pos          (0)                                               /*!< VDMA_T::CBCR: VDMA_CBCR Position          */
N#define VDMA_CBCR_VDMA_CBCR_Msk          (0xfffful << VDMA_CBCR_VDMA_CBCR_Pos)             /*!< VDMA_T::CBCR: VDMA_CBCR Mask              */
N
N#define VDMA_IER_TABORT_IE_Pos           (0)                                               /*!< VDMA_T::IER: TABORT_IE Position           */
N#define VDMA_IER_TABORT_IE_Msk           (0x1ul << VDMA_IER_TABORT_IE_Pos)                 /*!< VDMA_T::IER: TABORT_IE Mask               */
N
N#define VDMA_IER_TD_IE_Pos               (1)                                               /*!< VDMA_T::IER: TD_IE Position               */
N#define VDMA_IER_TD_IE_Msk               (0x1ul << VDMA_IER_TD_IE_Pos)                     /*!< VDMA_T::IER: TD_IE Mask                   */
N
N#define VDMA_ISR_TABORT_IS_Pos           (0)                                               /*!< VDMA_T::ISR: TABORT_IS Position           */
N#define VDMA_ISR_TABORT_IS_Msk           (0x1ul << VDMA_ISR_TABORT_IS_Pos)                 /*!< VDMA_T::ISR: TABORT_IS Mask               */
N
N#define VDMA_ISR_TD_IS_Pos               (1)                                               /*!< VDMA_T::ISR: TD_IS Position               */
N#define VDMA_ISR_TD_IS_Msk               (0x1ul << VDMA_ISR_TD_IS_Pos)                     /*!< VDMA_T::ISR: TD_IS Mask                   */
N
N#define VDMA_SASOCR_SASTOBL_Pos          (0)                                               /*!< VDMA_T::SASOCR: SASTOBL Position          */
N#define VDMA_SASOCR_SASTOBL_Msk          (0xfffful << VDMA_SASOCR_SASTOBL_Pos)             /*!< VDMA_T::SASOCR: SASTOBL Mask              */
N
N#define VDMA_SASOCR_STBC_Pos             (16)                                              /*!< VDMA_T::SASOCR: STBC Position             */
N#define VDMA_SASOCR_STBC_Msk             (0xfffful << VDMA_SASOCR_STBC_Pos)                /*!< VDMA_T::SASOCR: STBC Mask                 */
N
N#define VDMA_DASOCR_DASTOBL_Pos          (0)                                               /*!< VDMA_T::DASOCR: DASTOBL Position          */
N#define VDMA_DASOCR_DASTOBL_Msk          (0xfffful << VDMA_DASOCR_DASTOBL_Pos)             /*!< VDMA_T::DASOCR: DASTOBL Mask              */
N
N/**@}*/ /* VDMA_CONST */
N
N/**@}*/ /* end of DMA register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * PRES
N     * ===================================================================================================
N     * Offset: 0x00  PWM Prescaler Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CP01      |Clock Prescaler 0 For PWM Timer 0 & 1
N     * |        |          |Clock input is divided by (CP01 + 1) before it is fed to the counter 0 & 1
N     * |        |          |If CP01 =0, the prescaler 0 output clock will be stopped. So PWM counter 0 and 1 will be stopped also.
N     * |[15:8]  |CP23      |Clock Prescaler 2 For PWM Timer 2 & 3
N     * |        |          |Clock input is divided by (CP23 + 1) before it is fed to the counter 2 & 3
N     * |        |          |If CP23=0, the prescaler 2 output clock will be stopped. So PWM counter2 and 3 will be stopped also.
N     * |[23:16] |DZ01      |Dead Zone Interval Register For CH0 And CH1 Pair
N     * |        |          |These 8 bits determine dead zone length.
N     * |        |          |The unit time of dead zone length is received from clock selector 0.
N     * |[31:24] |DZ23      |Dead Zone Interval Register For CH2 And CH3 Pair
N     * |        |          |These 8 bits determine dead zone length.
N     * |        |          |The unit time of dead zone length is received from clock selector 2.
N    */
N    __IO uint32_t PRES;
X    volatile uint32_t PRES;
N
N    /**
N     * CLKSEL
N     * ===================================================================================================
N     * Offset: 0x04  PWM Clock Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |CLKSEL0   |Timer 0 Clock Source Selection
N     * |        |          |Select clock input for timer 0.
N     * |        |          |(Table is the same as CLKSEL3)
N     * |[6:4]   |CLKSEL1   |Timer 1 Clock Source Selection
N     * |        |          |Select clock input for timer 1.
N     * |        |          |(Table is the same as CLKSEL3)
N     * |[10:8]  |CLKSEL2   |Timer 2Clock Source Selection
N     * |        |          |Select clock input for timer 2.
N     * |        |          |(Table is the same as CLKSEL3)
N     * |[14:12] |CLKSEL3   |Timer 3 Clock Source Selection
N     * |        |          |Select clock input for timer 3.
N     * |        |          |000 = Input Clock Divided by 2.
N     * |        |          |001 = Input Clock Divided by 4.
N     * |        |          |010 = Input Clock Divided by 8.
N     * |        |          |011 = Input Clock Divided by 16.
N     * |        |          |100 = Input Clock Divided by 1.
N    */
N    __IO uint32_t CLKSEL;
X    volatile uint32_t CLKSEL;
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x08  PWM Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CH0EN     |PWM-Timer 0 Enable/Disable Start Run
N     * |        |          |0 = PWM-Timer 0 Running Stopped.
N     * |        |          |1 = PWM-Timer 0 Start Run Enabled.
N     * |[2]     |CH0INV    |PWM-Timer 0 Output Inverter ON/OFF
N     * |        |          |0 = Inverter OFF.
N     * |        |          |1 = Inverter ON.
N     * |[3]     |CH0MOD    |PWM-Timer 0 Continuous/One-Shot Mode
N     * |        |          |0 = One-Shot Mode.
N     * |        |          |1 = Continuous Mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CN and CM of PWM0_DUTY0 to be cleared.
N     * |[4]     |DZEN01    |Dead-Zone 0 Generator Enable/Disable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair.
N     * |[5]     |DZEN23    |Dead-Zone 2 Generator Enable/Disable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair.
N     * |[8]     |CH1EN     |PWM-Timer 1 Enable/Disable Start Run
N     * |        |          |0 = PWM-Timer 1 Running Stopped.
N     * |        |          |1 = PWM-Timer 1 Start Run Enabled.
N     * |[10]    |CH1INV    |PWM-Timer 1 Output Inverter ON/OFF
N     * |        |          |0 = Inverter OFF.
N     * |        |          |1 = Inverter ON.
N     * |[11]    |CH1MOD    |PWM-Timer 1 Continuous/One-Shot Mode
N     * |        |          |0 = One-Shot Mode.
N     * |        |          |1 = Continuous Mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CN and CM of PWM0_DUTY1 to be cleared.
N     * |[16]    |CH2EN     |PWM-Timer 2 Enable/Disable Start Run
N     * |        |          |0 = PWM-Timer 2 Running Stopped.
N     * |        |          |1 = PWM-Timer 2 Start Run Enabled.
N     * |[18]    |CH2INV    |PWM-Timer 2 Output Inverter ON/OFF
N     * |        |          |0 = Inverter OFF.
N     * |        |          |1 = Inverter ON.
N     * |[19]    |CH2MOD    |PWM-Timer 2 Continuous/One-Shot Mode
N     * |        |          |0 = One-Shot Mode.
N     * |        |          |1 = Continuous Mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CN and CM of PWM0_DUTY2 be cleared.
N     * |[24]    |CH3EN     |PWM-Timer 3 Enable/Disable Start Run
N     * |        |          |0 = PWM-Timer 3 Running Stopped.
N     * |        |          |1 = PWM-Timer 3 Start Run Enabled.
N     * |[26]    |CH3INV    |PWM-Timer 3 Output Inverter ON/OFF
N     * |        |          |0 = Inverter OFF.
N     * |        |          |1 = Inverter ON.
N     * |[27]    |CH3MOD    |PWM-Timer 3 Continuous/One-Shot Mode
N     * |        |          |0 = One-Shot Mode.
N     * |        |          |1 = Continuous Mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CN and CM of PWM0_DUTY3 to be cleared.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x0C  PWM Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TMIE0     |PWM Timer 0 Interrupt Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[1]     |TMIE1     |PWM Timer 1 Interrupt Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[2]     |TMIE2     |PWM Timer 2 Interrupt Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[3]     |TMIE3     |PWM Timer 3 Interrupt Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N    */
N    __IO uint32_t INTEN;
X    volatile uint32_t INTEN;
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x10  PWM Interrupt Indication Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TMINT0    |PWM Timer 0 Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0 down counter reaches zero, software can clear this bit by writing a one to it.
N     * |[1]     |TMINT1    |PWM Timer 1 Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM1 down counter reaches zero, software can clear this bit by writing a one to it.
N     * |[2]     |TMINT2    |PWM Timer 2 Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM2 down counter reaches zero, software can clear this bit by writing a one to it.
N     * |[3]     |TMINT3    |PWM Timer 3 Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM3 down counter reaches zero, software can clear this bit by writing a one to it.
N     * |[4]     |Duty0Syncflag|Duty0 Synchronize Flag
N     * |        |          |0 = Duty0 has been synchronized to ECLK domain.
N     * |        |          |1 = Duty0 is synchronizing to ECLK domain.
N     * |        |          |Note: software should check this flag when writing duty0, if this flag is set, and user ignore this flag and change duty0, the corresponding CNR and CMR may be wrong for one duty cycle
N     * |[5]     |Duty1Syncflag|Duty1 Synchronize Flag
N     * |        |          |0 = Duty1 has been synchronized to ECLK domain.
N     * |        |          |1 = Duty1 is synchronizing to ECLK domain.
N     * |        |          |Note: software should check this flag when writing duty1, if this flag is set, and user ignore this flag and change duty1, the corresponding CNR and CMR may be wrong for one duty cycle
N     * |[6]     |Duty2Syncflag|Duty2 Synchronize Flag
N     * |        |          |0 = Duty2 has been synchronized to ECLK domain.
N     * |        |          |1 = Duty2 is synchronizing to ECLK domain.
N     * |        |          |Note: software should check this flag when writing duty2, if this flag is set, and user ignore this flag and change duty2, the corresponding CNR and CMR may be wrong for one duty cycle
N     * |[7]     |Duty3Syncflag|Duty3 Synchronize Flag
N     * |        |          |0 = Duty3 has been synchronized to ECLK domain.
N     * |        |          |1 = Duty3 is synchronizing to ECLK domain.
N     * |        |          |Note: software should check this flag when writing duty3, if this flag is set, and user ignore this flag and change duty3, the corresponding CNR and CMR may be wrong for one duty cycle
N     * |[8]     |PresSyncFlag|Prescale Synchronize Flag
N     * |        |          |0 = Prescale has been synchronized to ECLK domain.
N     * |        |          |1 = Prescale is synchronizing to ECLK domain.
N     * |        |          |Note: software should check this flag when writing Prescale, if this flag is set, and user ignore this flag and change Prescale, the Prescale may be wrong for one prescale cycle
N    */
N    __IO uint32_t INTSTS;
X    volatile uint32_t INTSTS;
N
N    /**
N     * OE
N     * ===================================================================================================
N     * Offset: 0x14  PWM Output Enable for PWM0~PWM3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CH0_OE    |PWM CH0 Output Enable Register
N     * |        |          |0 = PWM CH0 output to pin Disabled.
N     * |        |          |1 = PWM CH0 output to pin Enabled.
N     * |        |          |Note: The corresponding GPI/O pin also must be switched to PWM function (refer to GPx_MFP)
N     * |[1]     |CH1_OE    |PWM CH1 Output Enable Register
N     * |        |          |0 = PWM CH1 output to pin Disabled.
N     * |        |          |1 = PWM CH1 output to pin Enabled.
N     * |        |          |Note: The corresponding GPI/O pin also must be switched to PWM function (refer to GPx_MFP)
N     * |[2]     |CH2_OE    |PWM CH2 Output Enable Register
N     * |        |          |0 = PWM CH2 output to pin Disabled.
N     * |        |          |1 = PWM CH2 output to pin Enabled.
N     * |        |          |Note: The corresponding GPI/O pin also must be switched to PWM function (refer to GPx_MFP)
N     * |[3]     |CH3_OE    |PWM CH3 Output Enable Register
N     * |        |          |0 = PWM CH3 output to pin Disabled.
N     * |        |          |1 = PWM CH3 output to pin Enabled.
N     * |        |          |Note: The corresponding GPI/O pin also must be switched to PWM function (refer to GPx_MFP)
N    */
N    __IO uint32_t OE;
X    volatile uint32_t OE;
N    uint32_t RESERVE0[1];
N
N
N    /**
N     * DUTY0
N     * ===================================================================================================
N     * Offset: 0x1C  PWM Counter/Comparator Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CN        |PWM Counter/Timer Loaded Value
N     * |        |          |CN determines the PWM period.
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy, could be 01, 23, depends on selected PWM channel.
N     * |        |          |Duty ratio = (CM+1)/(CN+1).
N     * |        |          |CM >= CN: PWM output is always high.
N     * |        |          |CM < CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.
N     * |        |          |CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.
N     * |        |          |(Unit = one PWM clock cycle).
N     * |        |          |Note:
N     * |        |          |Any write to CN will take effect in next PWM cycle.
N     * |[31:16] |CM        |PWM Comparator Register
N     * |        |          |CM determines the PWM duty.
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy, could be 01, 23, depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CM+1)/(CN+1).
N     * |        |          |CM >= CN: PWM output is always high.
N     * |        |          |CM < CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.
N     * |        |          |CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.
N     * |        |          |(Unit = one PWM clock cycle).
N     * |        |          |Note:
N     * |        |          |Any write to CM will take effect in next PWM cycle.
N    */
N    __IO uint32_t DUTY0;
X    volatile uint32_t DUTY0;
N
N    /**
N     * DATA0
N     * ===================================================================================================
N     * Offset: 0x20  PWM Data Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PWMx_DATAy15_0|PWM Data Register
N     * |        |          |User can monitor PWMx_DATAy to know the current value in 16-bit down count counter.
N     * |[30:16] |PWMx_DATAy30_16|PWM Data Register
N     * |        |          |User can monitor PWMx_DATAy to know the current value in 32-bit down count counter
N     * |        |          |Notes:This will be valid only for the corresponding cascade enable .bit is set
N     * |[31]    |sync      |Indicate That CNR Value Is Sync To PWM Counter
N     * |        |          |0 = CNR value is sync to PWM counter.
N     * |        |          |1 = CNR value is not sync to PWM counter.
N     * |        |          |Note: when the corresponding cascade enable .bit is set is bit will not appear in the corresponding channel
N    */
N    __I  uint32_t DATA0;
X    volatile const  uint32_t DATA0;
N    uint32_t RESERVE1[1];
N
N
N    /**
N     * DUTY1
N     * ===================================================================================================
N     * Offset: 0x28  PWM Counter/Comparator Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CN        |PWM Counter/Timer Loaded Value
N     * |        |          |CN determines the PWM period.
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy, could be 01, 23, depends on selected PWM channel.
N     * |        |          |Duty ratio = (CM+1)/(CN+1).
N     * |        |          |CM >= CN: PWM output is always high.
N     * |        |          |CM < CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.
N     * |        |          |CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.
N     * |        |          |(Unit = one PWM clock cycle).
N     * |        |          |Note:
N     * |        |          |Any write to CN will take effect in next PWM cycle.
N     * |[31:16] |CM        |PWM Comparator Register
N     * |        |          |CM determines the PWM duty.
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy, could be 01, 23, depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CM+1)/(CN+1).
N     * |        |          |CM >= CN: PWM output is always high.
N     * |        |          |CM < CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.
N     * |        |          |CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.
N     * |        |          |(Unit = one PWM clock cycle).
N     * |        |          |Note:
N     * |        |          |Any write to CM will take effect in next PWM cycle.
N    */
N    __IO uint32_t DUTY1;
X    volatile uint32_t DUTY1;
N
N    /**
N     * DATA1
N     * ===================================================================================================
N     * Offset: 0x2C  PWM Data Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PWMx_DATAy15_0|PWM Data Register
N     * |        |          |User can monitor PWMx_DATAy to know the current value in 16-bit down count counter.
N     * |[30:16] |PWMx_DATAy30_16|PWM Data Register
N     * |        |          |User can monitor PWMx_DATAy to know the current value in 32-bit down count counter
N     * |        |          |Notes:This will be valid only for the corresponding cascade enable .bit is set
N     * |[31]    |sync      |Indicate That CNR Value Is Sync To PWM Counter
N     * |        |          |0 = CNR value is sync to PWM counter.
N     * |        |          |1 = CNR value is not sync to PWM counter.
N     * |        |          |Note: when the corresponding cascade enable .bit is set is bit will not appear in the corresponding channel
N    */
N    __I  uint32_t DATA1;
X    volatile const  uint32_t DATA1;
N    uint32_t RESERVE2[1];
N
N
N    /**
N     * DUTY2
N     * ===================================================================================================
N     * Offset: 0x34  PWM Counter/Comparator Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CN        |PWM Counter/Timer Loaded Value
N     * |        |          |CN determines the PWM period.
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy, could be 01, 23, depends on selected PWM channel.
N     * |        |          |Duty ratio = (CM+1)/(CN+1).
N     * |        |          |CM >= CN: PWM output is always high.
N     * |        |          |CM < CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.
N     * |        |          |CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.
N     * |        |          |(Unit = one PWM clock cycle).
N     * |        |          |Note:
N     * |        |          |Any write to CN will take effect in next PWM cycle.
N     * |[31:16] |CM        |PWM Comparator Register
N     * |        |          |CM determines the PWM duty.
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy, could be 01, 23, depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CM+1)/(CN+1).
N     * |        |          |CM >= CN: PWM output is always high.
N     * |        |          |CM < CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.
N     * |        |          |CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.
N     * |        |          |(Unit = one PWM clock cycle).
N     * |        |          |Note:
N     * |        |          |Any write to CM will take effect in next PWM cycle.
N    */
N    __IO uint32_t DUTY2;
X    volatile uint32_t DUTY2;
N
N    /**
N     * DATA2
N     * ===================================================================================================
N     * Offset: 0x38  PWM Data Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PWMx_DATAy15_0|PWM Data Register
N     * |        |          |User can monitor PWMx_DATAy to know the current value in 16-bit down count counter.
N     * |[30:16] |PWMx_DATAy30_16|PWM Data Register
N     * |        |          |User can monitor PWMx_DATAy to know the current value in 32-bit down count counter
N     * |        |          |Notes:This will be valid only for the corresponding cascade enable .bit is set
N     * |[31]    |sync      |Indicate That CNR Value Is Sync To PWM Counter
N     * |        |          |0 = CNR value is sync to PWM counter.
N     * |        |          |1 = CNR value is not sync to PWM counter.
N     * |        |          |Note: when the corresponding cascade enable .bit is set is bit will not appear in the corresponding channel
N    */
N    __I  uint32_t DATA2;
X    volatile const  uint32_t DATA2;
N    uint32_t RESERVE3[1];
N
N
N    /**
N     * DUTY3
N     * ===================================================================================================
N     * Offset: 0x40  PWM Counter/Comparator Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CN        |PWM Counter/Timer Loaded Value
N     * |        |          |CN determines the PWM period.
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy, could be 01, 23, depends on selected PWM channel.
N     * |        |          |Duty ratio = (CM+1)/(CN+1).
N     * |        |          |CM >= CN: PWM output is always high.
N     * |        |          |CM < CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.
N     * |        |          |CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.
N     * |        |          |(Unit = one PWM clock cycle).
N     * |        |          |Note: Any write to CN will take effect in next PWM cycle.
N     * |[31:16] |CM        |PWM Comparator Register
N     * |        |          |CM determines the PWM duty.
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)*(clock divider)/(CN+1); where xy, could be 01, 23, depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CM+1)/(CN+1).
N     * |        |          |CM >= CN: PWM output is always high.
N     * |        |          |CM < CN: PWM low width = (CN-CM) unit; PWM high width = (CM+1) unit.
N     * |        |          |CM = 0: PWM low width = (CN) unit; PWM high width = 1 unit.
N     * |        |          |(Unit = one PWM clock cycle).
N     * |        |          |Note: Any write to CM will take effect in next PWM cycle.
N    */
N    __IO uint32_t DUTY3;
X    volatile uint32_t DUTY3;
N
N    /**
N     * DATA3
N     * ===================================================================================================
N     * Offset: 0x44  PWM Data Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PWMx_DATAy15_0|PWM Data Register
N     * |        |          |User can monitor PWMx_DATAy to know the current value in 16-bit down count counter.
N     * |[30:16] |PWMx_DATAy30_16|PWM Data Register
N     * |        |          |User can monitor PWMx_DATAy to know the current value in 32-bit down count counter
N     * |        |          |Notes:This will be valid only for the corresponding cascade enable .bit is set
N     * |[31]    |sync      |Indicate That CNR Value Is Sync To PWM Counter
N     * |        |          |0 = CNR value is sync to PWM counter.
N     * |        |          |1 = CNR value is not sync to PWM counter.
N     * |        |          |Note: when the corresponding cascade enable .bit is set is bit will not appear in the corresponding channel
N    */
N    __I  uint32_t DATA3;
X    volatile const  uint32_t DATA3;
N    uint32_t RESERVE4[3];
N
N
N    /**
N     * CAPCTL
N     * ===================================================================================================
N     * Offset: 0x54  Capture Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INV0      |Channel 0 Inverter ON/OFF
N     * |        |          |0 = Inverter OFF.
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
N     * |[1]     |CAPCH0EN  |Capture Channel 0 Transition Enable/Disable
N     * |        |          |0 = Capture function on channel 0 Disabled.
N     * |        |          |1 = Capture function on channel 0 Enabled.
N     * |        |          |When Enabled, Capture latched the PWM-timer value and saved to PWM_CRL0 (Rising latch) and PWM_CFL0 (Falling latch).
N     * |        |          |When Disabled, Capture does not update PWM_CRL0 and PWM_CFL0, and disable Channel 0 Interrupt.
N     * |[2]     |CAPCH0PADEN|Capture Input Enable
N     * |        |          |0 = OFF.
N     * |        |          |1 = ON.
N     * |[3]     |CH0PDMAEN |Channel 0 PDMA Enable
N     * |        |          |0 = Channel 0 PDMA function Disabled.
N     * |        |          |1 = Channel 0 PDMA function Enabled for the channel 0 captured data and transfer to memory.
N     * |[5:4]   |PDMACAPMOD0|Select CRL0 Or CFL0 For PDMA Transfer
N     * |        |          |00 = Reserved.
N     * |        |          |01 = CRL0.
N     * |        |          |10 = CFL0.
N     * |        |          |11 = Both CRL0 and CFL0.
N     * |[6]     |CAPRELOADREN0|Reload CNR0 When CH0 Capture Rising Event Comes
N     * |        |          |0 = Rising capture reload for CH0 Disabled.
N     * |        |          |1 = Rising capture reload for CH0 Enabled.
N     * |[7]     |CAPRELOADFEN0|Reload CNR0 When CH0 Capture Falling Event Comes
N     * |        |          |0 = Falling capture reload for CH0 Disabled.
N     * |        |          |1 = Falling capture reload for CH0 Enabled.
N     * |[8]     |INV1      |Channel 1 Inverter ON/OFF
N     * |        |          |0 = Inverter OFF.
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
N     * |[9]     |CAPCH1EN  |Capture Channel 1 Transition Enable/Disable
N     * |        |          |0 = Capture function on channel 1 Disabled.
N     * |        |          |1 = Capture function on channel 1 Enabled.
N     * |        |          |When Enabled, Capture latched the PMW-counter and saved to PWM_CRL1 (Rising latch) and PWM_CFL1 (Falling latch).
N     * |        |          |When Disabled, Capture does not update PWM_CRL1 and PWM_CFL1, and disable Channel 1 Interrupt.
N     * |[10]    |CAPCH1PADEN|Capture Input Enable
N     * |        |          |0 = OFF.
N     * |        |          |1 = ON.
N     * |[12]    |CH0RFORDER|Channel 0 capture order control
N     * |        |          |Set this bit to determine whether the PWM_CRL0 or PWM_CFL0 is the first captured data transferred to memory through PDMA when PDMACAPMOD0 =2'b11.
N     * |        |          |0 = PWM_CFL0 is the first captured data to memory.
N     * |        |          |1 = PWM_CRL0 is the first captured data to memory.
N     * |[13]    |CH01CASK  |Cascade channel 0 and channel 1 PWM timer for capturing usage
N     * |[14]    |CAPRELOADREN1|Reload CNR1 When CH1 Capture Rising Event Comes
N     * |        |          |0 = Rising capture reload for CH1 Disabled.
N     * |        |          |1 = Rising capture reload for CH1 Enabled.
N     * |[15]    |CAPRELOADFEN1|Reload CNR1 When CH1 Capture Falling Event Coming
N     * |        |          |0 = Capture falling reload for CH1 Disabled.
N     * |        |          |1 = Capture falling reload for CH1 Enabled.
N     * |[16]    |INV2      |Channel 2 Inverter ON/OFF
N     * |        |          |0 = Inverter OFF.
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
N     * |[17]    |CAPCH2EN  |Capture Channel 2 Transition Enable/Disable
N     * |        |          |0 = Capture function on channel 2 Disabled.
N     * |        |          |1 = Capture function on channel 2 Enabled.
N     * |        |          |When Enabled, Capture latched the PWM-timer value and saved to PWM_CRL2 (Rising latch) and PWM_CFL2 (Falling latch).
N     * |        |          |When Disabled, Capture does not update PWM_CRL2 and PWM_CFL2, and disable Channel 2 Interrupt.
N     * |[18]    |CAPCH2PADEN|Capture Input Enable
N     * |        |          |0 = OFF.
N     * |        |          |1 = ON.
N     * |[19]    |CH2PDMAEN |Channel 2 PDMA Enable
N     * |        |          |0 = Channel 2 PDMA function Disabled.
N     * |        |          |1 = Channel 2 PDMA function Enabled for the channel 2 captured data and transfer to memory.
N     * |[21:20] |PDMACAPMOD2|Select CRL2 Or CFL2 For PDMA Transfer
N     * |        |          |00 = Reserved.
N     * |        |          |01 = CRL2.
N     * |        |          |10 = CFL2.
N     * |        |          |11 = Both CRL2 and CFL2.
N     * |[22]    |CAPRELOADREN2|Reload CNR2 When CH2 Capture Rising Event Coming
N     * |        |          |0 = Rising capture reload for CH2 Disabled.
N     * |        |          |1 = Rising capture reload for CH2 Enabled.
N     * |[23]    |CAPRELOADFEN2|Reload CNR2 When CH2 Capture Failing Event Coming
N     * |        |          |0 = Failing capture reload for CH2 Disabled.
N     * |        |          |1 = Failing capture reload for CH2 Enabled.
N     * |[24]    |INV3      |Channel 3 Inverter ON/OFF
N     * |        |          |0 = Inverter OFF.
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
N     * |[25]    |CAPCH3EN  |Capture Channel 3 Transition Enable/Disable
N     * |        |          |0 = Capture function on channel 3 Disabled.
N     * |        |          |1 = Capture function on channel 3 Enabled.
N     * |        |          |When Enabled, Capture latched the PMW-timer and saved to PWM_CRL3 (Rising latch) and PWM_CFL3 (Falling latch).
N     * |        |          |When Disabled, Capture does not update PWM_CRL3 and PWM_CFL3, and disable Channel 3 Interrupt.
N     * |[26]    |CAPCH3PADEN|Capture Input Enable
N     * |        |          |0 = OFF.
N     * |        |          |1 = ON.
N     * |[28]    |CH2RFORDER|Channel 0 capture order control
N     * |        |          |Set this bit to determine whether the PWM_CRL2 or PWM_CFL2 is the first captured data transferred to memory through PDMA when PDMACAPMOD2 = 2'b11.
N     * |        |          |0 = PWM_CFL2 is the first captured data to memory.
N     * |        |          |1 = PWM_CRL2 is the first captured data to memory.
N     * |[29]    |CH23CASK  |Cascade channel 2 and channel 3 PWM counter for capturing usage
N     * |[30]    |CAPRELOADREN3|Reload CNR3 When CH3 Rising Capture Event Comes
N     * |        |          |0 = Rising capture reload for CH3 Disabled.
N     * |        |          |1 = Rising capture reload for CH3 Enabled.
N     * |[31]    |CAPRELOADFEN3|Reload CNR3 When CH3 Falling Capture Event Comes
N     * |        |          |0 = Falling capture reload for CH3 Disabled.
N     * |        |          |1 = Falling capture reload for CH3 Enabled.
N    */
N    __IO uint32_t CAPCTL;
X    volatile uint32_t CAPCTL;
N
N    /**
N     * CAPINTEN
N     * ===================================================================================================
N     * Offset: 0x58  Capture interrupt enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CRL_IE0   |Channel 0 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |0 = Rising latch interrupt Disabled.
N     * |        |          |1 = Rising latch interrupt Enabled.
N     * |        |          |When Enabled, if Capture detects Channel 0 has rising transition, Capture issues an Interrupt.
N     * |[1]     |CFL_IE0   |Channel 0 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |0 = Falling latch interrupt Disabled.
N     * |        |          |1 = Falling latch interrupt Enabled.
N     * |        |          |When Enabled, if Capture detects Channel 0 has falling transition, Capture issues an Interrupt.
N     * |[8]     |CRL_IE1   |Channel 1 Rising Latch Interrupt Enable
N     * |        |          |0 = Rising latch interrupt Disabled.
N     * |        |          |1 = Rising latch interrupt Enabled.
N     * |        |          |When Enabled, if Capture detects Channel 1 has rising transition, Capture issues an Interrupt.
N     * |[9]     |CFL_IE1   |Channel 1 Falling Latch Interrupt Enable
N     * |        |          |0 = Falling latch interrupt Disabled.
N     * |        |          |1 = Falling latch interrupt Enabled.
N     * |        |          |When Enabled, if Capture detects Channel 1 has falling transition, Capture issues an Interrupt.
N     * |[16]    |CRL_IE2   |Channel 2 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |0 = Rising latch interrupt Disabled.
N     * |        |          |1 = Rising latch interrupt Enabled.
N     * |        |          |When Enabled, if Capture detects Channel 2 has rising transition, Capture issues an Interrupt.
N     * |[17]    |CFL_IE2   |Channel 2 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |0 = Falling latch interrupt Disabled.
N     * |        |          |1 = Falling latch interrupt Enabled.
N     * |        |          |When Enabled, if Capture detects Channel 2 has falling transition, Capture issues an Interrupt.
N     * |[24]    |CRL_IE3   |Channel 3 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |0 = Rising latch interrupt Disabled.
N     * |        |          |1 = Rising latch interrupt Enabled.
N     * |        |          |When Enabled, if Capture detects Channel 3 has rising transition, Capture issues an Interrupt.
N     * |[25]    |CFL_IE3   |Channel 3 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |0 = Falling latch interrupt Disabled.
N     * |        |          |1 = Falling latch interrupt Enabled.
N     * |        |          |When Enabled, if Capture detects Channel 3 has falling transition, Capture issues an Interrupt.
N    */
N    __IO uint32_t CAPINTEN;
X    volatile uint32_t CAPINTEN;
N
N    /**
N     * CAPINTSTS
N     * ===================================================================================================
N     * Offset: 0x5C  Capture Interrupt Indication Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CAPIF0    |Capture0 Interrupt Indication Flag
N     * |        |          |If channel 0 rising latch interrupt is enabled (CRL_IE0 =1), a rising transition occurs at input channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if channel 0 falling latch interrupt is enabled (CFL_IE0 =1).
N     * |        |          |This flag is cleared by software with a write 1 on it.
N     * |[1]     |CRLI0     |PWM_CRL0 Latched Indicator Bit
N     * |        |          |When input channel 0 has a rising transition, PWM0_CRL0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.
N     * |[2]     |CFLRI0    |PWM_CFL0 Latched Indicator Bit
N     * |        |          |When input channel 0 has a falling transition, PWM0_CFL0 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.
N     * |[3]     |CAPOVR0   |Capture Rising Flag Over Run For Channel 0
N     * |        |          |This flag indicate CRL0 update faster than software reading it when it is set
N     * |        |          |This bit will be cleared automatically when user clears CRLI0 bit 1 of PWM_CAPINTSTS.
N     * |[4]     |CAPOVF0   |Capture Falling Flag Over Run For Channel 0
N     * |        |          |This flag indicate CFL0 update faster than software read it when it is set
N     * |        |          |This bit will be cleared automatically when user clear CFLI0 bit 2 of PWM_CAPINTSTS
N     * |[8]     |CAPIF1    |Capture1 Interrupt Indication Flag
N     * |        |          |If channel 1 rising latch interrupt is enabled (CRL_IE1 =1), a rising transition occurs at input channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if channel 1 falling latch interrupt is enabled (CFL_IE1 =1).
N     * |        |          |This flag is cleared by software with a write 1 on it.
N     * |[9]     |CRLI1     |PWM_CRL1 Latched Indicator Bit
N     * |        |          |When input channel 1 has a rising transition, PWM_CRL1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.
N     * |[10]    |CFLI1     |PWM_CFL1 Latched Indicator Bit
N     * |        |          |When input channel 1 has a falling transition, PWM_CFL1 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.
N     * |[11]    |CAPOVR1   |Capture Rising Flag Over Run For Channel 1
N     * |        |          |This flag indicate CRL1 update faster than software reading it when it is set
N     * |        |          |This bit will be cleared automatically when user clear CRLI1 bit 9 of PWM_CAPINTSTS
N     * |[12]    |CAPOVF1   |Capture Falling Flag Over Run For Channel 1
N     * |        |          |This flag indicate CFL1 update faster than software reading it when it is set
N     * |        |          |This bit will be cleared automatically when user clear CFLI1 bit 10 of PWM_CAPINTSTS
N     * |[16]    |CAPIF2    |Capture2 Interrupt Indication Flag
N     * |        |          |If channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs at input channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause CAPIF2 to be set high if channel 2 falling latch interrupt is enabled (CFL_IE2=1).
N     * |        |          |This flag is cleared by software with a write 1 on it.
N     * |[17]    |CRLI2     |PWM_CRL2 Latched Indicator Bit
N     * |        |          |When input channel 2 has a rising transition, PWM0_CRL2 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.
N     * |[18]    |CFLI2     |PWM_CFL2 Latched Indicator Bit
N     * |        |          |When input channel 2 has a falling transition, PWM0_CFL2 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.
N     * |[19]    |CAPOVR2   |Capture Rising Flag Over Run For Channel 2
N     * |        |          |This flag indicate CRL2 update faster than software reading it when it is set
N     * |        |          |This bit will be cleared automatically when user clear CRLI2 bit 17 of PWM_CAPINTSTS
N     * |[20]    |CAPOVF2   |Capture Falling Flag Over Run For Channel 2
N     * |        |          |This flag indicate CFL2 update faster than software reading it when it is set
N     * |        |          |This bit will be cleared automatically when user clear CFLI2 bit 18 of PWM_CAPINTSTS
N     * |[24]    |CAPIF3    |Capture3 Interrupt Indication Flag
N     * |        |          |If channel 3 rising latch interrupt is enabled (CRL_IE3 =1), a rising transition occurs at input channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause CAPIF3 to be set high if channel 3 falling latch interrupt is enabled (CFL_IE3=1).
N     * |        |          |This flag is cleared by software with a write 1 on it.
N     * |[25]    |CRLI3     |PWM_CRL3 Latched Indicator Bit
N     * |        |          |When input channel 3 has a rising transition, PWM_CRL3 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.
N     * |[26]    |CFLI3     |PWM_CFL3 Latched Indicator Bit
N     * |        |          |When input channel 3 has a falling transition, PWM_CFL3 was latched with the value of PWM down-counter and this bit is set by hardware, software can clear this bit by writing 1 to it.
N     * |[27]    |CAPOVR3   |Capture Rising Flag Over Run For Channel 3
N     * |        |          |This flag indicate CRL3update faster than software reading it when it is set
N     * |        |          |This bit will be cleared automatically when user clear CRLI3 bit 25 of PWM_CAPINTSTS
N     * |[28]    |CAPOVF3   |Capture Falling Flag Over Run For Channel 3
N     * |        |          |This flag indicate CFL3 update faster than software reading it when it is set
N     * |        |          |This bit will be cleared automatically when user clear CFLI3 bit 26 of PWM_CAPINTSTS
N    */
N    __IO uint32_t CAPINTSTS;
X    volatile uint32_t CAPINTSTS;
N
N    /**
N     * CRL0
N     * ===================================================================================================
N     * Offset: 0x60  Capture Rising Latch Register (Channel 0)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRL15_0   |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     * |[31:16] |CRL31_16  |Upper Half Word Of 32-Bit Capture Data When Cascade Enabled
N     * |        |          |When cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit.
N    */
N    __I  uint32_t CRL0;
X    volatile const  uint32_t CRL0;
N
N    /**
N     * CFL0
N     * ===================================================================================================
N     * Offset: 0x64  Capture Falling Latch Register (Channel 0)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFL15_0   |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N     * |[31:16] |CFL31_16  |Upper Half Word Of 32-Bit Capture Data When Cascade Enabled
N     * |        |          |When cascade is enabled for capture channel 0, 2, the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit.
N    */
N    __I  uint32_t CFL0;
X    volatile const  uint32_t CFL0;
N
N    /**
N     * CRL1
N     * ===================================================================================================
N     * Offset: 0x68  Capture Rising Latch Register (Channel 1)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRL15_0   |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     * |[31:16] |CRL31_16  |Upper Half Word Of 32-Bit Capture Data When Cascade Enabled
N     * |        |          |When cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit.
N    */
N    __I  uint32_t CRL1;
X    volatile const  uint32_t CRL1;
N
N    /**
N     * CFL1
N     * ===================================================================================================
N     * Offset: 0x6C  Capture Falling Latch Register (Channel 1)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFL15_0   |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N     * |[31:16] |CFL31_16  |Upper Half Word Of 32-Bit Capture Data When Cascade Enabled
N     * |        |          |When cascade is enabled for capture channel 0, 2, the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit.
N    */
N    __I  uint32_t CFL1;
X    volatile const  uint32_t CFL1;
N
N    /**
N     * CRL2
N     * ===================================================================================================
N     * Offset: 0x70  Capture Rising Latch Register (Channel 2)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRL15_0   |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     * |[31:16] |CRL31_16  |Upper Half Word Of 32-Bit Capture Data When Cascade Enabled
N     * |        |          |When cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit.
N    */
N    __I  uint32_t CRL2;
X    volatile const  uint32_t CRL2;
N
N    /**
N     * CFL2
N     * ===================================================================================================
N     * Offset: 0x74  Capture Falling Latch Register (Channel 2)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFL15_0   |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N     * |[31:16] |CFL31_16  |Upper Half Word Of 32-Bit Capture Data When Cascade Enabled
N     * |        |          |When cascade is enabled for capture channel 0, 2, the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit.
N    */
N    __I  uint32_t CFL2;
X    volatile const  uint32_t CFL2;
N
N    /**
N     * CRL3
N     * ===================================================================================================
N     * Offset: 0x78  Capture Rising Latch Register (Channel 3)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRL15_0   |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     * |[31:16] |CRL31_16  |Upper Half Word Of 32-Bit Capture Data When Cascade Enabled
N     * |        |          |When cascade is enabled for capture channel 0, 2,the original 16 bit counter extend to 32 bit, and capture result CRL0 and CRL2 are also extend to 32 bit.
N    */
N    __I  uint32_t CRL3;
X    volatile const  uint32_t CRL3;
N
N    /**
N     * CFL3
N     * ===================================================================================================
N     * Offset: 0x7C  Capture Falling Latch Register (Channel 3)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFL15_0   |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N     * |[31:16] |CFL31_16  |Upper Half Word Of 32-Bit Capture Data When Cascade Enabled
N     * |        |          |When cascade is enabled for capture channel 0, 2, the original 16 bit counter extend to 32 bit, and capture result CFL0 and CFL2 are also extend to 32 bit.
N    */
N    __I  uint32_t CFL3;
X    volatile const  uint32_t CFL3;
N
N    /**
N     * PDMACH0
N     * ===================================================================================================
N     * Offset: 0x80  PDMA channel 0 captured data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |Captureddata7_0|PDMACH0
N     * |        |          |When CH01CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 0
N     * |        |          |When CH01CASK is enabled, It is the for the first byte of 32 bit capturing data for channel 0
N     * |[15:8]  |Captureddata15_8|PDMACH0
N     * |        |          |When CH01CASK is disabled, it is the capturing value(CFL0/CRL0) for channel 0
N     * |        |          |When CH01CASK is enabled, It is the second byte of 32 bit capturing data for channel 0
N     * |[23:16] |Captureddata23_16|PDMACH0
N     * |        |          |When CH01CASK is disabled, this byte is 0
N     * |        |          |When CH01CASK is enabled, It is the third byte of 32 bit capturing data for channel 0
N     * |[31:24] |Captureddata31_24|PDMACH0
N     * |        |          |When CH01CASK is disabled, this byte is 0
N     * |        |          |When CH01CASK is enabled, It is the 4th byte of 32 bit capturing data for channel 0
N    */
N    __I  uint32_t PDMACH0;
X    volatile const  uint32_t PDMACH0;
N
N    /**
N     * PDMACH2
N     * ===================================================================================================
N     * Offset: 0x84  PDMA channel 2 captured data
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |Captureddata7_0|PDMACH0
N     * |        |          |When CH23CASK is disabled, it is the capturing value(CFL2/CRL2) for channel 2
N     * |        |          |When CH23CASK is enabled, It is the for the first byte of 32 bit capturing data for channel 2
N     * |[15:8]  |Captureddata15_8|PDMACH0
N     * |        |          |When CH23CASK is disabled, it is the capturing value(CFL2/CRL2) for channel 2
N     * |        |          |When CH23CASK is enabled, It is the second byte of 32 bit capturing data for channel 2
N     * |[23:16] |Captureddata23_16|PDMACH0
N     * |        |          |When CH23CASK is disabled, this byte is 0
N     * |        |          |When CH23CASK is enabled, It is the third byte of 32 bit capturing data for channel 2
N     * |[31:24] |Captureddata31_24|PDMACH0
N     * |        |          |When CH23CASK is disabled, this byte is 0
N     * |        |          |When CH23CASK is enabled, It is the 4th byte of 32 bit capturing data for channel 2
N    */
N    __I  uint32_t PDMACH2;
X    volatile const  uint32_t PDMACH2;
N
N} PWM_T;
N
N/**
N    @addtogroup PWM_CONST PWM Bit Field Definition
N    Constant Definitions for PWM Controller
N@{ */
N
N#define PWM_PRES_CP01_Pos                (0)                                               /*!< PWM_T::PRES: CP01 Position                */
N#define PWM_PRES_CP01_Msk                (0xfful << PWM_PRES_CP01_Pos)                     /*!< PWM_T::PRES: CP01 Mask                    */
N
N#define PWM_PRES_CP23_Pos                (8)                                               /*!< PWM_T::PRES: CP23 Position                */
N#define PWM_PRES_CP23_Msk                (0xfful << PWM_PRES_CP23_Pos)                     /*!< PWM_T::PRES: CP23 Mask                    */
N
N#define PWM_PRES_DZ01_Pos                (16)                                              /*!< PWM_T::PRES: DZ01 Position                */
N#define PWM_PRES_DZ01_Msk                (0xfful << PWM_PRES_DZ01_Pos)                     /*!< PWM_T::PRES: DZ01 Mask                    */
N
N#define PWM_PRES_DZ23_Pos                (24)                                              /*!< PWM_T::PRES: DZ23 Position                */
N#define PWM_PRES_DZ23_Msk                (0xfful << PWM_PRES_DZ23_Pos)                     /*!< PWM_T::PRES: DZ23 Mask                    */
N
N#define PWM_CLKSEL_CLKSEL0_Pos           (0)                                               /*!< PWM_T::CLKSEL: CLKSEL0 Position           */
N#define PWM_CLKSEL_CLKSEL0_Msk           (0x7ul << PWM_CLKSEL_CLKSEL0_Pos)                 /*!< PWM_T::CLKSEL: CLKSEL0 Mask               */
N
N#define PWM_CLKSEL_CLKSEL1_Pos           (4)                                               /*!< PWM_T::CLKSEL: CLKSEL1 Position           */
N#define PWM_CLKSEL_CLKSEL1_Msk           (0x7ul << PWM_CLKSEL_CLKSEL1_Pos)                 /*!< PWM_T::CLKSEL: CLKSEL1 Mask               */
N
N#define PWM_CLKSEL_CLKSEL2_Pos           (8)                                               /*!< PWM_T::CLKSEL: CLKSEL2 Position           */
N#define PWM_CLKSEL_CLKSEL2_Msk           (0x7ul << PWM_CLKSEL_CLKSEL2_Pos)                 /*!< PWM_T::CLKSEL: CLKSEL2 Mask               */
N
N#define PWM_CLKSEL_CLKSEL3_Pos           (12)                                              /*!< PWM_T::CLKSEL: CLKSEL3 Position           */
N#define PWM_CLKSEL_CLKSEL3_Msk           (0x7ul << PWM_CLKSEL_CLKSEL3_Pos)                 /*!< PWM_T::CLKSEL: CLKSEL3 Mask               */
N
N#define PWM_CTL_CH0EN_Pos                (0)                                               /*!< PWM_T::CTL: CH0EN Position                */
N#define PWM_CTL_CH0EN_Msk                (0x1ul << PWM_CTL_CH0EN_Pos)                      /*!< PWM_T::CTL: CH0EN Mask                    */
N
N#define PWM_CTL_CH0INV_Pos               (2)                                               /*!< PWM_T::CTL: CH0INV Position               */
N#define PWM_CTL_CH0INV_Msk               (0x1ul << PWM_CTL_CH0INV_Pos)                     /*!< PWM_T::CTL: CH0INV Mask                   */
N
N#define PWM_CTL_CH0MOD_Pos               (3)                                               /*!< PWM_T::CTL: CH0MOD Position               */
N#define PWM_CTL_CH0MOD_Msk               (0x1ul << PWM_CTL_CH0MOD_Pos)                     /*!< PWM_T::CTL: CH0MOD Mask                   */
N
N#define PWM_CTL_DZEN01_Pos               (4)                                               /*!< PWM_T::CTL: DZEN01 Position               */
N#define PWM_CTL_DZEN01_Msk               (0x1ul << PWM_CTL_DZEN01_Pos)                     /*!< PWM_T::CTL: DZEN01 Mask                   */
N
N#define PWM_CTL_DZEN23_Pos               (5)                                               /*!< PWM_T::CTL: DZEN23 Position               */
N#define PWM_CTL_DZEN23_Msk               (0x1ul << PWM_CTL_DZEN23_Pos)                     /*!< PWM_T::CTL: DZEN23 Mask                   */
N
N#define PWM_CTL_CH1EN_Pos                (8)                                               /*!< PWM_T::CTL: CH1EN Position                */
N#define PWM_CTL_CH1EN_Msk                (0x1ul << PWM_CTL_CH1EN_Pos)                      /*!< PWM_T::CTL: CH1EN Mask                    */
N
N#define PWM_CTL_CH1INV_Pos               (10)                                              /*!< PWM_T::CTL: CH1INV Position               */
N#define PWM_CTL_CH1INV_Msk               (0x1ul << PWM_CTL_CH1INV_Pos)                     /*!< PWM_T::CTL: CH1INV Mask                   */
N
N#define PWM_CTL_CH1MOD_Pos               (11)                                              /*!< PWM_T::CTL: CH1MOD Position               */
N#define PWM_CTL_CH1MOD_Msk               (0x1ul << PWM_CTL_CH1MOD_Pos)                     /*!< PWM_T::CTL: CH1MOD Mask                   */
N
N#define PWM_CTL_CH2EN_Pos                (16)                                              /*!< PWM_T::CTL: CH2EN Position                */
N#define PWM_CTL_CH2EN_Msk                (0x1ul << PWM_CTL_CH2EN_Pos)                      /*!< PWM_T::CTL: CH2EN Mask                    */
N
N#define PWM_CTL_CH2INV_Pos               (18)                                              /*!< PWM_T::CTL: CH2INV Position               */
N#define PWM_CTL_CH2INV_Msk               (0x1ul << PWM_CTL_CH2INV_Pos)                     /*!< PWM_T::CTL: CH2INV Mask                   */
N
N#define PWM_CTL_CH2MOD_Pos               (19)                                              /*!< PWM_T::CTL: CH2MOD Position               */
N#define PWM_CTL_CH2MOD_Msk               (0x1ul << PWM_CTL_CH2MOD_Pos)                     /*!< PWM_T::CTL: CH2MOD Mask                   */
N
N#define PWM_CTL_CH3EN_Pos                (24)                                              /*!< PWM_T::CTL: CH3EN Position                */
N#define PWM_CTL_CH3EN_Msk                (0x1ul << PWM_CTL_CH3EN_Pos)                      /*!< PWM_T::CTL: CH3EN Mask                    */
N
N#define PWM_CTL_CH3INV_Pos               (26)                                              /*!< PWM_T::CTL: CH3INV Position               */
N#define PWM_CTL_CH3INV_Msk               (0x1ul << PWM_CTL_CH3INV_Pos)                     /*!< PWM_T::CTL: CH3INV Mask                   */
N
N#define PWM_CTL_CH3MOD_Pos               (27)                                              /*!< PWM_T::CTL: CH3MOD Position               */
N#define PWM_CTL_CH3MOD_Msk               (0x1ul << PWM_CTL_CH3MOD_Pos)                     /*!< PWM_T::CTL: CH3MOD Mask                   */
N
N#define PWM_INTEN_TMIE0_Pos              (0)                                               /*!< PWM_T::INTEN: TMIE0 Position              */
N#define PWM_INTEN_TMIE0_Msk              (0x1ul << PWM_INTEN_TMIE0_Pos)                    /*!< PWM_T::INTEN: TMIE0 Mask                  */
N
N#define PWM_INTEN_TMIE1_Pos              (1)                                               /*!< PWM_T::INTEN: TMIE1 Position              */
N#define PWM_INTEN_TMIE1_Msk              (0x1ul << PWM_INTEN_TMIE1_Pos)                    /*!< PWM_T::INTEN: TMIE1 Mask                  */
N
N#define PWM_INTEN_TMIE2_Pos              (2)                                               /*!< PWM_T::INTEN: TMIE2 Position              */
N#define PWM_INTEN_TMIE2_Msk              (0x1ul << PWM_INTEN_TMIE2_Pos)                    /*!< PWM_T::INTEN: TMIE2 Mask                  */
N
N#define PWM_INTEN_TMIE3_Pos              (3)                                               /*!< PWM_T::INTEN: TMIE3 Position              */
N#define PWM_INTEN_TMIE3_Msk              (0x1ul << PWM_INTEN_TMIE3_Pos)                    /*!< PWM_T::INTEN: TMIE3 Mask                  */
N
N#define PWM_INTSTS_TMINT0_Pos            (0)                                               /*!< PWM_T::INTSTS: TMINT0 Position            */
N#define PWM_INTSTS_TMINT0_Msk            (0x1ul << PWM_INTSTS_TMINT0_Pos)                  /*!< PWM_T::INTSTS: TMINT0 Mask                */
N
N#define PWM_INTSTS_TMINT1_Pos            (1)                                               /*!< PWM_T::INTSTS: TMINT1 Position            */
N#define PWM_INTSTS_TMINT1_Msk            (0x1ul << PWM_INTSTS_TMINT1_Pos)                  /*!< PWM_T::INTSTS: TMINT1 Mask                */
N
N#define PWM_INTSTS_TMINT2_Pos            (2)                                               /*!< PWM_T::INTSTS: TMINT2 Position            */
N#define PWM_INTSTS_TMINT2_Msk            (0x1ul << PWM_INTSTS_TMINT2_Pos)                  /*!< PWM_T::INTSTS: TMINT2 Mask                */
N
N#define PWM_INTSTS_TMINT3_Pos            (3)                                               /*!< PWM_T::INTSTS: TMINT3 Position            */
N#define PWM_INTSTS_TMINT3_Msk            (0x1ul << PWM_INTSTS_TMINT3_Pos)                  /*!< PWM_T::INTSTS: TMINT3 Mask                */
N
N#define PWM_INTSTS_DUTY0SYNC_Pos         (4)                                               /*!< PWM_T::INTSTS: DUTY0SYNC Position     */
N#define PWM_INTSTS_DUTY0SYNC_Msk         (0x1ul << PWM_INTSTS_DUTY0SYNC_Pos)               /*!< PWM_T::INTSTS: DUTY0SYNC Mask         */
N
N#define PWM_INTSTS_PRESSYNC_Pos          (8)                                               /*!< PWM_T::INTSTS: PRESSYNC Position      */
N#define PWM_INTSTS_PRESSYNC_Msk          (0x1ul << PWM_INTSTS_PRESSYNC_Pos)                /*!< PWM_T::INTSTS: PRESSYNC Mask          */
N
N#define PWM_OE_CH0_OE_Pos                (0)                                               /*!< PWM_T::OE: CH0_OE Position                */
N#define PWM_OE_CH0_OE_Msk                (0x1ul << PWM_OE_CH0_OE_Pos)                      /*!< PWM_T::OE: CH0_OE Mask                    */
N
N#define PWM_OE_CH1_OE_Pos                (1)                                               /*!< PWM_T::OE: CH1_OE Position                */
N#define PWM_OE_CH1_OE_Msk                (0x1ul << PWM_OE_CH1_OE_Pos)                      /*!< PWM_T::OE: CH1_OE Mask                    */
N
N#define PWM_OE_CH2_OE_Pos                (2)                                               /*!< PWM_T::OE: CH2_OE Position                */
N#define PWM_OE_CH2_OE_Msk                (0x1ul << PWM_OE_CH2_OE_Pos)                      /*!< PWM_T::OE: CH2_OE Mask                    */
N
N#define PWM_OE_CH3_OE_Pos                (3)                                               /*!< PWM_T::OE: CH3_OE Position                */
N#define PWM_OE_CH3_OE_Msk                (0x1ul << PWM_OE_CH3_OE_Pos)                      /*!< PWM_T::OE: CH3_OE Mask                    */
N
N#define PWM_DUTY_CN_Pos                 (0)                                               /*!< PWM_T::DUTY0: CN Position                 */
N#define PWM_DUTY_CN_Msk                 (0xfffful << PWM_DUTY_CN_Pos)                    /*!< PWM_T::DUTY0: CN Mask                     */
N
N#define PWM_DUTY_CM_Pos                 (16)                                              /*!< PWM_T::DUTY0: CM Position                 */
N#define PWM_DUTY_CM_Msk                 (0xfffful << PWM_DUTY_CM_Pos)                    /*!< PWM_T::DUTY0: CM Mask                     */
N
N#define PWM_DATA0_PWMx_DATAy15_0_Pos     (0)                                               /*!< PWM_T::DATA0: PWMx_DATAy15_0 Position     */
N#define PWM_DATA0_PWMx_DATAy15_0_Msk     (0xfffful << PWM_DATA0_PWMx_DATAy15_0_Pos)        /*!< PWM_T::DATA0: PWMx_DATAy15_0 Mask         */
N
N#define PWM_DATA0_PWMx_DATAy30_16_Pos    (16)                                              /*!< PWM_T::DATA0: PWMx_DATAy30_16 Position    */
N#define PWM_DATA0_PWMx_DATAy30_16_Msk    (0x7ffful << PWM_DATA0_PWMx_DATAy30_16_Pos)       /*!< PWM_T::DATA0: PWMx_DATAy30_16 Mask        */
N
N#define PWM_DATA0_sync_Pos               (31)                                              /*!< PWM_T::DATA0: sync Position               */
N#define PWM_DATA0_sync_Msk               (0x1ul << PWM_DATA0_sync_Pos)                     /*!< PWM_T::DATA0: sync Mask                   */
N
N#define PWM_DUTY1_CN_Pos                 (0)                                               /*!< PWM_T::DUTY1: CN Position                 */
N#define PWM_DUTY1_CN_Msk                 (0xfffful << PWM_DUTY1_CN_Pos)                    /*!< PWM_T::DUTY1: CN Mask                     */
N
N#define PWM_DUTY1_CM_Pos                 (16)                                              /*!< PWM_T::DUTY1: CM Position                 */
N#define PWM_DUTY1_CM_Msk                 (0xfffful << PWM_DUTY1_CM_Pos)                    /*!< PWM_T::DUTY1: CM Mask                     */
N
N#define PWM_DATA1_PWMx_DATAy15_0_Pos     (0)                                               /*!< PWM_T::DATA1: PWMx_DATAy15_0 Position     */
N#define PWM_DATA1_PWMx_DATAy15_0_Msk     (0xfffful << PWM_DATA1_PWMx_DATAy15_0_Pos)        /*!< PWM_T::DATA1: PWMx_DATAy15_0 Mask         */
N
N#define PWM_DATA1_PWMx_DATAy30_16_Pos    (16)                                              /*!< PWM_T::DATA1: PWMx_DATAy30_16 Position    */
N#define PWM_DATA1_PWMx_DATAy30_16_Msk    (0x7ffful << PWM_DATA1_PWMx_DATAy30_16_Pos)       /*!< PWM_T::DATA1: PWMx_DATAy30_16 Mask        */
N
N#define PWM_DATA1_sync_Pos               (31)                                              /*!< PWM_T::DATA1: sync Position               */
N#define PWM_DATA1_sync_Msk               (0x1ul << PWM_DATA1_sync_Pos)                     /*!< PWM_T::DATA1: sync Mask                   */
N
N#define PWM_DUTY2_CN_Pos                 (0)                                               /*!< PWM_T::DUTY2: CN Position                 */
N#define PWM_DUTY2_CN_Msk                 (0xfffful << PWM_DUTY2_CN_Pos)                    /*!< PWM_T::DUTY2: CN Mask                     */
N
N#define PWM_DUTY2_CM_Pos                 (16)                                              /*!< PWM_T::DUTY2: CM Position                 */
N#define PWM_DUTY2_CM_Msk                 (0xfffful << PWM_DUTY2_CM_Pos)                    /*!< PWM_T::DUTY2: CM Mask                     */
N
N#define PWM_DATA2_PWMx_DATAy15_0_Pos     (0)                                               /*!< PWM_T::DATA2: PWMx_DATAy15_0 Position     */
N#define PWM_DATA2_PWMx_DATAy15_0_Msk     (0xfffful << PWM_DATA2_PWMx_DATAy15_0_Pos)        /*!< PWM_T::DATA2: PWMx_DATAy15_0 Mask         */
N
N#define PWM_DATA2_PWMx_DATAy30_16_Pos    (16)                                              /*!< PWM_T::DATA2: PWMx_DATAy30_16 Position    */
N#define PWM_DATA2_PWMx_DATAy30_16_Msk    (0x7ffful << PWM_DATA2_PWMx_DATAy30_16_Pos)       /*!< PWM_T::DATA2: PWMx_DATAy30_16 Mask        */
N
N#define PWM_DATA2_sync_Pos               (31)                                              /*!< PWM_T::DATA2: sync Position               */
N#define PWM_DATA2_sync_Msk               (0x1ul << PWM_DATA2_sync_Pos)                     /*!< PWM_T::DATA2: sync Mask                   */
N
N#define PWM_DUTY3_CN_Pos                 (0)                                               /*!< PWM_T::DUTY3: CN Position                 */
N#define PWM_DUTY3_CN_Msk                 (0xfffful << PWM_DUTY3_CN_Pos)                    /*!< PWM_T::DUTY3: CN Mask                     */
N
N#define PWM_DUTY3_CM_Pos                 (16)                                              /*!< PWM_T::DUTY3: CM Position                 */
N#define PWM_DUTY3_CM_Msk                 (0xfffful << PWM_DUTY3_CM_Pos)                    /*!< PWM_T::DUTY3: CM Mask                     */
N
N#define PWM_DATA3_PWMx_DATAy15_0_Pos     (0)                                               /*!< PWM_T::DATA3: PWMx_DATAy15_0 Position     */
N#define PWM_DATA3_PWMx_DATAy15_0_Msk     (0xfffful << PWM_DATA3_PWMx_DATAy15_0_Pos)        /*!< PWM_T::DATA3: PWMx_DATAy15_0 Mask         */
N
N#define PWM_DATA3_PWMx_DATAy30_16_Pos    (16)                                              /*!< PWM_T::DATA3: PWMx_DATAy30_16 Position    */
N#define PWM_DATA3_PWMx_DATAy30_16_Msk    (0x7ffful << PWM_DATA3_PWMx_DATAy30_16_Pos)       /*!< PWM_T::DATA3: PWMx_DATAy30_16 Mask        */
N
N#define PWM_DATA3_sync_Pos               (31)                                              /*!< PWM_T::DATA3: sync Position               */
N#define PWM_DATA3_sync_Msk               (0x1ul << PWM_DATA3_sync_Pos)                     /*!< PWM_T::DATA3: sync Mask                   */
N
N#define PWM_CAPCTL_INV0_Pos              (0)                                               /*!< PWM_T::CAPCTL: INV0 Position              */
N#define PWM_CAPCTL_INV0_Msk              (0x1ul << PWM_CAPCTL_INV0_Pos)                    /*!< PWM_T::CAPCTL: INV0 Mask                  */
N
N#define PWM_CAPCTL_CAPCH0EN_Pos          (1)                                               /*!< PWM_T::CAPCTL: CAPCH0EN Position          */
N#define PWM_CAPCTL_CAPCH0EN_Msk          (0x1ul << PWM_CAPCTL_CAPCH0EN_Pos)                /*!< PWM_T::CAPCTL: CAPCH0EN Mask              */
N
N#define PWM_CAPCTL_CAPCH0PADEN_Pos       (2)                                               /*!< PWM_T::CAPCTL: CAPCH0PADEN Position       */
N#define PWM_CAPCTL_CAPCH0PADEN_Msk       (0x1ul << PWM_CAPCTL_CAPCH0PADEN_Pos)             /*!< PWM_T::CAPCTL: CAPCH0PADEN Mask           */
N
N#define PWM_CAPCTL_CH0PDMAEN_Pos         (3)                                               /*!< PWM_T::CAPCTL: CH0PDMAEN Position         */
N#define PWM_CAPCTL_CH0PDMAEN_Msk         (0x1ul << PWM_CAPCTL_CH0PDMAEN_Pos)               /*!< PWM_T::CAPCTL: CH0PDMAEN Mask             */
N
N#define PWM_CAPCTL_PDMACAPMOD0_Pos       (4)                                               /*!< PWM_T::CAPCTL: PDMACAPMOD0 Position       */
N#define PWM_CAPCTL_PDMACAPMOD0_Msk       (0x3ul << PWM_CAPCTL_PDMACAPMOD0_Pos)             /*!< PWM_T::CAPCTL: PDMACAPMOD0 Mask           */
N
N#define PWM_CAPCTL_CAPRELOADREN0_Pos     (6)                                               /*!< PWM_T::CAPCTL: CAPRELOADREN0 Position     */
N#define PWM_CAPCTL_CAPRELOADREN0_Msk     (0x1ul << PWM_CAPCTL_CAPRELOADREN0_Pos)           /*!< PWM_T::CAPCTL: CAPRELOADREN0 Mask         */
N
N#define PWM_CAPCTL_CAPRELOADFEN0_Pos     (7)                                               /*!< PWM_T::CAPCTL: CAPRELOADFEN0 Position     */
N#define PWM_CAPCTL_CAPRELOADFEN0_Msk     (0x1ul << PWM_CAPCTL_CAPRELOADFEN0_Pos)           /*!< PWM_T::CAPCTL: CAPRELOADFEN0 Mask         */
N
N#define PWM_CAPCTL_INV1_Pos              (8)                                               /*!< PWM_T::CAPCTL: INV1 Position              */
N#define PWM_CAPCTL_INV1_Msk              (0x1ul << PWM_CAPCTL_INV1_Pos)                    /*!< PWM_T::CAPCTL: INV1 Mask                  */
N
N#define PWM_CAPCTL_CAPCH1EN_Pos          (9)                                               /*!< PWM_T::CAPCTL: CAPCH1EN Position          */
N#define PWM_CAPCTL_CAPCH1EN_Msk          (0x1ul << PWM_CAPCTL_CAPCH1EN_Pos)                /*!< PWM_T::CAPCTL: CAPCH1EN Mask              */
N
N#define PWM_CAPCTL_CAPCH1PADEN_Pos       (10)                                              /*!< PWM_T::CAPCTL: CAPCH1PADEN Position       */
N#define PWM_CAPCTL_CAPCH1PADEN_Msk       (0x1ul << PWM_CAPCTL_CAPCH1PADEN_Pos)             /*!< PWM_T::CAPCTL: CAPCH1PADEN Mask           */
N
N#define PWM_CAPCTL_CH0RFORDER_Pos        (12)                                              /*!< PWM_T::CAPCTL: CH0RFORDER Position        */
N#define PWM_CAPCTL_CH0RFORDER_Msk        (0x1ul << PWM_CAPCTL_CH0RFORDER_Pos)              /*!< PWM_T::CAPCTL: CH0RFORDER Mask            */
N
N#define PWM_CAPCTL_CH01CASK_Pos          (13)                                              /*!< PWM_T::CAPCTL: CH01CASK Position          */
N#define PWM_CAPCTL_CH01CASK_Msk          (0x1ul << PWM_CAPCTL_CH01CASK_Pos)                /*!< PWM_T::CAPCTL: CH01CASK Mask              */
N
N#define PWM_CAPCTL_CAPRELOADREN1_Pos     (14)                                              /*!< PWM_T::CAPCTL: CAPRELOADREN1 Position     */
N#define PWM_CAPCTL_CAPRELOADREN1_Msk     (0x1ul << PWM_CAPCTL_CAPRELOADREN1_Pos)           /*!< PWM_T::CAPCTL: CAPRELOADREN1 Mask         */
N
N#define PWM_CAPCTL_CAPRELOADFEN1_Pos     (15)                                              /*!< PWM_T::CAPCTL: CAPRELOADFEN1 Position     */
N#define PWM_CAPCTL_CAPRELOADFEN1_Msk     (0x1ul << PWM_CAPCTL_CAPRELOADFEN1_Pos)           /*!< PWM_T::CAPCTL: CAPRELOADFEN1 Mask         */
N
N#define PWM_CAPCTL_INV2_Pos              (16)                                              /*!< PWM_T::CAPCTL: INV2 Position              */
N#define PWM_CAPCTL_INV2_Msk              (0x1ul << PWM_CAPCTL_INV2_Pos)                    /*!< PWM_T::CAPCTL: INV2 Mask                  */
N
N#define PWM_CAPCTL_CAPCH2EN_Pos          (17)                                              /*!< PWM_T::CAPCTL: CAPCH2EN Position          */
N#define PWM_CAPCTL_CAPCH2EN_Msk          (0x1ul << PWM_CAPCTL_CAPCH2EN_Pos)                /*!< PWM_T::CAPCTL: CAPCH2EN Mask              */
N
N#define PWM_CAPCTL_CAPCH2PADEN_Pos       (18)                                              /*!< PWM_T::CAPCTL: CAPCH2PADEN Position       */
N#define PWM_CAPCTL_CAPCH2PADEN_Msk       (0x1ul << PWM_CAPCTL_CAPCH2PADEN_Pos)             /*!< PWM_T::CAPCTL: CAPCH2PADEN Mask           */
N
N#define PWM_CAPCTL_CH2PDMAEN_Pos         (19)                                              /*!< PWM_T::CAPCTL: CH2PDMAEN Position         */
N#define PWM_CAPCTL_CH2PDMAEN_Msk         (0x1ul << PWM_CAPCTL_CH2PDMAEN_Pos)               /*!< PWM_T::CAPCTL: CH2PDMAEN Mask             */
N
N#define PWM_CAPCTL_PDMACAPMOD2_Pos       (20)                                              /*!< PWM_T::CAPCTL: PDMACAPMOD2 Position       */
N#define PWM_CAPCTL_PDMACAPMOD2_Msk       (0x3ul << PWM_CAPCTL_PDMACAPMOD2_Pos)             /*!< PWM_T::CAPCTL: PDMACAPMOD2 Mask           */
N
N#define PWM_CAPCTL_CAPRELOADREN2_Pos     (22)                                              /*!< PWM_T::CAPCTL: CAPRELOADREN2 Position     */
N#define PWM_CAPCTL_CAPRELOADREN2_Msk     (0x1ul << PWM_CAPCTL_CAPRELOADREN2_Pos)           /*!< PWM_T::CAPCTL: CAPRELOADREN2 Mask         */
N
N#define PWM_CAPCTL_CAPRELOADFEN2_Pos     (23)                                              /*!< PWM_T::CAPCTL: CAPRELOADFEN2 Position     */
N#define PWM_CAPCTL_CAPRELOADFEN2_Msk     (0x1ul << PWM_CAPCTL_CAPRELOADFEN2_Pos)           /*!< PWM_T::CAPCTL: CAPRELOADFEN2 Mask         */
N
N#define PWM_CAPCTL_INV3_Pos              (24)                                              /*!< PWM_T::CAPCTL: INV3 Position              */
N#define PWM_CAPCTL_INV3_Msk              (0x1ul << PWM_CAPCTL_INV3_Pos)                    /*!< PWM_T::CAPCTL: INV3 Mask                  */
N
N#define PWM_CAPCTL_CAPCH3EN_Pos          (25)                                              /*!< PWM_T::CAPCTL: CAPCH3EN Position          */
N#define PWM_CAPCTL_CAPCH3EN_Msk          (0x1ul << PWM_CAPCTL_CAPCH3EN_Pos)                /*!< PWM_T::CAPCTL: CAPCH3EN Mask              */
N
N#define PWM_CAPCTL_CAPCH3PADEN_Pos       (26)                                              /*!< PWM_T::CAPCTL: CAPCH3PADEN Position       */
N#define PWM_CAPCTL_CAPCH3PADEN_Msk       (0x1ul << PWM_CAPCTL_CAPCH3PADEN_Pos)             /*!< PWM_T::CAPCTL: CAPCH3PADEN Mask           */
N
N#define PWM_CAPCTL_CH2RFORDER_Pos        (28)                                              /*!< PWM_T::CAPCTL: CH2RFORDER Position        */
N#define PWM_CAPCTL_CH2RFORDER_Msk        (0x1ul << PWM_CAPCTL_CH2RFORDER_Pos)              /*!< PWM_T::CAPCTL: CH2RFORDER Mask            */
N
N#define PWM_CAPCTL_CH23CASK_Pos          (29)                                              /*!< PWM_T::CAPCTL: CH23CASK Position          */
N#define PWM_CAPCTL_CH23CASK_Msk          (0x1ul << PWM_CAPCTL_CH23CASK_Pos)                /*!< PWM_T::CAPCTL: CH23CASK Mask              */
N
N#define PWM_CAPCTL_CAPRELOADREN3_Pos     (30)                                              /*!< PWM_T::CAPCTL: CAPRELOADREN3 Position     */
N#define PWM_CAPCTL_CAPRELOADREN3_Msk     (0x1ul << PWM_CAPCTL_CAPRELOADREN3_Pos)           /*!< PWM_T::CAPCTL: CAPRELOADREN3 Mask         */
N
N#define PWM_CAPCTL_CAPRELOADFEN3_Pos     (31)                                              /*!< PWM_T::CAPCTL: CAPRELOADFEN3 Position     */
N#define PWM_CAPCTL_CAPRELOADFEN3_Msk     (0x1ul << PWM_CAPCTL_CAPRELOADFEN3_Pos)           /*!< PWM_T::CAPCTL: CAPRELOADFEN3 Mask         */
N
N#define PWM_CAPINTEN_CRL_IE0_Pos         (0)                                               /*!< PWM_T::CAPINTEN: CRL_IE0 Position         */
N#define PWM_CAPINTEN_CRL_IE0_Msk         (0x1ul << PWM_CAPINTEN_CRL_IE0_Pos)               /*!< PWM_T::CAPINTEN: CRL_IE0 Mask             */
N
N#define PWM_CAPINTEN_CFL_IE0_Pos         (1)                                               /*!< PWM_T::CAPINTEN: CFL_IE0 Position         */
N#define PWM_CAPINTEN_CFL_IE0_Msk         (0x1ul << PWM_CAPINTEN_CFL_IE0_Pos)               /*!< PWM_T::CAPINTEN: CFL_IE0 Mask             */
N
N#define PWM_CAPINTEN_CRL_IE1_Pos         (8)                                               /*!< PWM_T::CAPINTEN: CRL_IE1 Position         */
N#define PWM_CAPINTEN_CRL_IE1_Msk         (0x1ul << PWM_CAPINTEN_CRL_IE1_Pos)               /*!< PWM_T::CAPINTEN: CRL_IE1 Mask             */
N
N#define PWM_CAPINTEN_CFL_IE1_Pos         (9)                                               /*!< PWM_T::CAPINTEN: CFL_IE1 Position         */
N#define PWM_CAPINTEN_CFL_IE1_Msk         (0x1ul << PWM_CAPINTEN_CFL_IE1_Pos)               /*!< PWM_T::CAPINTEN: CFL_IE1 Mask             */
N
N#define PWM_CAPINTEN_CRL_IE2_Pos         (16)                                              /*!< PWM_T::CAPINTEN: CRL_IE2 Position         */
N#define PWM_CAPINTEN_CRL_IE2_Msk         (0x1ul << PWM_CAPINTEN_CRL_IE2_Pos)               /*!< PWM_T::CAPINTEN: CRL_IE2 Mask             */
N
N#define PWM_CAPINTEN_CFL_IE2_Pos         (17)                                              /*!< PWM_T::CAPINTEN: CFL_IE2 Position         */
N#define PWM_CAPINTEN_CFL_IE2_Msk         (0x1ul << PWM_CAPINTEN_CFL_IE2_Pos)               /*!< PWM_T::CAPINTEN: CFL_IE2 Mask             */
N
N#define PWM_CAPINTEN_CRL_IE3_Pos         (24)                                              /*!< PWM_T::CAPINTEN: CRL_IE3 Position         */
N#define PWM_CAPINTEN_CRL_IE3_Msk         (0x1ul << PWM_CAPINTEN_CRL_IE3_Pos)               /*!< PWM_T::CAPINTEN: CRL_IE3 Mask             */
N
N#define PWM_CAPINTEN_CFL_IE3_Pos         (25)                                              /*!< PWM_T::CAPINTEN: CFL_IE3 Position         */
N#define PWM_CAPINTEN_CFL_IE3_Msk         (0x1ul << PWM_CAPINTEN_CFL_IE3_Pos)               /*!< PWM_T::CAPINTEN: CFL_IE3 Mask             */
N
N#define PWM_CAPINTSTS_CAPIF0_Pos         (0)                                               /*!< PWM_T::CAPINTSTS: CAPIF0 Position         */
N#define PWM_CAPINTSTS_CAPIF0_Msk         (0x1ul << PWM_CAPINTSTS_CAPIF0_Pos)               /*!< PWM_T::CAPINTSTS: CAPIF0 Mask             */
N
N#define PWM_CAPINTSTS_CRLI0_Pos          (1)                                               /*!< PWM_T::CAPINTSTS: CRLI0 Position          */
N#define PWM_CAPINTSTS_CRLI0_Msk          (0x1ul << PWM_CAPINTSTS_CRLI0_Pos)                /*!< PWM_T::CAPINTSTS: CRLI0 Mask              */
N
N#define PWM_CAPINTSTS_CFLRI0_Pos         (2)                                               /*!< PWM_T::CAPINTSTS: CFLRI0 Position         */
N#define PWM_CAPINTSTS_CFLRI0_Msk         (0x1ul << PWM_CAPINTSTS_CFLRI0_Pos)               /*!< PWM_T::CAPINTSTS: CFLRI0 Mask             */
N
N#define PWM_CAPINTSTS_CAPOVR0_Pos        (3)                                               /*!< PWM_T::CAPINTSTS: CAPOVR0 Position        */
N#define PWM_CAPINTSTS_CAPOVR0_Msk        (0x1ul << PWM_CAPINTSTS_CAPOVR0_Pos)              /*!< PWM_T::CAPINTSTS: CAPOVR0 Mask            */
N
N#define PWM_CAPINTSTS_CAPOVF0_Pos        (4)                                               /*!< PWM_T::CAPINTSTS: CAPOVF0 Position        */
N#define PWM_CAPINTSTS_CAPOVF0_Msk        (0x1ul << PWM_CAPINTSTS_CAPOVF0_Pos)              /*!< PWM_T::CAPINTSTS: CAPOVF0 Mask            */
N
N#define PWM_CAPINTSTS_CAPIF1_Pos         (8)                                               /*!< PWM_T::CAPINTSTS: CAPIF1 Position         */
N#define PWM_CAPINTSTS_CAPIF1_Msk         (0x1ul << PWM_CAPINTSTS_CAPIF1_Pos)               /*!< PWM_T::CAPINTSTS: CAPIF1 Mask             */
N
N#define PWM_CAPINTSTS_CRLI1_Pos          (9)                                               /*!< PWM_T::CAPINTSTS: CRLI1 Position          */
N#define PWM_CAPINTSTS_CRLI1_Msk          (0x1ul << PWM_CAPINTSTS_CRLI1_Pos)                /*!< PWM_T::CAPINTSTS: CRLI1 Mask              */
N
N#define PWM_CAPINTSTS_CFLI1_Pos          (10)                                              /*!< PWM_T::CAPINTSTS: CFLI1 Position          */
N#define PWM_CAPINTSTS_CFLI1_Msk          (0x1ul << PWM_CAPINTSTS_CFLI1_Pos)                /*!< PWM_T::CAPINTSTS: CFLI1 Mask              */
N
N#define PWM_CAPINTSTS_CAPOVR1_Pos        (11)                                              /*!< PWM_T::CAPINTSTS: CAPOVR1 Position        */
N#define PWM_CAPINTSTS_CAPOVR1_Msk        (0x1ul << PWM_CAPINTSTS_CAPOVR1_Pos)              /*!< PWM_T::CAPINTSTS: CAPOVR1 Mask            */
N
N#define PWM_CAPINTSTS_CAPOVF1_Pos        (12)                                              /*!< PWM_T::CAPINTSTS: CAPOVF1 Position        */
N#define PWM_CAPINTSTS_CAPOVF1_Msk        (0x1ul << PWM_CAPINTSTS_CAPOVF1_Pos)              /*!< PWM_T::CAPINTSTS: CAPOVF1 Mask            */
N
N#define PWM_CAPINTSTS_CAPIF2_Pos         (16)                                              /*!< PWM_T::CAPINTSTS: CAPIF2 Position         */
N#define PWM_CAPINTSTS_CAPIF2_Msk         (0x1ul << PWM_CAPINTSTS_CAPIF2_Pos)               /*!< PWM_T::CAPINTSTS: CAPIF2 Mask             */
N
N#define PWM_CAPINTSTS_CRLI2_Pos          (17)                                              /*!< PWM_T::CAPINTSTS: CRLI2 Position          */
N#define PWM_CAPINTSTS_CRLI2_Msk          (0x1ul << PWM_CAPINTSTS_CRLI2_Pos)                /*!< PWM_T::CAPINTSTS: CRLI2 Mask              */
N
N#define PWM_CAPINTSTS_CFLI2_Pos          (18)                                              /*!< PWM_T::CAPINTSTS: CFLI2 Position          */
N#define PWM_CAPINTSTS_CFLI2_Msk          (0x1ul << PWM_CAPINTSTS_CFLI2_Pos)                /*!< PWM_T::CAPINTSTS: CFLI2 Mask              */
N
N#define PWM_CAPINTSTS_CAPOVR2_Pos        (19)                                              /*!< PWM_T::CAPINTSTS: CAPOVR2 Position        */
N#define PWM_CAPINTSTS_CAPOVR2_Msk        (0x1ul << PWM_CAPINTSTS_CAPOVR2_Pos)              /*!< PWM_T::CAPINTSTS: CAPOVR2 Mask            */
N
N#define PWM_CAPINTSTS_CAPOVF2_Pos        (20)                                              /*!< PWM_T::CAPINTSTS: CAPOVF2 Position        */
N#define PWM_CAPINTSTS_CAPOVF2_Msk        (0x1ul << PWM_CAPINTSTS_CAPOVF2_Pos)              /*!< PWM_T::CAPINTSTS: CAPOVF2 Mask            */
N
N#define PWM_CAPINTSTS_CAPIF3_Pos         (24)                                              /*!< PWM_T::CAPINTSTS: CAPIF3 Position         */
N#define PWM_CAPINTSTS_CAPIF3_Msk         (0x1ul << PWM_CAPINTSTS_CAPIF3_Pos)               /*!< PWM_T::CAPINTSTS: CAPIF3 Mask             */
N
N#define PWM_CAPINTSTS_CRLI3_Pos          (25)                                              /*!< PWM_T::CAPINTSTS: CRLI3 Position          */
N#define PWM_CAPINTSTS_CRLI3_Msk          (0x1ul << PWM_CAPINTSTS_CRLI3_Pos)                /*!< PWM_T::CAPINTSTS: CRLI3 Mask              */
N
N#define PWM_CAPINTSTS_CFLI3_Pos          (26)                                              /*!< PWM_T::CAPINTSTS: CFLI3 Position          */
N#define PWM_CAPINTSTS_CFLI3_Msk          (0x1ul << PWM_CAPINTSTS_CFLI3_Pos)                /*!< PWM_T::CAPINTSTS: CFLI3 Mask              */
N
N#define PWM_CAPINTSTS_CAPOVR3_Pos        (27)                                              /*!< PWM_T::CAPINTSTS: CAPOVR3 Position        */
N#define PWM_CAPINTSTS_CAPOVR3_Msk        (0x1ul << PWM_CAPINTSTS_CAPOVR3_Pos)              /*!< PWM_T::CAPINTSTS: CAPOVR3 Mask            */
N
N#define PWM_CAPINTSTS_CAPOVF3_Pos        (28)                                              /*!< PWM_T::CAPINTSTS: CAPOVF3 Position        */
N#define PWM_CAPINTSTS_CAPOVF3_Msk        (0x1ul << PWM_CAPINTSTS_CAPOVF3_Pos)              /*!< PWM_T::CAPINTSTS: CAPOVF3 Mask            */
N
N#define PWM_CRL0_CRL15_0_Pos             (0)                                               /*!< PWM_T::CRL0: CRL15_0 Position             */
N#define PWM_CRL0_CRL15_0_Msk             (0xfffful << PWM_CRL0_CRL15_0_Pos)                /*!< PWM_T::CRL0: CRL15_0 Mask                 */
N
N#define PWM_CRL0_CRL31_16_Pos            (16)                                              /*!< PWM_T::CRL0: CRL31_16 Position            */
N#define PWM_CRL0_CRL31_16_Msk            (0xfffful << PWM_CRL0_CRL31_16_Pos)               /*!< PWM_T::CRL0: CRL31_16 Mask                */
N
N#define PWM_CFL0_CFL15_0_Pos             (0)                                               /*!< PWM_T::CFL0: CFL15_0 Position             */
N#define PWM_CFL0_CFL15_0_Msk             (0xfffful << PWM_CFL0_CFL15_0_Pos)                /*!< PWM_T::CFL0: CFL15_0 Mask                 */
N
N#define PWM_CFL0_CFL31_16_Pos            (16)                                              /*!< PWM_T::CFL0: CFL31_16 Position            */
N#define PWM_CFL0_CFL31_16_Msk            (0xfffful << PWM_CFL0_CFL31_16_Pos)               /*!< PWM_T::CFL0: CFL31_16 Mask                */
N
N#define PWM_CRL1_CRL15_0_Pos             (0)                                               /*!< PWM_T::CRL1: CRL15_0 Position             */
N#define PWM_CRL1_CRL15_0_Msk             (0xfffful << PWM_CRL1_CRL15_0_Pos)                /*!< PWM_T::CRL1: CRL15_0 Mask                 */
N
N#define PWM_CRL1_CRL31_16_Pos            (16)                                              /*!< PWM_T::CRL1: CRL31_16 Position            */
N#define PWM_CRL1_CRL31_16_Msk            (0xfffful << PWM_CRL1_CRL31_16_Pos)               /*!< PWM_T::CRL1: CRL31_16 Mask                */
N
N#define PWM_CFL1_CFL15_0_Pos             (0)                                               /*!< PWM_T::CFL1: CFL15_0 Position             */
N#define PWM_CFL1_CFL15_0_Msk             (0xfffful << PWM_CFL1_CFL15_0_Pos)                /*!< PWM_T::CFL1: CFL15_0 Mask                 */
N
N#define PWM_CFL1_CFL31_16_Pos            (16)                                              /*!< PWM_T::CFL1: CFL31_16 Position            */
N#define PWM_CFL1_CFL31_16_Msk            (0xfffful << PWM_CFL1_CFL31_16_Pos)               /*!< PWM_T::CFL1: CFL31_16 Mask                */
N
N#define PWM_CRL2_CRL15_0_Pos             (0)                                               /*!< PWM_T::CRL2: CRL15_0 Position             */
N#define PWM_CRL2_CRL15_0_Msk             (0xfffful << PWM_CRL2_CRL15_0_Pos)                /*!< PWM_T::CRL2: CRL15_0 Mask                 */
N
N#define PWM_CRL2_CRL31_16_Pos            (16)                                              /*!< PWM_T::CRL2: CRL31_16 Position            */
N#define PWM_CRL2_CRL31_16_Msk            (0xfffful << PWM_CRL2_CRL31_16_Pos)               /*!< PWM_T::CRL2: CRL31_16 Mask                */
N
N#define PWM_CFL2_CFL15_0_Pos             (0)                                               /*!< PWM_T::CFL2: CFL15_0 Position             */
N#define PWM_CFL2_CFL15_0_Msk             (0xfffful << PWM_CFL2_CFL15_0_Pos)                /*!< PWM_T::CFL2: CFL15_0 Mask                 */
N
N#define PWM_CFL2_CFL31_16_Pos            (16)                                              /*!< PWM_T::CFL2: CFL31_16 Position            */
N#define PWM_CFL2_CFL31_16_Msk            (0xfffful << PWM_CFL2_CFL31_16_Pos)               /*!< PWM_T::CFL2: CFL31_16 Mask                */
N
N#define PWM_CRL3_CRL15_0_Pos             (0)                                               /*!< PWM_T::CRL3: CRL15_0 Position             */
N#define PWM_CRL3_CRL15_0_Msk             (0xfffful << PWM_CRL3_CRL15_0_Pos)                /*!< PWM_T::CRL3: CRL15_0 Mask                 */
N
N#define PWM_CRL3_CRL31_16_Pos            (16)                                              /*!< PWM_T::CRL3: CRL31_16 Position            */
N#define PWM_CRL3_CRL31_16_Msk            (0xfffful << PWM_CRL3_CRL31_16_Pos)               /*!< PWM_T::CRL3: CRL31_16 Mask                */
N
N#define PWM_CFL3_CFL15_0_Pos             (0)                                               /*!< PWM_T::CFL3: CFL15_0 Position             */
N#define PWM_CFL3_CFL15_0_Msk             (0xfffful << PWM_CFL3_CFL15_0_Pos)                /*!< PWM_T::CFL3: CFL15_0 Mask                 */
N
N#define PWM_CFL3_CFL31_16_Pos            (16)                                              /*!< PWM_T::CFL3: CFL31_16 Position            */
N#define PWM_CFL3_CFL31_16_Msk            (0xfffful << PWM_CFL3_CFL31_16_Pos)               /*!< PWM_T::CFL3: CFL31_16 Mask                */
N
N#define PWM_PDMACH0_Captureddata7_0_Pos  (0)                                               /*!< PWM_T::PDMACH0: Captureddata7_0 Position  */
N#define PWM_PDMACH0_Captureddata7_0_Msk  (0xfful << PWM_PDMACH0_Captureddata7_0_Pos)       /*!< PWM_T::PDMACH0: Captureddata7_0 Mask      */
N
N#define PWM_PDMACH0_Captureddata15_8_Pos (8)                                               /*!< PWM_T::PDMACH0: Captureddata15_8 Position */
N#define PWM_PDMACH0_Captureddata15_8_Msk (0xfful << PWM_PDMACH0_Captureddata15_8_Pos)      /*!< PWM_T::PDMACH0: Captureddata15_8 Mask     */
N
N#define PWM_PDMACH0_Captureddata23_16_Pos (16)                                             /*!< PWM_T::PDMACH0: Captureddata23_16 Position*/
N#define PWM_PDMACH0_Captureddata23_16_Msk (0xfful << PWM_PDMACH0_Captureddata23_16_Pos)    /*!< PWM_T::PDMACH0: Captureddata23_16 Mask    */
N
N#define PWM_PDMACH0_Captureddata31_24_Pos (24)                                             /*!< PWM_T::PDMACH0: Captureddata31_24 Position*/
N#define PWM_PDMACH0_Captureddata31_24_Msk (0xfful << PWM_PDMACH0_Captureddata31_24_Pos)    /*!< PWM_T::PDMACH0: Captureddata31_24 Mask    */
N
N#define PWM_PDMACH2_Captureddata7_0_Pos  (0)                                               /*!< PWM_T::PDMACH2: Captureddata7_0 Position  */
N#define PWM_PDMACH2_Captureddata7_0_Msk  (0xfful << PWM_PDMACH2_Captureddata7_0_Pos)       /*!< PWM_T::PDMACH2: Captureddata7_0 Mask      */
N
N#define PWM_PDMACH2_Captureddata15_8_Pos (8)                                               /*!< PWM_T::PDMACH2: Captureddata15_8 Position */
N#define PWM_PDMACH2_Captureddata15_8_Msk (0xfful << PWM_PDMACH2_Captureddata15_8_Pos)      /*!< PWM_T::PDMACH2: Captureddata15_8 Mask     */
N
N#define PWM_PDMACH2_Captureddata23_16_Pos (16)                                             /*!< PWM_T::PDMACH2: Captureddata23_16 Position*/
N#define PWM_PDMACH2_Captureddata23_16_Msk (0xfful << PWM_PDMACH2_Captureddata23_16_Pos)    /*!< PWM_T::PDMACH2: Captureddata23_16 Mask    */
N
N#define PWM_PDMACH2_Captureddata31_24_Pos (24)                                             /*!< PWM_T::PDMACH2: Captureddata31_24 Position*/
N#define PWM_PDMACH2_Captureddata31_24_Msk (0xfful << PWM_PDMACH2_Captureddata31_24_Pos)    /*!< PWM_T::PDMACH2: Captureddata31_24 Mask    */
N
N/**@}*/ /* PWM_CONST */
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * INIR
N     * ===================================================================================================
N     * Offset: 0x00  RTC Initiation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACTIVE    |RTC Active Status (Read Only)
N     * |        |          |0 = RTC is at reset state.
N     * |        |          |1 = RTC is at normal active state.
N     * |[31:1]  |INIR      |RTC Initiation (Write Only)
N     * |        |          |When RTC block is powered on, RTC is at reset state.
N     * |        |          |User has to write a number (0x a5eb1357) to INIR to make RTC leaving reset state.
N     * |        |          |Once the INIR is written as 0xa5eb1357, the RTC will be in un-reset state permanently.
N     * |        |          |The INIR is a write-only field and read value will be always "0".
N    */
N    __IO  uint32_t INIR;
X    volatile  uint32_t INIR;
N
N    /**
N     * AER
N     * ===================================================================================================
N     * Offset: 0x04  RTC Access Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |AER       |RTC Register Access Enable Password (Write Only)
N     * |        |          |Enable RTC access after write 0xA965. Otherwise disable RTC access.
N     * |[16]    |ENF       |RTC Register Access Enable Flag (Read Only)
N     * |        |          |1 = RTC register read/write Enabled.
N     * |        |          |0 = RTC register read/write Disabled.
N     * |        |          |This bit will be set after AER[15:0] register is load a 0xA965, and be cleared automatically 512 RTC clocks or AER[15:0] is not 0xA965.
N    */
N    __IO  uint32_t AER;
X    volatile  uint32_t AER;
N
N    /**
N     * FCR
N     * ===================================================================================================
N     * Offset: 0x08  RTC Frequency Compensation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |FRACTION  |Fraction Part
N     * |        |          |Formula = (fraction part of detected value) x 64.
N     * |        |          |Note: Digit in FCR must be expressed as hexadecimal number.
N     * |[11:8]  |INTEGER   |Integer Part
N     * |        |          |0000 = 32761.
N     * |        |          |0001 = 32762.
N     * |        |          |0010 = 32763.
N     * |        |          |0011 = 32764.
N     * |        |          |0100 = 32765.
N     * |        |          |0101 = 32766.
N     * |        |          |0110 = 32767.
N     * |        |          |0111 = 32768.
N     * |        |          |1000 = 32769.
N     * |        |          |1001 = 32770.
N     * |        |          |1010 = 32771.
N     * |        |          |1011 = 32772.
N     * |        |          |1100 = 32773.
N     * |        |          |1101 = 32774.
N     * |        |          |1110 = 32775.
N     * |        |          |1111 = 32776.
N    */
N    __IO uint32_t FCR;
X    volatile uint32_t FCR;
N
N    /**
N     * TLR
N     * ===================================================================================================
N     * Offset: 0x0C  Time Loading Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |1SEC      |1 Sec Time Digit (0~9)
N     * |[6:4]   |10SEC     |10 Sec Time Digit (0~5)
N     * |[11:8]  |1MIN      |1 Min Time Digit (0~9)
N     * |[14:12] |10MIN     |10 Min Time Digit (0~5)
N     * |[19:16] |1HR       |1 Hour Time Digit (0~9)
N     * |[21:20] |10HR      |10 Hour Time Digit (0~2)
N    */
N    __IO uint32_t TLR;
X    volatile uint32_t TLR;
N
N    /**
N     * CLR
N     * ===================================================================================================
N     * Offset: 0x10  Calendar Loading Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |1DAY      |1 Day Calendar Digit (0~9)
N     * |[5:4]   |10DAY     |10 Day Calendar Digit (0~3)
N     * |[11:8]  |1MON      |1 Month Calendar Digit (0~9)
N     * |[12]    |10MON     |10 Month Calendar Digit (0~1)
N     * |[19:16] |1YEAR     |1 Year Calendar Digit (0~9)
N     * |[23:20] |10YEAR    |10 Year Calendar Digit (0~9)
N    */
N    __IO uint32_t CLR;
X    volatile uint32_t CLR;
N
N    /**
N     * TSSR
N     * ===================================================================================================
N     * Offset: 0x14  Time Scale Selection Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |24hr_12hr |24-Hour / 12-Hour Mode Selection
N     * |        |          |It indicates that TLR and TAR are in 24-hour mode or 12-hour mode
N     * |        |          |0 = select 12-hour time scale with AM and PM indication.
N     * |        |          |1 = select 24-hour time scale.
N    */
N    __IO uint32_t TSSR;
X    volatile uint32_t TSSR;
N
N    /**
N     * DWR
N     * ===================================================================================================
N     * Offset: 0x18  Day of the Week Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |DWR       |Day Of The Week Register
N     * |        |          |000 = Sunday.
N     * |        |          |001 = Monday.
N     * |        |          |010 = Tuesday.
N     * |        |          |011 = Wednesday.
N     * |        |          |100 = Thursday.
N     * |        |          |101 = Friday.
N     * |        |          |110 = Saturday.
N    */
N    __IO uint32_t DWR;
X    volatile uint32_t DWR;
N
N    /**
N     * TAR
N     * ===================================================================================================
N     * Offset: 0x1C  Time Alarm Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |1SEC      |1 Sec Time Digit of Alarm Setting (0~9)
N     * |[6:4]   |10SEC     |10 Sec Time Digit of Alarm Setting (0~5)
N     * |[11:8]  |1MIN      |1 Min Time Digit of Alarm Setting (0~9)
N     * |[14:12] |10MIN     |10 Min Time Digit of Alarm Setting (0~5)
N     * |[19:16] |1HR       |1 Hour Time Digit of Alarm Setting (0~9)
N     * |[21:20] |10HR      |10 Hour Time Digit of Alarm Setting (0~2)
N    */
N    __IO uint32_t TAR;
X    volatile uint32_t TAR;
N
N    /**
N     * CAR
N     * ===================================================================================================
N     * Offset: 0x20  Calendar Alarm Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |1DAY      |1 Day Calendar Digit of Alarm Setting (0~9)
N     * |[5:4]   |10DAY     |10 Day Calendar Digit of Alarm Setting (0~3)
N     * |[11:8]  |1MON      |1 Month Calendar Digit of Alarm Setting (0~9)
N     * |[12]    |10MON     |10 Month Calendar Digit of Alarm Setting (0~1)
N     * |[19:16] |1YEAR     |1 Year Calendar Digit of Alarm Setting (0~9)
N     * |[23:20] |10YEAR    |10 Year Calendar Digit of Alarm Setting (0~9)
N    */
N    __IO uint32_t CAR;
X    volatile uint32_t CAR;
N
N    /**
N     * LIR
N     * ===================================================================================================
N     * Offset: 0x24  Leap Year Indicator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LIR       |Leap Year Indication REGISTER (Read Only)
N     * |        |          |0 = This year is not a leap year.
N     * |        |          |1 = This year is leap year.
N    */
N    __I  uint32_t LIR;
X    volatile const  uint32_t LIR;
N
N    /**
N     * RIER
N     * ===================================================================================================
N     * Offset: 0x28  RTC Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |AIER      |Alarm Interrupt Enable
N     * |        |          |0 = RTC Alarm Interrupt is disabled.
N     * |        |          |1 = RTC Alarm Interrupt is enabled.
N     * |[1]     |TIER      |Time Tick Interrupt And Wake-Up By Tick Enable
N     * |        |          |0 = RTC Time Tick Interrupt is disabled.
N     * |        |          |1 = RTC Time Tick Interrupt is enabled.
N     * |[2]     |SNOOPIER  |Snooper Pin Event Detection Interrupt Enable
N     * |        |          |0 = Snooper Pin Event Detection Interrupt is disabled.
N     * |        |          |1 = Snooper Pin Event Detection Interrupt is enabled.
N    */
N    __IO uint32_t RIER;
X    volatile uint32_t RIER;
N
N    /**
N     * RIIR
N     * ===================================================================================================
N     * Offset: 0x2C  RTC Interrupt Indication Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |AIS       |RTC Alarm Interrupt Status
N     * |        |          |RTC unit will set AIS to high once the RTC real time counters TLR and CLR reach the alarm setting time registers TAR and CAR.
N     * |        |          |When this bit is set and AIER is also high, RTC will generate an interrupt to CPU.
N     * |        |          |This bit is cleared by writing "1" to it through software.
N     * |        |          |0 = RCT Alarm Interrupt condition never occurred.
N     * |        |          |1 = RTC Alarm Interrupt is requested if RIER.AIER=1.
N     * |[1]     |TIS       |RTC Time Tick Interrupt Status
N     * |        |          |RTC unit will set TIF to high periodically in the period selected by TTR[2:0].
N     * |        |          |When this bit is set and TIER is also high, RTC will generate an interrupt to CPU.
N     * |        |          |This bit is cleared by writing "1" to it through software.
N     * |        |          |0 = RCT Time Tick Interrupt condition never occurred.
N     * |        |          |1 = RTC Time Tick Interrupt is requested.
N     * |[2]     |SNOOPIF   |Snooper Pin Event Detection Interrupt Flag
N     * |        |          |When SNOOPEN is high and an event defined by SNOOPEDGE detected in snooper pin, this flag will be set.
N     * |        |          |While this bit is set and SNOOPIER is also high, RTC will generate an interrupt to CPU.
N     * |        |          |Write "1" to clear this bit to "0".
N     * |        |          |0 = Snooper pin event defined by SNOOPEDGE never detected.
N     * |        |          |1 = Snooper pin event defined by SNOOPEDGE detected.
N    */
N    __IO uint32_t RIIR;
X    volatile uint32_t RIIR;
N
N    /**
N     * TTR
N     * ===================================================================================================
N     * Offset: 0x30  RTC Time Tick Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |TTR       |Time Tick Register
N     * |        |          |The RTC time tick period for Periodic Time Tick Interrupt request.
N     * |        |          |000 = 1 tick/second.
N     * |        |          |001 = 1/2 tick/second.
N     * |        |          |010 = 1/4 tick/second.
N     * |        |          |011 = 1/8 tick/second.
N     * |        |          |100 = 1/16 tick/second.
N     * |        |          |101 = 1/32 tick/second.
N     * |        |          |110 = 1/64 tick/second.
N     * |        |          |111 = 1/128 tick/second.
N     * |        |          |Note: This register can be read back after the RTC is active by AER.
N     * |[3]     |TWKE      |RTC Timer Wake-Up CPU Function Enable Bit
N     * |        |          |If TWKE is set before CPU enters power-down mode, when a RTC Time Tick, CPU will be wakened up by RTC unit.
N     * |        |          |0 = Time Tick wake-up CPU function Disabled.
N     * |        |          |1 = Wake-up function Enabled so that CPU can be waken up from Power-down mode by Time Tick.
N     * |        |          |Note: Tick timer setting follows the TTR description.
N    */
N    __IO uint32_t TTR;
X    volatile uint32_t TTR;
N    uint32_t RESERVE0[2];
N
N
N    /**
N     * SPRCTL
N     * ===================================================================================================
N     * Offset: 0x3C  RTC Spare Functional Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SNOOPEN   |Snooper Pin Event Detection Enable
N     * |        |          |This bit enables the snooper pin event detection.
N     * |        |          |When this bit is set high and an event defined by SNOOPEDGE detected, the 20 spare registers will be cleared to "0" by hardware automatically.
N     * |        |          |And, the SNOOPIF will also be set.
N     * |        |          |In addition, RTC will also generate wake-up event to wake system up.
N     * |        |          |0 = Snooper pin event detection function Disabled.
N     * |        |          |1 = Snooper pin event detection function Enabled.
N     * |[1]     |SNOOPEDGE |Snooper Active Edge Selection
N     * |        |          |This bit defines which edge of snooper pin will generate a snooper pin detected event to clear the 20 spare registers.
N     * |        |          |0 = Rising edge of snooper pin generates snooper pin detected event.
N     * |        |          |1 = Falling edge of snooper pin generates snooper pin detected event.
N     * |[7]     |SPRRDY    |SPR Register Ready
N     * |        |          |This bit indicates if the registers SPR0 ~ SPR19 are ready to read.
N     * |        |          |After CPU writing registers SPR0 ~ SPR19, polling this bit to check if SP0 ~ SPR19 are updated done is necessary.
N     * |        |          |This it is read only and any write to this bit won't take any effect.
N     * |        |          |0 = SPR0 ~ SPR19 updating is in progress.
N     * |        |          |1 = SPR0 ~ SPR19 are updated done and ready to read.
N    */
N    __IO uint32_t SPRCTL;
X    volatile uint32_t SPRCTL;
N
N    /**
N     * SPR0 ~ 19
N     * ===================================================================================================
N     * Offset: 0x40 ~ 0x8C  RTC Spare Register 0 ~ 19
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |SPARE     |SPARE
N     * |        |          |This field is used to store back-up information defined by software.
N     * |        |          |This field will be cleared by hardware automatically once a snooper pin event is detected.
N    */
N    __IO uint32_t SPR[20];
X    volatile uint32_t SPR[20];
N
N} RTC_T;
N
N/**
N    @addtogroup RTC_CONST RTC Bit Field Definition
N    Constant Definitions for RTC Controller
N@{ */
N
N#define RTC_INIR_ACTIVE_Pos              (0)                                               /*!< RTC_T::INIR: ACTIVE Position              */
N#define RTC_INIR_ACTIVE_Msk              (0x1ul << RTC_INIR_ACTIVE_Pos)                    /*!< RTC_T::INIR: ACTIVE Mask                  */
N
N#define RTC_INIR_INIR_Pos                (0)                                               /*!< RTC_T::INIR: INIR Position                */
N#define RTC_INIR_INIR_Msk                (0xfffffffful << RTC_INIR_INIR_Pos)               /*!< RTC_T::INIR: INIR Mask                    */
N
N#define RTC_AER_AER_Pos                  (0)                                               /*!< RTC_T::AER: AER Position                  */
N#define RTC_AER_AER_Msk                  (0xfffful << RTC_AER_AER_Pos)                     /*!< RTC_T::AER: AER Mask                      */
N
N#define RTC_AER_ENF_Pos                  (16)                                              /*!< RTC_T::AER: ENF Position                  */
N#define RTC_AER_ENF_Msk                  (0x1ul << RTC_AER_ENF_Pos)                        /*!< RTC_T::AER: ENF Mask                      */
N
N#define RTC_FCR_FRACTION_Pos             (0)                                               /*!< RTC_T::FCR: FRACTION Position             */
N#define RTC_FCR_FRACTION_Msk             (0x3ful << RTC_FCR_FRACTION_Pos)                  /*!< RTC_T::FCR: FRACTION Mask                 */
N
N#define RTC_FCR_INTEGER_Pos              (8)                                               /*!< RTC_T::FCR: INTEGER Position              */
N#define RTC_FCR_INTEGER_Msk              (0xful << RTC_FCR_INTEGER_Pos)                    /*!< RTC_T::FCR: INTEGER Mask                  */
N
N#define RTC_TLR_1SEC_Pos                 (0)                                               /*!< RTC_T::TLR: 1SEC Position                 */
N#define RTC_TLR_1SEC_Msk                 (0xful << RTC_TLR_1SEC_Pos)                       /*!< RTC_T::TLR: 1SEC Mask                     */
N
N#define RTC_TLR_10SEC_Pos                (4)                                               /*!< RTC_T::TLR: 10SEC Position                */
N#define RTC_TLR_10SEC_Msk                (0x7ul << RTC_TLR_10SEC_Pos)                      /*!< RTC_T::TLR: 10SEC Mask                    */
N
N#define RTC_TLR_1MIN_Pos                 (8)                                               /*!< RTC_T::TLR: 1MIN Position                 */
N#define RTC_TLR_1MIN_Msk                 (0xful << RTC_TLR_1MIN_Pos)                       /*!< RTC_T::TLR: 1MIN Mask                     */
N
N#define RTC_TLR_10MIN_Pos                (12)                                              /*!< RTC_T::TLR: 10MIN Position                */
N#define RTC_TLR_10MIN_Msk                (0x7ul << RTC_TLR_10MIN_Pos)                      /*!< RTC_T::TLR: 10MIN Mask                    */
N
N#define RTC_TLR_1HR_Pos                  (16)                                              /*!< RTC_T::TLR: 1HR Position                  */
N#define RTC_TLR_1HR_Msk                  (0xful << RTC_TLR_1HR_Pos)                        /*!< RTC_T::TLR: 1HR Mask                      */
N
N#define RTC_TLR_10HR_Pos                 (20)                                              /*!< RTC_T::TLR: 10HR Position                 */
N#define RTC_TLR_10HR_Msk                 (0x3ul << RTC_TLR_10HR_Pos)                       /*!< RTC_T::TLR: 10HR Mask                     */
N
N#define RTC_CLR_1DAY_Pos                 (0)                                               /*!< RTC_T::CLR: 1DAY Position                 */
N#define RTC_CLR_1DAY_Msk                 (0xful << RTC_CLR_1DAY_Pos)                       /*!< RTC_T::CLR: 1DAY Mask                     */
N
N#define RTC_CLR_10DAY_Pos                (4)                                               /*!< RTC_T::CLR: 10DAY Position                */
N#define RTC_CLR_10DAY_Msk                (0x3ul << RTC_CLR_10DAY_Pos)                      /*!< RTC_T::CLR: 10DAY Mask                    */
N
N#define RTC_CLR_1MON_Pos                 (8)                                               /*!< RTC_T::CLR: 1MON Position                 */
N#define RTC_CLR_1MON_Msk                 (0xful << RTC_CLR_1MON_Pos)                       /*!< RTC_T::CLR: 1MON Mask                     */
N
N#define RTC_CLR_10MON_Pos                (12)                                              /*!< RTC_T::CLR: 10MON Position                */
N#define RTC_CLR_10MON_Msk                (0x1ul << RTC_CLR_10MON_Pos)                      /*!< RTC_T::CLR: 10MON Mask                    */
N
N#define RTC_CLR_1YEAR_Pos                (16)                                              /*!< RTC_T::CLR: 1YEAR Position                */
N#define RTC_CLR_1YEAR_Msk                (0xful << RTC_CLR_1YEAR_Pos)                      /*!< RTC_T::CLR: 1YEAR Mask                    */
N
N#define RTC_CLR_10YEAR_Pos               (20)                                              /*!< RTC_T::CLR: 10YEAR Position               */
N#define RTC_CLR_10YEAR_Msk               (0xful << RTC_CLR_10YEAR_Pos)                     /*!< RTC_T::CLR: 10YEAR Mask                   */
N
N#define RTC_TSSR_24H_12H_Pos           (0)                                                 /*!< RTC_T::TSSR: 24hr_12hr Position           */
N#define RTC_TSSR_24H_12H_Msk           (0x1ul << RTC_TSSR_24H_12H_Pos)                     /*!< RTC_T::TSSR: 24hr_12hr Mask               */
N
N#define RTC_DWR_DWR_Pos                  (0)                                               /*!< RTC_T::DWR: DWR Position                  */
N#define RTC_DWR_DWR_Msk                  (0x7ul << RTC_DWR_DWR_Pos)                        /*!< RTC_T::DWR: DWR Mask                      */
N
N#define RTC_TAR_1SEC_Pos                 (0)                                               /*!< RTC_T::TAR: 1SEC Position                 */
N#define RTC_TAR_1SEC_Msk                 (0xful << RTC_TAR_1SEC_Pos)                       /*!< RTC_T::TAR: 1SEC Mask                     */
N
N#define RTC_TAR_10SEC_Pos                (4)                                               /*!< RTC_T::TAR: 10SEC Position                */
N#define RTC_TAR_10SEC_Msk                (0x7ul << RTC_TAR_10SEC_Pos)                      /*!< RTC_T::TAR: 10SEC Mask                    */
N
N#define RTC_TAR_1MIN_Pos                 (8)                                               /*!< RTC_T::TAR: 1MIN Position                 */
N#define RTC_TAR_1MIN_Msk                 (0xful << RTC_TAR_1MIN_Pos)                       /*!< RTC_T::TAR: 1MIN Mask                     */
N
N#define RTC_TAR_10MIN_Pos                (12)                                              /*!< RTC_T::TAR: 10MIN Position                */
N#define RTC_TAR_10MIN_Msk                (0x7ul << RTC_TAR_10MIN_Pos)                      /*!< RTC_T::TAR: 10MIN Mask                    */
N
N#define RTC_TAR_1HR_Pos                  (16)                                              /*!< RTC_T::TAR: 1HR Position                  */
N#define RTC_TAR_1HR_Msk                  (0xful << RTC_TAR_1HR_Pos)                        /*!< RTC_T::TAR: 1HR Mask                      */
N
N#define RTC_TAR_10HR_Pos                 (20)                                              /*!< RTC_T::TAR: 10HR Position                 */
N#define RTC_TAR_10HR_Msk                 (0x3ul << RTC_TAR_10HR_Pos)                       /*!< RTC_T::TAR: 10HR Mask                     */
N
N#define RTC_CAR_1DAY_Pos                 (0)                                               /*!< RTC_T::CAR: 1DAY Position                 */
N#define RTC_CAR_1DAY_Msk                 (0xful << RTC_CAR_1DAY_Pos)                       /*!< RTC_T::CAR: 1DAY Mask                     */
N
N#define RTC_CAR_10DAY_Pos                (4)                                               /*!< RTC_T::CAR: 10DAY Position                */
N#define RTC_CAR_10DAY_Msk                (0x3ul << RTC_CAR_10DAY_Pos)                      /*!< RTC_T::CAR: 10DAY Mask                    */
N
N#define RTC_CAR_1MON_Pos                 (8)                                               /*!< RTC_T::CAR: 1MON Position                 */
N#define RTC_CAR_1MON_Msk                 (0xful << RTC_CAR_1MON_Pos)                       /*!< RTC_T::CAR: 1MON Mask                     */
N
N#define RTC_CAR_10MON_Pos                (12)                                              /*!< RTC_T::CAR: 10MON Position                */
N#define RTC_CAR_10MON_Msk                (0x1ul << RTC_CAR_10MON_Pos)                      /*!< RTC_T::CAR: 10MON Mask                    */
N
N#define RTC_CAR_1YEAR_Pos                (16)                                              /*!< RTC_T::CAR: 1YEAR Position                */
N#define RTC_CAR_1YEAR_Msk                (0xful << RTC_CAR_1YEAR_Pos)                      /*!< RTC_T::CAR: 1YEAR Mask                    */
N
N#define RTC_CAR_10YEAR_Pos               (20)                                              /*!< RTC_T::CAR: 10YEAR Position               */
N#define RTC_CAR_10YEAR_Msk               (0xful << RTC_CAR_10YEAR_Pos)                     /*!< RTC_T::CAR: 10YEAR Mask                   */
N
N#define RTC_LIR_LIR_Pos                  (0)                                               /*!< RTC_T::LIR: LIR Position                  */
N#define RTC_LIR_LIR_Msk                  (0x1ul << RTC_LIR_LIR_Pos)                        /*!< RTC_T::LIR: LIR Mask                      */
N
N#define RTC_RIER_AIER_Pos                (0)                                               /*!< RTC_T::RIER: AIER Position                */
N#define RTC_RIER_AIER_Msk                (0x1ul << RTC_RIER_AIER_Pos)                      /*!< RTC_T::RIER: AIER Mask                    */
N
N#define RTC_RIER_TIER_Pos                (1)                                               /*!< RTC_T::RIER: TIER Position                */
N#define RTC_RIER_TIER_Msk                (0x1ul << RTC_RIER_TIER_Pos)                      /*!< RTC_T::RIER: TIER Mask                    */
N
N#define RTC_RIER_SNOOPIER_Pos            (2)                                               /*!< RTC_T::RIER: SNOOPIER Position            */
N#define RTC_RIER_SNOOPIER_Msk            (0x1ul << RTC_RIER_SNOOPIER_Pos)                  /*!< RTC_T::RIER: SNOOPIER Mask                */
N
N#define RTC_RIIR_AIF_Pos                 (0)                                               /*!< RTC_T::RIIR: AIF Position                 */
N#define RTC_RIIR_AIF_Msk                 (0x1ul << RTC_RIIR_AIF_Pos)                       /*!< RTC_T::RIIR: AIF Mask                     */
N
N#define RTC_RIIR_TIF_Pos                 (1)                                               /*!< RTC_T::RIIR: TIF Position                 */
N#define RTC_RIIR_TIF_Msk                 (0x1ul << RTC_RIIR_TIF_Pos)                       /*!< RTC_T::RIIR: TIF Mask                     */
N
N#define RTC_RIIR_SNOOPIF_Pos             (2)                                               /*!< RTC_T::RIIR: SNOOPIF Position             */
N#define RTC_RIIR_SNOOPIF_Msk             (0x1ul << RTC_RIIR_SNOOPIF_Pos)                   /*!< RTC_T::RIIR: SNOOPIF Mask                 */
N
N#define RTC_TTR_TTR_Pos                  (0)                                               /*!< RTC_T::TTR: TTR Position                  */
N#define RTC_TTR_TTR_Msk                  (0x7ul << RTC_TTR_TTR_Pos)                        /*!< RTC_T::TTR: TTR Mask                      */
N
N#define RTC_TTR_TWKE_Pos                 (3)                                               /*!< RTC_T::TTR: TWKE Position                 */
N#define RTC_TTR_TWKE_Msk                 (0x1ul << RTC_TTR_TWKE_Pos)                       /*!< RTC_T::TTR: TWKE Mask                     */
N
N#define RTC_SPRCTL_SNOOPEN_Pos           (0)                                               /*!< RTC_T::SPRCTL: SNOOPEN Position           */
N#define RTC_SPRCTL_SNOOPEN_Msk           (0x1ul << RTC_SPRCTL_SNOOPEN_Pos)                 /*!< RTC_T::SPRCTL: SNOOPEN Mask               */
N
N#define RTC_SPRCTL_SNOOPEDGE_Pos         (1)                                               /*!< RTC_T::SPRCTL: SNOOPEDGE Position         */
N#define RTC_SPRCTL_SNOOPEDGE_Msk         (0x1ul << RTC_SPRCTL_SNOOPEDGE_Pos)               /*!< RTC_T::SPRCTL: SNOOPEDGE Mask             */
N
N#define RTC_SPRCTL_SPRRDY_Pos            (7)                                               /*!< RTC_T::SPRCTL: SPRRDY Position            */
N#define RTC_SPRCTL_SPRRDY_Msk            (0x1ul << RTC_SPRCTL_SPRRDY_Pos)                  /*!< RTC_T::SPRCTL: SPRRDY Mask                */
N
N#define RTC_SPR0_SPARE_Pos               (0)                                               /*!< RTC_T::SPR0: SPARE Position               */
N#define RTC_SPR0_SPARE_Msk               (0xfffffffful << RTC_SPR0_SPARE_Pos)              /*!< RTC_T::SPR0: SPARE Mask                   */
N
N#define RTC_SPR1_SPARE_Pos               (0)                                               /*!< RTC_T::SPR1: SPARE Position               */
N#define RTC_SPR1_SPARE_Msk               (0xfffffffful << RTC_SPR1_SPARE_Pos)              /*!< RTC_T::SPR1: SPARE Mask                   */
N
N#define RTC_SPR2_SPARE_Pos               (0)                                               /*!< RTC_T::SPR2: SPARE Position               */
N#define RTC_SPR2_SPARE_Msk               (0xfffffffful << RTC_SPR2_SPARE_Pos)              /*!< RTC_T::SPR2: SPARE Mask                   */
N
N#define RTC_SPR3_SPARE_Pos               (0)                                               /*!< RTC_T::SPR3: SPARE Position               */
N#define RTC_SPR3_SPARE_Msk               (0xfffffffful << RTC_SPR3_SPARE_Pos)              /*!< RTC_T::SPR3: SPARE Mask                   */
N
N#define RTC_SPR4_SPARE_Pos               (0)                                               /*!< RTC_T::SPR4: SPARE Position               */
N#define RTC_SPR4_SPARE_Msk               (0xfffffffful << RTC_SPR4_SPARE_Pos)              /*!< RTC_T::SPR4: SPARE Mask                   */
N
N#define RTC_SPR5_SPARE_Pos               (0)                                               /*!< RTC_T::SPR5: SPARE Position               */
N#define RTC_SPR5_SPARE_Msk               (0xfffffffful << RTC_SPR5_SPARE_Pos)              /*!< RTC_T::SPR5: SPARE Mask                   */
N
N#define RTC_SPR6_SPARE_Pos               (0)                                               /*!< RTC_T::SPR6: SPARE Position               */
N#define RTC_SPR6_SPARE_Msk               (0xfffffffful << RTC_SPR6_SPARE_Pos)              /*!< RTC_T::SPR6: SPARE Mask                   */
N
N#define RTC_SPR7_SPARE_Pos               (0)                                               /*!< RTC_T::SPR7: SPARE Position               */
N#define RTC_SPR7_SPARE_Msk               (0xfffffffful << RTC_SPR7_SPARE_Pos)              /*!< RTC_T::SPR7: SPARE Mask                   */
N
N#define RTC_SPR8_SPARE_Pos               (0)                                               /*!< RTC_T::SPR8: SPARE Position               */
N#define RTC_SPR8_SPARE_Msk               (0xfffffffful << RTC_SPR8_SPARE_Pos)              /*!< RTC_T::SPR8: SPARE Mask                   */
N
N#define RTC_SPR9_SPARE_Pos               (0)                                               /*!< RTC_T::SPR9: SPARE Position               */
N#define RTC_SPR9_SPARE_Msk               (0xfffffffful << RTC_SPR9_SPARE_Pos)              /*!< RTC_T::SPR9: SPARE Mask                   */
N
N#define RTC_SPR10_SPARE_Pos              (0)                                               /*!< RTC_T::SPR10: SPARE Position              */
N#define RTC_SPR10_SPARE_Msk              (0xfffffffful << RTC_SPR10_SPARE_Pos)             /*!< RTC_T::SPR10: SPARE Mask                  */
N
N#define RTC_SPR11_SPARE_Pos              (0)                                               /*!< RTC_T::SPR11: SPARE Position              */
N#define RTC_SPR11_SPARE_Msk              (0xfffffffful << RTC_SPR11_SPARE_Pos)             /*!< RTC_T::SPR11: SPARE Mask                  */
N
N#define RTC_SPR12_SPARE_Pos              (0)                                               /*!< RTC_T::SPR12: SPARE Position              */
N#define RTC_SPR12_SPARE_Msk              (0xfffffffful << RTC_SPR12_SPARE_Pos)             /*!< RTC_T::SPR12: SPARE Mask                  */
N
N#define RTC_SPR13_SPARE_Pos              (0)                                               /*!< RTC_T::SPR13: SPARE Position              */
N#define RTC_SPR13_SPARE_Msk              (0xfffffffful << RTC_SPR13_SPARE_Pos)             /*!< RTC_T::SPR13: SPARE Mask                  */
N
N#define RTC_SPR14_SPARE_Pos              (0)                                               /*!< RTC_T::SPR14: SPARE Position              */
N#define RTC_SPR14_SPARE_Msk              (0xfffffffful << RTC_SPR14_SPARE_Pos)             /*!< RTC_T::SPR14: SPARE Mask                  */
N
N#define RTC_SPR15_SPARE_Pos              (0)                                               /*!< RTC_T::SPR15: SPARE Position              */
N#define RTC_SPR15_SPARE_Msk              (0xfffffffful << RTC_SPR15_SPARE_Pos)             /*!< RTC_T::SPR15: SPARE Mask                  */
N
N#define RTC_SPR16_SPARE_Pos              (0)                                               /*!< RTC_T::SPR16: SPARE Position              */
N#define RTC_SPR16_SPARE_Msk              (0xfffffffful << RTC_SPR16_SPARE_Pos)             /*!< RTC_T::SPR16: SPARE Mask                  */
N
N#define RTC_SPR17_SPARE_Pos              (0)                                               /*!< RTC_T::SPR17: SPARE Position              */
N#define RTC_SPR17_SPARE_Msk              (0xfffffffful << RTC_SPR17_SPARE_Pos)             /*!< RTC_T::SPR17: SPARE Mask                  */
N
N#define RTC_SPR18_SPARE_Pos              (0)                                               /*!< RTC_T::SPR18: SPARE Position              */
N#define RTC_SPR18_SPARE_Msk              (0xfffffffful << RTC_SPR18_SPARE_Pos)             /*!< RTC_T::SPR18: SPARE Mask                  */
N
N#define RTC_SPR19_SPARE_Pos              (0)                                               /*!< RTC_T::SPR19: SPARE Position              */
N#define RTC_SPR19_SPARE_Msk              (0xfffffffful << RTC_SPR19_SPARE_Pos)             /*!< RTC_T::SPR19: SPARE Mask                  */
N
N/**@}*/ /* RTC_CONST */
N/**@}*/ /* end of RTC register group */
N
N
N/*---------------------- Smart Card Host Interface Controller -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface Controller(SC)
N    Memory Mapped Structure for SC Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    union
N    {
N        /**
N         * RBR
N         * ===================================================================================================
N         * Offset: 0x00  SC Receive Buffer Register
N         * ---------------------------------------------------------------------------------------------------
N         * |Bits    |Field     |Descriptions
N         * | :----: | :----:   | :---- |
N         * |[7:0]   |RBR       |Receiving Buffer
N         * |        |          |By reading this register, the SC Controller will return an 8-bit data received from RX pin (LSB first).
N        */
N        __I  uint32_t  RBR;
X        volatile const  uint32_t  RBR;
N        /**
N         * THR
N         * ===================================================================================================
N         * Offset: 0x00  SC Transmit Buffer Register
N         * ---------------------------------------------------------------------------------------------------
N         * |Bits    |Field     |Descriptions
N         * | :----: | :----:   | :---- |
N         * |[7:0]   |THR       |Transmit Buffer
N         * |        |          |By writing to this register, the SC sends out an 8-bit data through the TX pin (LSB first).
N        */
N        __O  uint32_t  THR;
X        volatile  uint32_t  THR;
N    };
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x04  SC Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SC_CEN    |SC Engine Enable
N     * |        |          |Set this bit to "1" to enable SC operation.
N     * |        |          |If this bit is cleared, SC will force all transition to IDLE state.
N     * |[1]     |DIS_RX    |RX Transition Disable
N     * |        |          |0 = Receiver Enabled.
N     * |        |          |1 = Receiver Disabled.
N     * |[2]     |DIS_TX    |TX Transition Disable
N     * |        |          |0 = Transceiver Enabled.
N     * |        |          |1 = Transceiver Disabled.
N     * |[3]     |AUTO_CON_EN|Auto Convention Enable
N     * |        |          |0 = Auto-convention Disabled.
N     * |        |          |1 = Auto-convention Enabled.
N     * |        |          |When hardware receives TS in answer to reset state and the TS is direct convention, CON_SEL will be set to 00 automatically, otherwise if the TS is inverse convention, CON_SEL will be set to 11.
N     * |        |          |If software enables auto convention function, the setting step must be done before Answer to Reset state and the first data must be 0x3B or 0x3F.
N     * |        |          |After hardware received first data and stored it at buffer, hardware will decided the convention and change the SC_CTL[CON_SEL] register automatically.
N     * |        |          |If the first data is not 0x3B or 0x3F, hardware will generate an interrupt INT_ACON_ERR(if SC_IER [ACON_ERR_IE = "1"] to CPU.
N     * |[5:4]   |CON_SEL   |Convention Selection
N     * |        |          |00 = Direct convention.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Reserved.
N     * |        |          |11 = Inverse convention.
N     * |        |          |Note: If AUTO_CON_EN is enabled, this field must be ignored.
N     * |[7:6]   |RX_FTRI_LEV|RX Buffer Trigger Level
N     * |        |          |When the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be set (if IER [RDA_IEN] is enabled, an interrupt will be generated).
N     * |        |          |00 = INTR_RDA Trigger Level 1 byte.
N     * |        |          |01 = INTR_RDA Trigger Level 2 bytes.
N     * |        |          |10 = INTR_RDA Trigger Level 3 bytes.
N     * |        |          |11 = Reserved.
N     * |[12:8]  |BGT       |Block Guard Time (BGT)
N     * |        |          |This field indicates the counter for block guard time.
N     * |        |          |According to ISO7816-3, in T=0 mode, software must fill 15 (real block guard time = 16) to this field and in T=1 mode software must fill 21 (real block guard time = 22) to it.
N     * |        |          |In TX mode, hardware will auto hold off first character until BGT has elapsed regardless of the TX data.
N     * |        |          |In RX mode, software can enable SC_ALTCTL [RX_BGT_EN] to detect the first coming character timing.
N     * |        |          |If the incoming data timing less than BGT, an interrupt will be generated.
N     * |        |          |Note: The real block guard time is BGT + 1.
N     * |[14:13] |TMR_SEL   |Timer Selection
N     * |        |          |00 = Disable all internal timer function.
N     * |        |          |01 = Enable internal 24 bit timer.
N     * |        |          |Software can configure it by setting SC_TMR0 [23:0].
N     * |        |          |SC_TMR1 and SC_TMR2 will be ignored in this mode.
N     * |        |          |10 = Enable internal 24 bit timer and 8 bit internal timer.
N     * |        |          |Software can configure the 24 bit timer by setting SC_TMR0 [23:0] and configure the 8 bit timer by setting SC_TMR1 [7:0].
N     * |        |          |SC_TMR2 will be ignored in this mode.
N     * |        |          |11 = Enable internal 24 bit timer and two 8 bit timers.
N     * |        |          |Software can configure them by setting SC_TMR0 [23:0], SC_TMR1 [7:0] and SC_TMR2 [7:0].
N     * |[15]    |SLEN      |Stop Bit Length
N     * |        |          |This field indicates the length of stop bit.
N     * |        |          |0 = The stop bit length is 2 ETU.
N     * |        |          |1 = The stop bit length is 1 ETU.
N     * |        |          |Note: The default stop bit length is 2.
N     * |[18:16] |RX_ERETRY |RX Error Retry Register
N     * |        |          |This field indicates the maximum number of receiver retries that are allowed when parity error has occurred.
N     * |        |          |Note1: The real maximum retry number is RX_ERETRY + 1, so 8 is the maximum retry number.
N     * |        |          |Note2: This field can not be changed when RX_ERETRY_EN enabled.
N     * |        |          |The change flow is to disable RX_ETRTRY_EN first and then fill new retry value.
N     * |[19]    |RX_ERETRY_EN|RX Error Retry Enable Register
N     * |        |          |This bit enables receiver retry function when parity error has occurred.
N     * |        |          |0 = RX error retry function Disabled.
N     * |        |          |1 = RX error retry function Enabled.
N     * |        |          |Note: User must fill RX_ERETRY value before enabling this bit.
N     * |[22:20] |TX_ERETRY |TX Error Retry Register
N     * |        |          |This field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.
N     * |        |          |Note1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.
N     * |        |          |Note2: This field can not be changed when TX_ERETRY_EN enabled.
N     * |        |          |The change flow is to disable TX_ETRTRY_EN first and then fill new retry value.
N     * |[23]    |TX_ERETRY_EN|TX Error Retry Enable Register
N     * |        |          |This bit enables transmitter retry function when parity error has occurred.
N     * |        |          |0 = TX error retry function Disabled.
N     * |        |          |1 = TX error retry function Enabled.
N     * |        |          |Note: User must fill TX_ERETRY value before enabling this bit.
N     * |[25:24] |CD_DEB_SEL|Card Detect De-Bounce Select Register
N     * |        |          |This field indicates the card detect de-bounce selection.
N     * |        |          |This field indicates the card detect de-bounce selection.
N     * |        |          |00 = De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card removal once per 128 engine clocks.
N     * |        |          |01 = De-bounce sample card insert once per 192 (64 * 3) engine clocks and de-bounce sample card removal once per 64 engine clocks.
N     * |        |          |10 = De-bounce sample card insert once per 96 (32 * 3) engine clocks and de-bounce sample card removal once per 32 engine clocks.
N     * |        |          |11 = De-bounce sample card insert once per 48 (16 * 3) engine clocks and de-bounce sample card removal once per 16 engine clocks.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * ALTCTL
N     * ===================================================================================================
N     * Offset: 0x08  SC Alternate Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TX_RST    |TX Software Reset
N     * |        |          |When TX_RST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the TX internal state machine and pointers.
N     * |        |          |Note: This bit will be auto cleared and needs at least 3 SC engine clock cycles.
N     * |[1]     |RX_RST    |RX Software Reset
N     * |        |          |When RX_RST is set, all the bytes in the receiver buffer and RX internal state machine will be cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the RX internal state machine and pointers.
N     * |        |          |Note: This bit will be auto cleared and needs at least 3 SC engine clock cycles.
N     * |[2]     |DACT_EN   |Deactivation Sequence Generator Enable
N     * |        |          |This bit enables SC controller to initiate the card by deactivation sequence
N     * |        |          |0 = No effect.
N     * |        |          |1 = Deactivation sequence generator Enabled.
N     * |        |          |Note1: When the deactivation sequence completed, this bit will be cleared automatically and the SC_ISR [INIT_IS] will be set to "1".
N     * |        |          |Note2: This field will be cleared by TX_RST and RX_RST.
N     * |        |          |So don't fill this bit, TX_RST, and RX_RST at the same time.
N     * |        |          |Note3: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.
N     * |[3]     |ACT_EN    |Activation Sequence Generator Enable
N     * |        |          |This bit enables SC controller to initiate the card by activation sequence
N     * |        |          |0 = No effect.
N     * |        |          |1 = Activation sequence generator Enabled.
N     * |        |          |Note1: When the activation sequence completed, this bit will be cleared automatically and the SC_IS [INIT_IS] will be set to "1".
N     * |        |          |Note2: This field will be cleared by TX_RST and RX_RST, so don't fill this bit, TX_RST, and RX_RST at the same time.
N     * |        |          |Note3: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.
N     * |[4]     |WARST_EN  |Warm Reset Sequence Generator Enable
N     * |        |          |This bit enables SC controller to initiate the card by warm reset sequence
N     * |        |          |0 = No effect.
N     * |        |          |1 = Warm reset sequence generator Enabled.
N     * |        |          |Note1: When the warm reset sequence completed, this bit will be cleared automatically and the SC_ISR [INIT_IS] will be set to "1".
N     * |        |          |Note2: This field will be cleared by TX_RST and RX_RST, so don't fill this bit, TX_RST, and RX_RST at the same time.
N     * |        |          |Note3: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.
N     * |[5]     |TMR0_SEN  |Internal Timer0 Start Enable
N     * |        |          |This bit enables Timer0 to start counting.
N     * |        |          |Software can fill "0" to stop it and set "1" to reload and count.
N     * |        |          |0 = Stops counting.
N     * |        |          |1 = Starts counting.
N     * |        |          |Note1: This field is used for internal 24 bit timer when SC_CTL [TMR_SEL] = 01.
N     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_TMR0 [26] = "0"), this bit will be auto-cleared by hardware.
N     * |        |          |Note3: This field will be cleared by TX_RST and RX_RST.
N     * |        |          |So don't fill this bit, TX_RST and RX_RST at the same time.
N     * |        |          |Note4: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.
N     * |[6]     |TMR1_SEN  |Internal Timer1 Start Enable
N     * |        |          |This bit enables Timer "1" to start counting.
N     * |        |          |Software can fill 0 to stop it and set "1" to reload and count.
N     * |        |          |0 = Stops counting.
N     * |        |          |1 = Starts counting.
N     * |        |          |Note1: This field is used for internal 8-bit timer when SC_CTL [TMR_SEL] = 01 or 10.
N     * |        |          |Don't filled TMR1_SEN when SC_CTL [TMR_SEL] = 00 or 11.
N     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_TMR1 [26] = "0"), this bit will be auto-cleared by hardware.
N     * |        |          |Note3: This field will be cleared by TX_RST and RX_RST, so don't fill this bit, TX_RST, and RX_RST at the same time.
N     * |        |          |Note4: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.
N     * |[7]     |TMR2_SEN  |Internal Timer2 Start Enable
N     * |        |          |This bit enables Timer2 to start counting.
N     * |        |          |Software can fill "0" to stop it and set "1" to reload and count.
N     * |        |          |0 = Stops counting.
N     * |        |          |1 = Starts counting.
N     * |        |          |Note1: This field is used for internal 8-bit timer when SC_CTL [TMR_SEL] == 11.
N     * |        |          |Don't filled TMR2_SEN when SC_CTL [TMR_SEL] == 00 or 01 or 10.
N     * |        |          |Note2: If the operation mode is not in auto-reload mode (SC_TMR2 [26] = "0"), this bit will be auto-cleared by hardware.
N     * |        |          |Note3: This field will be cleared by TX_RST and RX_RST.
N     * |        |          |So don't fill this bit, TX_RST, and RX_RST at the same time.
N     * |        |          |Note4: If SC_CTL [SC_CEN] is not enabled, this filed can not be programmed.
N     * |[9:8]   |INIT_SEL  |Initial Timing Selection
N     * |        |          |This field indicates the timing of hardware initial state (activation or warm-reset or deactivation).
N     * |[12]    |RX_BGT_EN |Receiver Block Guard Time Function Enable
N     * |        |          |0 = Receiver block guard time function Disabled.
N     * |        |          |1 = Receiver block guard time function Enabled.
N     * |[13]    |TMR0_ATV  |Internal Timer0 Active State (Read Only)
N     * |        |          |This bit indicates the timer counter status of timer0.
N     * |        |          |0 = Timer0 is not active.
N     * |        |          |1 = Timer0 is active.
N     * |[14]    |TMR1_ATV  |Internal Timer1 Active State (Read Only)
N     * |        |          |This bit indicates the timer counter status of timer1.
N     * |        |          |0 = Timer1 is not active.
N     * |        |          |1 = Timer1 is active.
N     * |[15]    |TMR2_ATV  |Internal Timer2 Active State (Read Only)
N     * |        |          |This bit indicates the timer counter status of timer2.
N     * |        |          |0 = Timer2 is not active.
N     * |        |          |1 = Timer2 is active.
N    */
N    __IO uint32_t ALTCTL;
X    volatile uint32_t ALTCTL;
N
N    /**
N     * EGTR
N     * ===================================================================================================
N     * Offset: 0x0C  SC Extend Guard Time Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |EGT       |Extended Guard Time
N     * |        |          |This field indicates the extended guard timer value.
N     * |        |          |Note: The counter is ETU based and the real extended guard time is EGT.
N    */
N    __IO uint32_t EGTR;
X    volatile uint32_t EGTR;
N
N    /**
N     * RFTMR
N     * ===================================================================================================
N     * Offset: 0x10  SC Receive Buffer Time-Out Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |RFTM      |SC Receiver Buffer Time-Out Register (ETU Based)
N     * |        |          |The time-out counter resets and starts counting whenever the RX buffer received a new data word.
N     * |        |          |Once the counter decrease to "1" and no new data is received or CPU does not read data by reading SC_RBR register, a receiver time-out interrupt INT_RTMR will be generated(if SC_IER[RTMR_IE] is high).
N     * |        |          |Note1: The counter is ETU based and the real count value is RFTM + 1
N     * |        |          |Note2: Fill all "0" to this field to disable this function.
N    */
N    __IO uint32_t RFTMR;
X    volatile uint32_t RFTMR;
N
N    /**
N     * ETUCR
N     * ===================================================================================================
N     * Offset: 0x14  SC ETU Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |ETU_RDIV  |ETU Rate Divider
N     * |        |          |The field indicates the clock rate divider.
N     * |        |          |The real ETU is ETU_RDIV + 1.
N     * |        |          |Note1: Software can configure this field, but this field must be greater than 0x04.
N     * |        |          |Note2: Software can configure this field, but if the error rate is equal to 2%, this field must be greater than 0x040.
N     * |[15]    |COMPEN_EN |Compensation Mode Enable
N     * |        |          |This bit enables clock compensation function.
N     * |        |          |When this bit enabled, hardware will alternate between n clock cycles and (n-1) clock cycles, where n is the value to be written into the ETU_RDIV register.
N     * |        |          |0 = Compensation function Disabled.
N     * |        |          |1 = Compensation function Enabled.
N    */
N    __IO uint32_t ETUCR;
X    volatile uint32_t ETUCR;
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x18  SC Interrupt Enable Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IE    |Receive Data Reach Interrupt Enable
N     * |        |          |This field is used for received data reaching trigger level (SC_CTL [RX_FTRI_LEV]) interrupt enable.
N     * |        |          |0 = INT_RDR Disabled.
N     * |        |          |1 = INT_RDR Enabled.
N     * |[1]     |TBE_IE    |Transmit Buffer Empty Interrupt Enable
N     * |        |          |This field is used for transmit buffer empty interrupt enable.
N     * |        |          |0 = INT_THRE Disabled.
N     * |        |          |1 = INT_THRE Enabled.
N     * |[2]     |TERR_IE   |Transfer Error Interrupt Enable
N     * |        |          |This field is used for transfer error interrupt enable.
N     * |        |          |The transfer error states is at SC_TRSR register which includes receiver break error (RX_EBR_F), frame error (RX_EFR_F), parity error (RX_EPA_F), receiver buffer overflow error (RX_OVER_F), transmit buffer overflow error (TX_OVER_F), receiver retry over limit error (RX_OVER_ERETRY) and transmitter retry over limit error (TX_OVER_ERETRY).
N     * |        |          |0 = INT_TERR Disabled.
N     * |        |          |1 = INT_TERR Enabled.
N     * |[3]     |TMR0_IE   |Timer0 Interrupt Enable
N     * |        |          |This field is used for TMR0 interrupt enable.
N     * |        |          |0 = INT_TMR0 Disabled.
N     * |        |          |1 = INT_TMR0 Enabled.
N     * |[4]     |TMR1_IE   |Timer1 Interrupt Enable
N     * |        |          |This field is used for TMR1 interrupt enable.
N     * |        |          |0 = INT_TMR1 Disabled.
N     * |        |          |1 = INT_TMR1 Enabled.
N     * |[5]     |TMR2_IE   |Timer2 Interrupt Enable
N     * |        |          |This field is used for TMR2 interrupt enable.
N     * |        |          |0 = INT_TMR2 Disabled.
N     * |        |          |1 = INT_TMR2 Enabled.
N     * |[6]     |BGT_IE    |Block Guard Time Interrupt Enable
N     * |        |          |This field is used for block guard time interrupt enable.
N     * |        |          |0 = INT_BGT Disabled.
N     * |        |          |1 = INT_BGT Enabled.
N     * |[7]     |CD_IE     |Card Detect Interrupt Enable
N     * |        |          |This field is used for card detect interrupt enable.
N     * |        |          |The card detect status register is SC_PINCSR [CD_CH] and SC_PINCSR[CD_CL].
N     * |        |          |0 = INT_CD Disabled.
N     * |        |          |1 = INT_CD Enabled.
N     * |[8]     |INIT_IE   |Initial End Interrupt Enable
N     * |        |          |This field is used for activation (SC_ALTCTL [ACT_EN]), deactivation (SC_ALTCTL [DACT_EN]) and warm reset (SC_ALTCTL [WARST_EN]) sequence interrupt enable.
N     * |        |          |0 = INT_INIT Disabled.
N     * |        |          |1 = INT_INIT Enabled.
N     * |[9]     |RTMR_IE   |Receiver Buffer Time-Out Interrupt Enable
N     * |        |          |This field is used for receiver buffer time-out interrupt enable.
N     * |        |          |0 = INT_RTMR Disabled.
N     * |        |          |1 = INT_RTMR Enabled.
N     * |[10]    |ACON_ERR_IE|Auto Convention Error Interrupt Enable
N     * |        |          |This field is used for auto convention error interrupt enable.
N     * |        |          |0 = INT_ACON_ERR Disabled.
N     * |        |          |1 = INT_ACON_ERR Enabled.
N    */
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N
N    /**
N     * ISR
N     * ===================================================================================================
N     * Offset: 0x1C  SC Interrupt Status Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IS    |Receive Data Reach Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for received data reaching trigger level (SC_CTL [RX_FTRI_LEV]) interrupt status flag.
N     * |        |          |Note: This field is the status flag of received data reaching SC_CTL [RX_FTRI_LEV].
N     * |        |          |If software reads data from SC_RBR and receiver pointer is less than SC_CTL [RX_FTRI_LEV], this bit will be cleared automatically.
N     * |[1]     |TBE_IS    |Transmit Buffer Empty Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for transmit buffer empty interrupt status flag.
N     * |        |          |This bit is different with SC_TRSR [TX_EMPTY_F] flag and SC_TRSR [TX_ATV] flag; The TX_EMPTY_F will be set when the last byte data be read to shift register and TX_ATV flag indicates the transmitter is in active or not (the last data has been transmitted or not), but the TBE_IS may be set when the last byte data be read to shift register or the last data has been transmitted.
N     * |        |          |When this bit assert, software can write 1~4 byte data to SC_THR register.
N     * |        |          |Note: If software wants to clear this bit, software must write data to SC_THR register and then this bit will be cleared automatically.
N     * |[2]     |TERR_IS   |Transfer Error Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for transfer error interrupt status flag.
N     * |        |          |The transfer error states is at SC_TRSR register which includes receiver break error (RX_EBR_F), frame error (RX_EFR_F), parity error (RX_EPA_F) and receiver buffer overflow error (RX_OVER_F), transmit buffer overflow error (TX_OVER_F), receiver retry over limit error (RX_OVER_ERETRY) and transmitter retry over limit error (TX_OVER_ERETRY).
N     * |        |          |Note: This field is the status flag of SC_TRSR [RX_EBR_F], SC_TRSR [RX_EFR_F], SC_TRSR [RX_EPA_F], SC_TRSR [RX_OVER_F], SC_TRSR [TX_OVER_F], SC_TRSR [RX_OVER_ERETRY] or SC_TRSR [TX_OVER_ERETRY].
N     * |        |          |So if software wants to clear this bit, software must write "1" to each field.
N     * |[3]     |TMR0_IS   |Timer0 Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for TMR0 interrupt status flag.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[4]     |TMR1_IS   |Timer1 Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for TMR1 interrupt status flag.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[5]     |TMR2_IS   |Timer2 Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for TMR2 interrupt status flag.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[6]     |BGT_IS    |Block Guard Time Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for block guard time interrupt status flag.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[7]     |CD_IS     |Card Detect Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for card detect interrupt status flag.
N     * |        |          |The card detect status register is SC_PINCSR [CD_INS_F] and SC_PINCSR [CD_REM_F].
N     * |        |          |Note: This field is the status flag of SC_PINCSR [CD_INS_F] or SC_PINCSR [CD_REM_F].
N     * |        |          |So if software wants to clear this bit, software must write "1" to this field.
N     * |[8]     |INIT_IS   |Initial End Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for activation (SC_ALTCTL [ACT_EN]), deactivation (SC_ALTCTL [DACT_EN]) and warm reset (SC_ALTCTL [WARST_EN]) sequence interrupt status flag.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[9]     |RTMR_IS   |Receiver Buffer Time-Out Interrupt Status Flag (Read Only)
N     * |        |          |This field is used for receiver buffer time-out interrupt status flag.
N     * |        |          |Note: This field is the status flag of receiver buffer time-out state.
N     * |        |          |If software wants to clear this bit, software must read the receiver buffer remaining data by reading SC_RBR register,.
N     * |[10]    |ACON_ERR_IS|Auto Convention Error Interrupt Status Flag (Read Only)
N     * |        |          |This field indicates auto convention sequence error.
N     * |        |          |If the received TS at ATR state is not 0x3B or 0x3F, this bit will be set.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N    */
N    __IO uint32_t ISR;
X    volatile uint32_t ISR;
N
N    /**
N     * TRSR
N     * ===================================================================================================
N     * Offset: 0x20  SC Transfer Status Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_OVER_F |RX Overflow Error Status Flag (Read Only)
N     * |        |          |This bit is set when RX buffer overflow.
N     * |        |          |If the number of received bytes is greater than RX Buffer (SC_RBR) size, 4 bytes of SC, this bit will be set.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2: The overwrite data will be ignored.
N     * |[1]     |RX_EMPTY_F|Receiver Buffer Empty Status Flag(Read Only)
N     * |        |          |This bit indicates RX buffer empty or not.
N     * |        |          |When the last byte of RX buffer has been read by CPU, hardware sets this bit high.
N     * |        |          |It will be cleared when SC receives any new data.
N     * |[2]     |RX_FULL_F |Receiver Buffer Full Status Flag (Read Only)
N     * |        |          |This bit indicates RX buffer full or not.
N     * |        |          |This bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
N     * |[4]     |RX_EPA_F  |Receiver Parity Error Status Flag (Read Only)
N     * |        |          |This bit is set to logic "1" whenever the received character does not have a valid "parity bit".
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2: If CPU sets receiver retries function by setting SC_CTL [RX_ERETRY_EN] register, hardware will not set this flag.
N     * |[5]     |RX_EFR_F  |Receiver Frame Error Status Flag (Read Only)
N     * |        |          |This bit is set to logic "1" whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic "0").
N     * |        |          |Note1: This bit is read only, but can be cleared by writing "1" to it.
N     * |        |          |Note2: If CPI sets receiver retries function by setting SC_CTL [RX_ERETRY_EN] register, hardware will not set this flag.
N     * |[6]     |RX_EBR_F  |Receiver Break Error Status Flag (Read Only)
N     * |        |          |This bit is set to a logic "1" whenever the received data input (RX) held in the "spacing state" (logic "0") is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2: If CPU sets receiver retries function by setting SC_CTL [RX_ERETRY_EN] register, hardware will not set this flag.
N     * |[8]     |TX_OVER_F |TX Overflow Error Interrupt Status Flag (Read Only)
N     * |        |          |If TX buffer is full (TX_FULL_F = "1"), an additional write data to SC_THR will cause this bit to logic "1".
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2: The additional write data will be ignored.
N     * |[9]     |TX_EMPTY_F|Transmit Buffer Empty Status Flag (Read Only)
N     * |        |          |This bit indicates TX buffer empty or not.
N     * |        |          |When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high.
N     * |        |          |It will be cleared when writing data into SC_THR (TX buffer not empty).
N     * |[10]    |TX_FULL_F |Transmit Buffer Full Status Flag (Read Only)
N     * |        |          |This bit indicates TX buffer full or not.
N     * |        |          |This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.
N     * |[18:16] |RX_POINT_F|Receiver Buffer Pointer Status Flag (Read Only)
N     * |        |          |This field indicates the RX buffer pointer status flag.
N     * |        |          |When SC receives one byte from external device, RX_POINT_F increases one.
N     * |        |          |When one byte of RX buffer is read by CPU, RX_POINT_F decreases one.
N     * |[21]    |RX_REERR  |Receiver Retry Error (Read Only)
N     * |        |          |This bit is set by hardware when RX has any error and retries transfer.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2 This bit is a flag and can not generate any interrupt to CPU.
N     * |        |          |Note3: If CPU enables receiver retry function by setting SC_CTL [RX_ERETRY_EN] register, the RX_EPA_F flag will be ignored (hardware will not set RX_EPA_F).
N     * |[22]    |RX_OVER_ERETRY|Receiver Over Retry Error (Read Only)
N     * |        |          |This bit is set by hardware when RX transfer error retry over retry number limit.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2: If CPU enables receiver retries function by setting SC_CTL [RX_ERETRY_EN] register, the RX_EPA_F flag will be ignored (hardware will not set RX_EPA_F).
N     * |[23]    |RX_ATV    |Receiver In Active Status Flag (Read Only)
N     * |        |          |This bit is set by hardware when RX transfer is in active.
N     * |        |          |This bit is cleared automatically when RX transfer is finished.
N     * |[26:24] |TX_POINT_F|Transmit Buffer Pointer Status Flag (Read Only)
N     * |        |          |This field indicates the TX buffer pointer status flag.
N     * |        |          |When CPU writes data into SC_THR, TX_POINT_F increases one.
N     * |        |          |When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F decreases one.
N     * |[29]    |TX_REERR  |Transmitter Retry Error (Read Only)
N     * |        |          |This bit is set by hardware when transmitter re-transmits.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2 This bit is a flag and can not generate any interrupt to CPU.
N     * |[30]    |TX_OVER_ERETRY|Transmitter Over Retry Error (Read Only)
N     * |        |          |This bit is set by hardware when transmitter re-transmits over retry number limitation.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[31]    |TX_ATV    |Transmit In Active Status Flag (Read Only)
N     * |        |          |This bit is set by hardware when TX transfer is in active or the last byte transmission has not completed.
N     * |        |          |This bit is cleared automatically when TX transfer is finished and the STOP bit (include guard time) has been transmitted.
N    */
N    __IO uint32_t TRSR;
X    volatile uint32_t TRSR;
N
N    /**
N     * PINCSR
N     * ===================================================================================================
N     * Offset: 0x24  SC Pin Control State Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |POW_EN    |SC_POW_EN Pin Signal
N     * |        |          |This bit is the pin status of SC_POW_EN but user can drive SC_POW_EN pin to high or low by setting this bit.
N     * |        |          |0 = Drive SC_POW_EN pin to low.
N     * |        |          |1 = Drive SC_POW_EN pin to high.
N     * |        |          |Note: When operation at activation, warm reset or deactivation mode, this bit will be changed automatically.
N     * |        |          |So don't fill this field When operating in these modes.
N     * |[1]     |SC_RST    |SC_RST Pin Signal
N     * |        |          |This bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.
N     * |        |          |0 = Drive SC_RST pin to low.
N     * |        |          |1 = Drive SC_RST pin to high.
N     * |        |          |Note: When operation at activation, warm reset or deactivation mode, this bit will be changed automatically.
N     * |        |          |So don't fill this field When operating in these modes.
N     * |[2]     |CD_REM_F  |Card Detect Removal Status Of SC_CD Pin (Read Only)
N     * |        |          |This bit is set whenever card has been removal.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Card Removal.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2: Card detect engine will start after SC_CTL [SC_CEN] set.
N     * |[3]     |CD_INS_F  |Card Detect Insert Status Of SC_CD Pin (Read Only)
N     * |        |          |This bit is set whenever card has been inserted.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Card insert.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2: Card detect engine will start after SC_CTL [SC_CEN] set.
N     * |[4]     |CD_PIN_ST |Card Detect Status Of SC_CD Pin Status (Read Only)
N     * |        |          |This bit is the pin status flag of SC_CD
N     * |        |          |0 = SC_CD pin state at low.
N     * |        |          |1 = SC_CD pin state at high.
N     * |[6]     |CLK_KEEP  |SC Clock Enable
N     * |        |          |0 = SC clock generation Disabled.
N     * |        |          |1 = SC clock always keeps free running.
N     * |        |          |Note: When operation at activation, warm reset or deactivation mode, this bit will be changed automatically.
N     * |        |          |So don't fill this field when operation in these modes.
N     * |[7]     |ADAC_CD_EN|Auto Deactivation When Card Removal
N     * |        |          |0 = Auto deactivation Disabled when hardware detected the card is removal.
N     * |        |          |1 = Auto deactivation Enabled when hardware detected the card is removal.
N     * |        |          |Note1: When the card is removal, hardware will stop any process and then do deactivation sequence (if this bit be setting).
N     * |        |          |If this process completes.
N     * |        |          |Hardware will generate an interrupt INT_INIT to CPU.
N     * |[8]     |SC_OEN_ST |SC Data Pin Output Enable Status (Read Only)
N     * |        |          |0 = SC data output enable pin status is at low.
N     * |        |          |1 = SC data output enable pin status is at high.
N     * |[9]     |SC_DATA_O |Output Of SC Data Pin
N     * |        |          |This bit is the pin status of SC data output but user can drive this pin to high or low by setting this bit.
N     * |        |          |0 = Drive SC data output pin to low.
N     * |        |          |1 = Drive SC data output pin to high.
N     * |        |          |Note: When SC is at activation, warm re set or deactivation mode, this bit will be changed automatically.
N     * |        |          |So don't fill this field when SC is in these modes.
N     * |[10]    |CD_LEV    |Card Detect Level
N     * |        |          |0 = When hardware detects the card detect pin from high to low, it indicates a card is detected.
N     * |        |          |1 = When hardware detects the card detect pin from low to high, it indicates a card is detected.
N     * |        |          |Note: Software must select card detect level before Smart Card engine enable
N     * |[11]    |POW_INV   |SC_POW Pin Inverse
N     * |        |          |This bit is used for inverse the SC_POW pin.
N     * |        |          |There  are  four  kinds  of  combination  for  SC_POW  pin  setting  by  POW_INV  and
N     * |        |          |POW_EN(SC_PINCSR[0]). POW_INV is bit 1 and POW_EN is bit 0 for SC_POW_Pin as
N     * |        |          |high or low voltage selection.
N     * |        |          |POW_INV is 0 and POW_EN is 0, than SC_POW Pin output 0.
N     * |        |          |POW_INV is 0 and POW_EN is 1, than SC_POW Pin output 1.
N     * |        |          |POW_INV is 1 and POW_EN is 0, than SC_POW Pin output 1.
N     * |        |          |POW_INV is 1 and POW_EN is 1, than SC_POW Pin output 0.
N     * |        |          |Note:  Software  must  select  POW_INV  before  Smart  Card  is  enabled  by  SC_CEN (SC_CTL[0])
N     * |[16]    |SC_DATA_I_ST|SC Data Input Pin Status (Read Only)
N     * |        |          |This bit is the pin status of SC_DATA_I
N     * |        |          |0 = The SC_DATA_I pin is low.
N     * |        |          |1 = The SC_DATA_I pin is high.
N    */
N    __IO uint32_t PINCSR;
X    volatile uint32_t PINCSR;
N
N    /**
N     * TMR0
N     * ===================================================================================================
N     * Offset: 0x28  SC Internal Timer Control Register 0.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CNT       |Timer 0 Counter Value Register (ETU Base)
N     * |        |          |This field indicates the internal timer operation values.
N     * |[27:24] |MODE      |Timer 0 Operation Mode Selection
N     * |        |          |This field indicates the internal 24 bit timer operation selection.
N    */
N    __IO uint32_t TMR0;
X    volatile uint32_t TMR0;
N
N    /**
N     * TMR1
N     * ===================================================================================================
N     * Offset: 0x2C  SC Internal Timer Control Register 1.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CNT       |Timer 1 Counter Value Register (ETU Base)
N     * |        |          |This field indicates the internal timer operation values.
N     * |[27:24] |MODE      |Timer 1 Operation Mode Selection
N     * |        |          |This field indicates the internal 8 bit timer operation selection.
N    */
N    __IO uint32_t TMR1;
X    volatile uint32_t TMR1;
N
N    /**
N     * TMR2
N     * ===================================================================================================
N     * Offset: 0x30  SC Internal Timer Control Register 2.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CNT       |Timer 2 Counter Value Register (ETU Base)
N     * |        |          |This field indicates the internal timer operation values.
N     * |[27:24] |MODE      |Timer 2 Operation Mode Selection
N     * |        |          |This field indicates the internal 8 bit timer operation selection.
N    */
N    __IO uint32_t TMR2;
X    volatile uint32_t TMR2;
N
N    /**
N     * UACTL
N     * ===================================================================================================
N     * Offset: 0x34  SC UART Mode Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |UA_MODE_EN|UART Mode Enable
N     * |        |          |0 = Smart Card mode.
N     * |        |          |1 = UART mode.
N     * |        |          |Note1: When operating in UART mode, user must set SCx_CTL [CON_SEL] and SCx_CTL [AUTO_CON_EN] to "0".
N     * |        |          |Note2: When operating in smart card mode, user must set SCx_UACTL [7:0] register to "0".
N     * |        |          |Note3: When UART is enabled, hardware will generate a reset to reset internal buffer and internal state machine.
N     * |[5:4]   |DATA_LEN  |Data Length
N     * |        |          |00 = 8 bits
N     * |        |          |01 = 7 bits
N     * |        |          |10 = 6 bits
N     * |        |          |11 = 5 bits
N     * |        |          |Note: In Smart Card mode, this field must be '00'
N     * |[6]     |PBDIS     |Parity Bit Disable
N     * |        |          |0 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
N     * |        |          |1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
N     * |        |          |Note: In Smart Card mode, this field must be '0' (default setting is with parity bit)
N     * |[7]     |OPE       |Odd Parity Enable
N     * |        |          |0 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
N     * |        |          |1 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
N     * |        |          |Note: This bit has effect only when PBDIS bit is '0'.
N    */
N    __IO uint32_t UACTL;
X    volatile uint32_t UACTL;
N
N    /**
N     * TDRA
N     * ===================================================================================================
N     * Offset: 0x38  SC Timer Current Data Register A.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TDR0      |Timer0 Current Data Register (Read Only)
N     * |        |          |This field indicates the current count values of timer0.
N    */
N    __I  uint32_t TDRA;
X    volatile const  uint32_t TDRA;
N
N    /**
N     * TDRB
N     * ===================================================================================================
N     * Offset: 0x3C  SC Timer Current Data Register B.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |TDR1      |Timer1 Current Data Register (Read Only)
N     * |        |          |This field indicates the current count values of timer1.
N     * |[15:8]  |TDR2      |Timer2 Current Data Register (Read Only)
N     * |        |          |This field indicates the current count values of timer2.
N    */
N    __I  uint32_t TDRB;
X    volatile const  uint32_t TDRB;
N
N} SC_T;
N
N/**
N    @addtogroup SC_CONST SC Bit Field Definition
N    Constant Definitions for SC Controller
N@{ */
N
N#define SC_DAT_DAT_Pos                   (0)                                               /*!< SC_T::DAT: DAT Position                   */
N#define SC_DAT_DAT_Msk                   (0xfful << SC_DAT_DAT_Pos)                        /*!< SC_T::DAT: DAT Mask                       */
N
N#define SC_CTL_SC_CEN_Pos                (0)                                               /*!< SC_T::CTL: SC_CEN Position                */
N#define SC_CTL_SC_CEN_Msk                (0x1ul << SC_CTL_SC_CEN_Pos)                      /*!< SC_T::CTL: SC_CEN Mask                    */
N
N#define SC_CTL_DIS_RX_Pos                (1)                                               /*!< SC_T::CTL: DIS_RX Position                */
N#define SC_CTL_DIS_RX_Msk                (0x1ul << SC_CTL_DIS_RX_Pos)                      /*!< SC_T::CTL: DIS_RX Mask                    */
N
N#define SC_CTL_DIS_TX_Pos                (2)                                               /*!< SC_T::CTL: DIS_TX Position                */
N#define SC_CTL_DIS_TX_Msk                (0x1ul << SC_CTL_DIS_TX_Pos)                      /*!< SC_T::CTL: DIS_TX Mask                    */
N
N#define SC_CTL_AUTO_CON_EN_Pos           (3)                                               /*!< SC_T::CTL: AUTO_CON_EN Position           */
N#define SC_CTL_AUTO_CON_EN_Msk           (0x1ul << SC_CTL_AUTO_CON_EN_Pos)                 /*!< SC_T::CTL: AUTO_CON_EN Mask               */
N
N#define SC_CTL_CON_SEL_Pos               (4)                                               /*!< SC_T::CTL: CON_SEL Position               */
N#define SC_CTL_CON_SEL_Msk               (0x3ul << SC_CTL_CON_SEL_Pos)                     /*!< SC_T::CTL: CON_SEL Mask                   */
N
N#define SC_CTL_RX_FTRI_LEV_Pos           (6)                                               /*!< SC_T::CTL: RX_FTRI_LEV Position           */
N#define SC_CTL_RX_FTRI_LEV_Msk           (0x3ul << SC_CTL_RX_FTRI_LEV_Pos)                 /*!< SC_T::CTL: RX_FTRI_LEV Mask               */
N
N#define SC_CTL_BGT_Pos                   (8)                                               /*!< SC_T::CTL: BGT Position                   */
N#define SC_CTL_BGT_Msk                   (0x1ful << SC_CTL_BGT_Pos)                        /*!< SC_T::CTL: BGT Mask                       */
N
N#define SC_CTL_TMR_SEL_Pos               (13)                                              /*!< SC_T::CTL: TMR_SEL Position               */
N#define SC_CTL_TMR_SEL_Msk               (0x3ul << SC_CTL_TMR_SEL_Pos)                     /*!< SC_T::CTL: TMR_SEL Mask                   */
N
N#define SC_CTL_SLEN_Pos                  (15)                                              /*!< SC_T::CTL: SLEN Position                  */
N#define SC_CTL_SLEN_Msk                  (0x1ul << SC_CTL_SLEN_Pos)                        /*!< SC_T::CTL: SLEN Mask                      */
N
N#define SC_CTL_RX_ERETRY_Pos             (16)                                              /*!< SC_T::CTL: RX_ERETRY Position             */
N#define SC_CTL_RX_ERETRY_Msk             (0x7ul << SC_CTL_RX_ERETRY_Pos)                   /*!< SC_T::CTL: RX_ERETRY Mask                 */
N
N#define SC_CTL_RX_ERETRY_EN_Pos          (19)                                              /*!< SC_T::CTL: RX_ERETRY_EN Position          */
N#define SC_CTL_RX_ERETRY_EN_Msk          (0x1ul << SC_CTL_RX_ERETRY_EN_Pos)                /*!< SC_T::CTL: RX_ERETRY_EN Mask              */
N
N#define SC_CTL_TX_ERETRY_Pos             (20)                                              /*!< SC_T::CTL: TX_ERETRY Position             */
N#define SC_CTL_TX_ERETRY_Msk             (0x7ul << SC_CTL_TX_ERETRY_Pos)                   /*!< SC_T::CTL: TX_ERETRY Mask                 */
N
N#define SC_CTL_TX_ERETRY_EN_Pos          (23)                                              /*!< SC_T::CTL: TX_ERETRY_EN Position          */
N#define SC_CTL_TX_ERETRY_EN_Msk          (0x1ul << SC_CTL_TX_ERETRY_EN_Pos)                /*!< SC_T::CTL: TX_ERETRY_EN Mask              */
N
N#define SC_CTL_CD_DEB_SEL_Pos            (24)                                              /*!< SC_T::CTL: CD_DEB_SEL Position            */
N#define SC_CTL_CD_DEB_SEL_Msk            (0x3ul << SC_CTL_CD_DEB_SEL_Pos)                  /*!< SC_T::CTL: CD_DEB_SEL Mask                */
N
N#define SC_ALTCTL_TX_RST_Pos             (0)                                               /*!< SC_T::ALTCTL: TX_RST Position             */
N#define SC_ALTCTL_TX_RST_Msk             (0x1ul << SC_ALTCTL_TX_RST_Pos)                   /*!< SC_T::ALTCTL: TX_RST Mask                 */
N
N#define SC_ALTCTL_RX_RST_Pos             (1)                                               /*!< SC_T::ALTCTL: RX_RST Position             */
N#define SC_ALTCTL_RX_RST_Msk             (0x1ul << SC_ALTCTL_RX_RST_Pos)                   /*!< SC_T::ALTCTL: RX_RST Mask                 */
N
N#define SC_ALTCTL_DACT_EN_Pos            (2)                                               /*!< SC_T::ALTCTL: DACT_EN Position            */
N#define SC_ALTCTL_DACT_EN_Msk            (0x1ul << SC_ALTCTL_DACT_EN_Pos)                  /*!< SC_T::ALTCTL: DACT_EN Mask                */
N
N#define SC_ALTCTL_ACT_EN_Pos             (3)                                               /*!< SC_T::ALTCTL: ACT_EN Position             */
N#define SC_ALTCTL_ACT_EN_Msk             (0x1ul << SC_ALTCTL_ACT_EN_Pos)                   /*!< SC_T::ALTCTL: ACT_EN Mask                 */
N
N#define SC_ALTCTL_WARST_EN_Pos           (4)                                               /*!< SC_T::ALTCTL: WARST_EN Position           */
N#define SC_ALTCTL_WARST_EN_Msk           (0x1ul << SC_ALTCTL_WARST_EN_Pos)                 /*!< SC_T::ALTCTL: WARST_EN Mask               */
N
N#define SC_ALTCTL_TMR0_SEN_Pos           (5)                                               /*!< SC_T::ALTCTL: TMR0_SEN Position           */
N#define SC_ALTCTL_TMR0_SEN_Msk           (0x1ul << SC_ALTCTL_TMR0_SEN_Pos)                 /*!< SC_T::ALTCTL: TMR0_SEN Mask               */
N
N#define SC_ALTCTL_TMR1_SEN_Pos           (6)                                               /*!< SC_T::ALTCTL: TMR1_SEN Position           */
N#define SC_ALTCTL_TMR1_SEN_Msk           (0x1ul << SC_ALTCTL_TMR1_SEN_Pos)                 /*!< SC_T::ALTCTL: TMR1_SEN Mask               */
N
N#define SC_ALTCTL_TMR2_SEN_Pos           (7)                                               /*!< SC_T::ALTCTL: TMR2_SEN Position           */
N#define SC_ALTCTL_TMR2_SEN_Msk           (0x1ul << SC_ALTCTL_TMR2_SEN_Pos)                 /*!< SC_T::ALTCTL: TMR2_SEN Mask               */
N
N#define SC_ALTCTL_INIT_SEL_Pos           (8)                                               /*!< SC_T::ALTCTL: INIT_SEL Position           */
N#define SC_ALTCTL_INIT_SEL_Msk           (0x3ul << SC_ALTCTL_INIT_SEL_Pos)                 /*!< SC_T::ALTCTL: INIT_SEL Mask               */
N
N#define SC_ALTCTL_RX_BGT_EN_Pos          (12)                                              /*!< SC_T::ALTCTL: RX_BGT_EN Position          */
N#define SC_ALTCTL_RX_BGT_EN_Msk          (0x1ul << SC_ALTCTL_RX_BGT_EN_Pos)                /*!< SC_T::ALTCTL: RX_BGT_EN Mask              */
N
N#define SC_ALTCTL_TMR0_ATV_Pos           (13)                                              /*!< SC_T::ALTCTL: TMR0_ATV Position           */
N#define SC_ALTCTL_TMR0_ATV_Msk           (0x1ul << SC_ALTCTL_TMR0_ATV_Pos)                 /*!< SC_T::ALTCTL: TMR0_ATV Mask               */
N
N#define SC_ALTCTL_TMR1_ATV_Pos           (14)                                              /*!< SC_T::ALTCTL: TMR1_ATV Position           */
N#define SC_ALTCTL_TMR1_ATV_Msk           (0x1ul << SC_ALTCTL_TMR1_ATV_Pos)                 /*!< SC_T::ALTCTL: TMR1_ATV Mask               */
N
N#define SC_ALTCTL_TMR2_ATV_Pos           (15)                                              /*!< SC_T::ALTCTL: TMR2_ATV Position           */
N#define SC_ALTCTL_TMR2_ATV_Msk           (0x1ul << SC_ALTCTL_TMR2_ATV_Pos)                 /*!< SC_T::ALTCTL: TMR2_ATV Mask               */
N
N#define SC_EGTR_EGT_Pos                  (0)                                               /*!< SC_T::EGTR: EGT Position                  */
N#define SC_EGTR_EGT_Msk                  (0xfful << SC_EGTR_EGT_Pos)                       /*!< SC_T::EGTR: EGT Mask                      */
N
N#define SC_RFTMR_RFTM_Pos                (0)                                               /*!< SC_T::RFTMR: RFTM Position                */
N#define SC_RFTMR_RFTM_Msk                (0x1fful << SC_RFTMR_RFTM_Pos)                    /*!< SC_T::RFTMR: RFTM Mask                    */
N
N#define SC_ETUCR_ETU_RDIV_Pos            (0)                                               /*!< SC_T::ETUCR: ETU_RDIV Position            */
N#define SC_ETUCR_ETU_RDIV_Msk            (0xffful << SC_ETUCR_ETU_RDIV_Pos)                /*!< SC_T::ETUCR: ETU_RDIV Mask                */
N
N#define SC_ETUCR_COMPEN_EN_Pos           (15)                                              /*!< SC_T::ETUCR: COMPEN_EN Position           */
N#define SC_ETUCR_COMPEN_EN_Msk           (0x1ul << SC_ETUCR_COMPEN_EN_Pos)                 /*!< SC_T::ETUCR: COMPEN_EN Mask               */
N
N#define SC_IER_RDA_IE_Pos                (0)                                               /*!< SC_T::IER: RDA_IE Position                */
N#define SC_IER_RDA_IE_Msk                (0x1ul << SC_IER_RDA_IE_Pos)                      /*!< SC_T::IER: RDA_IE Mask                    */
N
N#define SC_IER_TBE_IE_Pos                (1)                                               /*!< SC_T::IER: TBE_IE Position                */
N#define SC_IER_TBE_IE_Msk                (0x1ul << SC_IER_TBE_IE_Pos)                      /*!< SC_T::IER: TBE_IE Mask                    */
N
N#define SC_IER_TERR_IE_Pos               (2)                                               /*!< SC_T::IER: TERR_IE Position               */
N#define SC_IER_TERR_IE_Msk               (0x1ul << SC_IER_TERR_IE_Pos)                     /*!< SC_T::IER: TERR_IE Mask                   */
N
N#define SC_IER_TMR0_IE_Pos               (3)                                               /*!< SC_T::IER: TMR0_IE Position               */
N#define SC_IER_TMR0_IE_Msk               (0x1ul << SC_IER_TMR0_IE_Pos)                     /*!< SC_T::IER: TMR0_IE Mask                   */
N
N#define SC_IER_TMR1_IE_Pos               (4)                                               /*!< SC_T::IER: TMR1_IE Position               */
N#define SC_IER_TMR1_IE_Msk               (0x1ul << SC_IER_TMR1_IE_Pos)                     /*!< SC_T::IER: TMR1_IE Mask                   */
N
N#define SC_IER_TMR2_IE_Pos               (5)                                               /*!< SC_T::IER: TMR2_IE Position               */
N#define SC_IER_TMR2_IE_Msk               (0x1ul << SC_IER_TMR2_IE_Pos)                     /*!< SC_T::IER: TMR2_IE Mask                   */
N
N#define SC_IER_BGT_IE_Pos                (6)                                               /*!< SC_T::IER: BGT_IE Position                */
N#define SC_IER_BGT_IE_Msk                (0x1ul << SC_IER_BGT_IE_Pos)                      /*!< SC_T::IER: BGT_IE Mask                    */
N
N#define SC_IER_CD_IE_Pos                 (7)                                               /*!< SC_T::IER: CD_IE Position                 */
N#define SC_IER_CD_IE_Msk                 (0x1ul << SC_IER_CD_IE_Pos)                       /*!< SC_T::IER: CD_IE Mask                     */
N
N#define SC_IER_INIT_IE_Pos               (8)                                               /*!< SC_T::IER: INIT_IE Position               */
N#define SC_IER_INIT_IE_Msk               (0x1ul << SC_IER_INIT_IE_Pos)                     /*!< SC_T::IER: INIT_IE Mask                   */
N
N#define SC_IER_RTMR_IE_Pos               (9)                                               /*!< SC_T::IER: RTMR_IE Position               */
N#define SC_IER_RTMR_IE_Msk               (0x1ul << SC_IER_RTMR_IE_Pos)                     /*!< SC_T::IER: RTMR_IE Mask                   */
N
N#define SC_IER_ACON_ERR_IE_Pos           (10)                                              /*!< SC_T::IER: ACON_ERR_IE Position           */
N#define SC_IER_ACON_ERR_IE_Msk           (0x1ul << SC_IER_ACON_ERR_IE_Pos)                 /*!< SC_T::IER: ACON_ERR_IE Mask               */
N
N#define SC_ISR_RDA_IS_Pos                (0)                                               /*!< SC_T::ISR: RDA_IS Position                */
N#define SC_ISR_RDA_IS_Msk                (0x1ul << SC_ISR_RDA_IS_Pos)                      /*!< SC_T::ISR: RDA_IS Mask                    */
N
N#define SC_ISR_TBE_IS_Pos                (1)                                               /*!< SC_T::ISR: TBE_IS Position                */
N#define SC_ISR_TBE_IS_Msk                (0x1ul << SC_ISR_TBE_IS_Pos)                      /*!< SC_T::ISR: TBE_IS Mask                    */
N
N#define SC_ISR_TERR_IS_Pos               (2)                                               /*!< SC_T::ISR: TERR_IS Position               */
N#define SC_ISR_TERR_IS_Msk               (0x1ul << SC_ISR_TERR_IS_Pos)                     /*!< SC_T::ISR: TERR_IS Mask                   */
N
N#define SC_ISR_TMR0_IS_Pos               (3)                                               /*!< SC_T::ISR: TMR0_IS Position               */
N#define SC_ISR_TMR0_IS_Msk               (0x1ul << SC_ISR_TMR0_IS_Pos)                     /*!< SC_T::ISR: TMR0_IS Mask                   */
N
N#define SC_ISR_TMR1_IS_Pos               (4)                                               /*!< SC_T::ISR: TMR1_IS Position               */
N#define SC_ISR_TMR1_IS_Msk               (0x1ul << SC_ISR_TMR1_IS_Pos)                     /*!< SC_T::ISR: TMR1_IS Mask                   */
N
N#define SC_ISR_TMR2_IS_Pos               (5)                                               /*!< SC_T::ISR: TMR2_IS Position               */
N#define SC_ISR_TMR2_IS_Msk               (0x1ul << SC_ISR_TMR2_IS_Pos)                     /*!< SC_T::ISR: TMR2_IS Mask                   */
N
N#define SC_ISR_BGT_IS_Pos                (6)                                               /*!< SC_T::ISR: BGT_IS Position                */
N#define SC_ISR_BGT_IS_Msk                (0x1ul << SC_ISR_BGT_IS_Pos)                      /*!< SC_T::ISR: BGT_IS Mask                    */
N
N#define SC_ISR_CD_IS_Pos                 (7)                                               /*!< SC_T::ISR: CD_IS Position                 */
N#define SC_ISR_CD_IS_Msk                 (0x1ul << SC_ISR_CD_IS_Pos)                       /*!< SC_T::ISR: CD_IS Mask                     */
N
N#define SC_ISR_INIT_IS_Pos               (8)                                               /*!< SC_T::ISR: INIT_IS Position               */
N#define SC_ISR_INIT_IS_Msk               (0x1ul << SC_ISR_INIT_IS_Pos)                     /*!< SC_T::ISR: INIT_IS Mask                   */
N
N#define SC_ISR_RTMR_IS_Pos               (9)                                               /*!< SC_T::ISR: RTMR_IS Position               */
N#define SC_ISR_RTMR_IS_Msk               (0x1ul << SC_ISR_RTMR_IS_Pos)                     /*!< SC_T::ISR: RTMR_IS Mask                   */
N
N#define SC_ISR_ACON_ERR_IS_Pos           (10)                                              /*!< SC_T::ISR: ACON_ERR_IS Position           */
N#define SC_ISR_ACON_ERR_IS_Msk           (0x1ul << SC_ISR_ACON_ERR_IS_Pos)                 /*!< SC_T::ISR: ACON_ERR_IS Mask               */
N
N#define SC_TRSR_RX_OVER_F_Pos            (0)                                               /*!< SC_T::TRSR: RX_OVER_F Position            */
N#define SC_TRSR_RX_OVER_F_Msk            (0x1ul << SC_TRSR_RX_OVER_F_Pos)                  /*!< SC_T::TRSR: RX_OVER_F Mask                */
N
N#define SC_TRSR_RX_EMPTY_F_Pos           (1)                                               /*!< SC_T::TRSR: RX_EMPTY_F Position           */
N#define SC_TRSR_RX_EMPTY_F_Msk           (0x1ul << SC_TRSR_RX_EMPTY_F_Pos)                 /*!< SC_T::TRSR: RX_EMPTY_F Mask               */
N
N#define SC_TRSR_RX_FULL_F_Pos            (2)                                               /*!< SC_T::TRSR: RX_FULL_F Position            */
N#define SC_TRSR_RX_FULL_F_Msk            (0x1ul << SC_TRSR_RX_FULL_F_Pos)                  /*!< SC_T::TRSR: RX_FULL_F Mask                */
N
N#define SC_TRSR_RX_EPA_F_Pos             (4)                                               /*!< SC_T::TRSR: RX_EPA_F Position             */
N#define SC_TRSR_RX_EPA_F_Msk             (0x1ul << SC_TRSR_RX_EPA_F_Pos)                   /*!< SC_T::TRSR: RX_EPA_F Mask                 */
N
N#define SC_TRSR_RX_EFR_F_Pos             (5)                                               /*!< SC_T::TRSR: RX_EFR_F Position             */
N#define SC_TRSR_RX_EFR_F_Msk             (0x1ul << SC_TRSR_RX_EFR_F_Pos)                   /*!< SC_T::TRSR: RX_EFR_F Mask                 */
N
N#define SC_TRSR_RX_EBR_F_Pos             (6)                                               /*!< SC_T::TRSR: RX_EBR_F Position             */
N#define SC_TRSR_RX_EBR_F_Msk             (0x1ul << SC_TRSR_RX_EBR_F_Pos)                   /*!< SC_T::TRSR: RX_EBR_F Mask                 */
N
N#define SC_TRSR_TX_OVER_F_Pos            (8)                                               /*!< SC_T::TRSR: TX_OVER_F Position            */
N#define SC_TRSR_TX_OVER_F_Msk            (0x1ul << SC_TRSR_TX_OVER_F_Pos)                  /*!< SC_T::TRSR: TX_OVER_F Mask                */
N
N#define SC_TRSR_TX_EMPTY_F_Pos           (9)                                               /*!< SC_T::TRSR: TX_EMPTY_F Position           */
N#define SC_TRSR_TX_EMPTY_F_Msk           (0x1ul << SC_TRSR_TX_EMPTY_F_Pos)                 /*!< SC_T::TRSR: TX_EMPTY_F Mask               */
N
N#define SC_TRSR_TX_FULL_F_Pos            (10)                                              /*!< SC_T::TRSR: TX_FULL_F Position            */
N#define SC_TRSR_TX_FULL_F_Msk            (0x1ul << SC_TRSR_TX_FULL_F_Pos)                  /*!< SC_T::TRSR: TX_FULL_F Mask                */
N
N#define SC_TRSR_RX_POINT_F_Pos           (16)                                              /*!< SC_T::TRSR: RX_POINT_F Position           */
N#define SC_TRSR_RX_POINT_F_Msk           (0x7ul << SC_TRSR_RX_POINT_F_Pos)                 /*!< SC_T::TRSR: RX_POINT_F Mask               */
N
N#define SC_TRSR_RX_REERR_Pos             (21)                                              /*!< SC_T::TRSR: RX_REERR Position             */
N#define SC_TRSR_RX_REERR_Msk             (0x1ul << SC_TRSR_RX_REERR_Pos)                   /*!< SC_T::TRSR: RX_REERR Mask                 */
N
N#define SC_TRSR_RX_OVER_ERETRY_Pos       (22)                                              /*!< SC_T::TRSR: RX_OVER_ERETRY Position       */
N#define SC_TRSR_RX_OVER_ERETRY_Msk       (0x1ul << SC_TRSR_RX_OVER_ERETRY_Pos)             /*!< SC_T::TRSR: RX_OVER_ERETRY Mask           */
N
N#define SC_TRSR_RX_ATV_Pos               (23)                                              /*!< SC_T::TRSR: RX_ATV Position               */
N#define SC_TRSR_RX_ATV_Msk               (0x1ul << SC_TRSR_RX_ATV_Pos)                     /*!< SC_T::TRSR: RX_ATV Mask                   */
N
N#define SC_TRSR_TX_POINT_F_Pos           (24)                                              /*!< SC_T::TRSR: TX_POINT_F Position           */
N#define SC_TRSR_TX_POINT_F_Msk           (0x7ul << SC_TRSR_TX_POINT_F_Pos)                 /*!< SC_T::TRSR: TX_POINT_F Mask               */
N
N#define SC_TRSR_TX_REERR_Pos             (29)                                              /*!< SC_T::TRSR: TX_REERR Position             */
N#define SC_TRSR_TX_REERR_Msk             (0x1ul << SC_TRSR_TX_REERR_Pos)                   /*!< SC_T::TRSR: TX_REERR Mask                 */
N
N#define SC_TRSR_TX_OVER_ERETRY_Pos       (30)                                              /*!< SC_T::TRSR: TX_OVER_ERETRY Position       */
N#define SC_TRSR_TX_OVER_ERETRY_Msk       (0x1ul << SC_TRSR_TX_OVER_ERETRY_Pos)             /*!< SC_T::TRSR: TX_OVER_ERETRY Mask           */
N
N#define SC_TRSR_TX_ATV_Pos               (31)                                              /*!< SC_T::TRSR: TX_ATV Position               */
N#define SC_TRSR_TX_ATV_Msk               (0x1ul << SC_TRSR_TX_ATV_Pos)                     /*!< SC_T::TRSR: TX_ATV Mask                   */
N
N#define SC_PINCSR_POW_EN_Pos             (0)                                               /*!< SC_T::PINCSR: POW_EN Position             */
N#define SC_PINCSR_POW_EN_Msk             (0x1ul << SC_PINCSR_POW_EN_Pos)                   /*!< SC_T::PINCSR: POW_EN Mask                 */
N
N#define SC_PINCSR_SC_RST_Pos             (1)                                               /*!< SC_T::PINCSR: SC_RST Position             */
N#define SC_PINCSR_SC_RST_Msk             (0x1ul << SC_PINCSR_SC_RST_Pos)                   /*!< SC_T::PINCSR: SC_RST Mask                 */
N
N#define SC_PINCSR_CD_REM_F_Pos           (2)                                               /*!< SC_T::PINCSR: CD_REM_F Position           */
N#define SC_PINCSR_CD_REM_F_Msk           (0x1ul << SC_PINCSR_CD_REM_F_Pos)                 /*!< SC_T::PINCSR: CD_REM_F Mask               */
N
N#define SC_PINCSR_CD_INS_F_Pos           (3)                                               /*!< SC_T::PINCSR: CD_INS_F Position           */
N#define SC_PINCSR_CD_INS_F_Msk           (0x1ul << SC_PINCSR_CD_INS_F_Pos)                 /*!< SC_T::PINCSR: CD_INS_F Mask               */
N
N#define SC_PINCSR_CD_PIN_ST_Pos          (4)                                               /*!< SC_T::PINCSR: CD_PIN_ST Position          */
N#define SC_PINCSR_CD_PIN_ST_Msk          (0x1ul << SC_PINCSR_CD_PIN_ST_Pos)                /*!< SC_T::PINCSR: CD_PIN_ST Mask              */
N
N#define SC_PINCSR_CLK_KEEP_Pos           (6)                                               /*!< SC_T::PINCSR: CLK_KEEP Position           */
N#define SC_PINCSR_CLK_KEEP_Msk           (0x1ul << SC_PINCSR_CLK_KEEP_Pos)                 /*!< SC_T::PINCSR: CLK_KEEP Mask               */
N
N#define SC_PINCSR_ADAC_CD_EN_Pos         (7)                                               /*!< SC_T::PINCSR: ADAC_CD_EN Position         */
N#define SC_PINCSR_ADAC_CD_EN_Msk         (0x1ul << SC_PINCSR_ADAC_CD_EN_Pos)               /*!< SC_T::PINCSR: ADAC_CD_EN Mask             */
N
N#define SC_PINCSR_SC_OEN_ST_Pos          (8)                                               /*!< SC_T::PINCSR: SC_OEN_ST Position          */
N#define SC_PINCSR_SC_OEN_ST_Msk          (0x1ul << SC_PINCSR_SC_OEN_ST_Pos)                /*!< SC_T::PINCSR: SC_OEN_ST Mask              */
N
N#define SC_PINCSR_SC_DATA_O_Pos          (9)                                               /*!< SC_T::PINCSR: SC_DATA_O Position          */
N#define SC_PINCSR_SC_DATA_O_Msk          (0x1ul << SC_PINCSR_SC_DATA_O_Pos)                /*!< SC_T::PINCSR: SC_DATA_O Mask              */
N
N#define SC_PINCSR_CD_LEV_Pos             (10)                                              /*!< SC_T::PINCSR: CD_LEV Position             */
N#define SC_PINCSR_CD_LEV_Msk             (0x1ul << SC_PINCSR_CD_LEV_Pos)                   /*!< SC_T::PINCSR: CD_LEV Mask                 */
N
N#define SC_PINCSR_POW_INV_Pos            (11)                                              /*!< SC_T::PINCSR: POW_INV Position            */
N#define SC_PINCSR_POW_INV_Msk            (0x1ul << SC_PINCSR_POW_INV_Pos)                  /*!< SC_T::PINCSR: POW_INV Mask                */
N
N#define SC_PINCSR_SC_DATA_I_ST_Pos       (16)                                              /*!< SC_T::PINCSR: SC_DATA_I_ST Position       */
N#define SC_PINCSR_SC_DATA_I_ST_Msk       (0x1ul << SC_PINCSR_SC_DATA_I_ST_Pos)             /*!< SC_T::PINCSR: SC_DATA_I_ST Mask           */
N
N#define SC_TMR0_CNT_Pos                  (0)                                               /*!< SC_T::TMR0: CNT Position                  */
N#define SC_TMR0_CNT_Msk                  (0xfffffful << SC_TMR0_CNT_Pos)                   /*!< SC_T::TMR0: CNT Mask                      */
N
N#define SC_TMR0_MODE_Pos                 (24)                                              /*!< SC_T::TMR0: MODE Position                 */
N#define SC_TMR0_MODE_Msk                 (0xful << SC_TMR0_MODE_Pos)                       /*!< SC_T::TMR0: MODE Mask                     */
N
N#define SC_TMR1_CNT_Pos                  (0)                                               /*!< SC_T::TMR1: CNT Position                  */
N#define SC_TMR1_CNT_Msk                  (0xfful << SC_TMR1_CNT_Pos)                       /*!< SC_T::TMR1: CNT Mask                      */
N
N#define SC_TMR1_MODE_Pos                 (24)                                              /*!< SC_T::TMR1: MODE Position                 */
N#define SC_TMR1_MODE_Msk                 (0xful << SC_TMR1_MODE_Pos)                       /*!< SC_T::TMR1: MODE Mask                     */
N
N#define SC_TMR2_CNT_Pos                  (0)                                               /*!< SC_T::TMR2: CNT Position                  */
N#define SC_TMR2_CNT_Msk                  (0xfful << SC_TMR2_CNT_Pos)                       /*!< SC_T::TMR2: CNT Mask                      */
N
N#define SC_TMR2_MODE_Pos                 (24)                                              /*!< SC_T::TMR2: MODE Position                 */
N#define SC_TMR2_MODE_Msk                 (0xful << SC_TMR2_MODE_Pos)                       /*!< SC_T::TMR2: MODE Mask                     */
N
N#define SC_UACTL_UA_MODE_EN_Pos          (0)                                               /*!< SC_T::UACTL: UA_MODE_EN Position          */
N#define SC_UACTL_UA_MODE_EN_Msk          (0x1ul << SC_UACTL_UA_MODE_EN_Pos)                /*!< SC_T::UACTL: UA_MODE_EN Mask              */
N
N#define SC_UACTL_DATA_LEN_Pos            (4)                                               /*!< SC_T::UACTL: DATA_LEN Position            */
N#define SC_UACTL_DATA_LEN_Msk            (0x3ul << SC_UACTL_DATA_LEN_Pos)                  /*!< SC_T::UACTL: DATA_LEN Mask                */
N
N#define SC_UACTL_PBDIS_Pos               (6)                                               /*!< SC_T::UACTL: PBDIS Position               */
N#define SC_UACTL_PBDIS_Msk               (0x1ul << SC_UACTL_PBDIS_Pos)                     /*!< SC_T::UACTL: PBDIS Mask                   */
N
N#define SC_UACTL_OPE_Pos                 (7)                                               /*!< SC_T::UACTL: OPE Position                 */
N#define SC_UACTL_OPE_Msk                 (0x1ul << SC_UACTL_OPE_Pos)                       /*!< SC_T::UACTL: OPE Mask                     */
N
N#define SC_TDRA_TDR0_Pos                 (0)                                               /*!< SC_T::TDRA: TDR0 Position                 */
N#define SC_TDRA_TDR0_Msk                 (0xfffffful << SC_TDRA_TDR0_Pos)                  /*!< SC_T::TDRA: TDR0 Mask                     */
N
N#define SC_TDRB_TDR1_Pos                 (0)                                               /*!< SC_T::TDRB: TDR1 Position                 */
N#define SC_TDRB_TDR1_Msk                 (0xfful << SC_TDRB_TDR1_Pos)                      /*!< SC_T::TDRB: TDR1 Mask                     */
N
N#define SC_TDRB_TDR2_Pos                 (8)                                               /*!< SC_T::TDRB: TDR2 Position                 */
N#define SC_TDRB_TDR2_Msk                 (0xfful << SC_TDRB_TDR2_Pos)                      /*!< SC_T::TDRB: TDR2 Mask                     */
N
N/**@}*/ /* SC_CONST */
N/**@}*/ /* end of SC register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  SPI Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GO_BUSY   |SPI Transfer Control Bit And Busy Status
N     * |        |          |0 = Writing this bit "0" will stop data transfer if SPI is transferring.
N     * |        |          |1 = In Master mode, writing "1" to this bit will start the SPI data transfer; In Slave mode, writing '1' to this bit indicates that the salve is ready to communicate with a master.
N     * |        |          |If the FIFO mode is disabled, during the data transfer, this bit keeps the value of '1'.
N     * |        |          |As the transfer is finished, this bit will be cleared automatically.
N     * |        |          |Software can read this bit to check if the SPI is in busy status.
N     * |        |          |In FIFO mode, this bit will be controlled by hardware.
N     * |        |          |Software should not modify this bit.
N     * |        |          |In slave mode, this bit always returns 1 when software reads this register.
N     * |        |          |In master mode, this bit reflects the busy or idle status of SPI.
N     * |        |          |Note:
N     * |        |          |1. When FIFO mode is disabled, all configurations should be set before writing "1" to the GO_BUSY bit in the SPI_CTL register.
N     * |        |          |2. When FIFO bit is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA controller finishes the data transfer.
N     * |[1]     |RX_NEG    |Receive At Negative Edge
N     * |        |          |0 = The received data is latched on the rising edge of SPI_SCLK.
N     * |        |          |1 = The received data is latched on the falling edge of SPI_SCLK.
N     * |[2]     |TX_NEG    |Transmit At Negative Edge
N     * |        |          |0 = The transmitted data output is changed on the rising edge of SPI_SCLK.
N     * |        |          |1 = The transmitted data output is changed on the falling edge of SPI_SCLK.
N     * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
N     * |        |          |This field specifies how many bits can be transmitted / received in one transaction.
N     * |        |          |The minimum bit length is 8 bits and can be up to 32 bits.
N     * |        |          |TX_BIT_LEN   Description
N     * |        |          |01000        8 bits are transmitted in one transaction
N     * |        |          |01001        9 bits are transmitted in one transaction
N     * |        |          |------       ----------
N     * |        |          |11111        31 bits are transmitted in one transaction
N     * |        |          |00000        32 bits are transmitted in one transaction
N     * |[10]    |LSB       |Send LSB First
N     * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of TX_BITLEN, is transmitted/received first.
N     * |        |          |1 = The LSB, bit 0 of the SPI_TX0/1, is sent first to the the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the SPI_RX register (SPI_RX0/1).
N     * |[11]    |CLKP      |Clock Polarity
N     * |        |          |0 = The default level of SCLK is low in idle state.
N     * |        |          |1 = The default level of SCLK is high in idle state.
N     * |[15:12] |SP_CYCLE  |Suspend Interval (Master Only)
N     * |        |          |These four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.
N     * |        |          |The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = "0".
N     * |        |          |If CLKP = "1", the interval is from the rising clock edge to the falling clock edge.
N     * |        |          |The default value is 0x3. The desired suspend interval is obtained according to the following equation:
N     * |        |          |(SP_CYCLE[3:0) + 0.5) * period of SPICLK
N     * |        |          |Ex:
N     * |        |          |SP_CYCLE = 0x0 ... 0.5 SPICLK clock cycle.
N     * |        |          |SP_CYCLE = 0x1 ... 1.5 SPICLK clock cycle.
N     * |        |          |......
N     * |        |          |SP_CYCLE = 0xE ... 14.5 SPICLK clock cycle.
N     * |        |          |SP_CYCLE = 0xF ... 15.5 SPICLK clock cycle.
N     * |        |          |If the Variable Clock function is enabled, the minimum period of suspend interval (the transmit data in FIFO buffer is not empty) between the successive transaction is (6.5 + SP_CYCLE) * SPICLK clock cycle
N     * |[17]    |INTEN     |Interrupt Enable
N     * |        |          |0 = SPI Interrupt Disabled.
N     * |        |          |1 = SPI Interrupt Enabled.
N     * |[18]    |SLAVE     |Slave Mode
N     * |        |          |0 = SPI controller set as Master mode.
N     * |        |          |1 = SPI controller set as Slave mode.
N     * |[19]    |REORDER   |Byte Reorder Function Enable
N     * |        |          |0 = Disable byte reorder function
N     * |        |          |1 = Enable byte reorder function and insert a byte suspend interval among each byte.
N     * |        |          |The setting of TX_BIT_LEN must be configured as 00b ( 32 bits/ word).
N     * |        |          |The suspend interval is defined in SP_CYCLE.
N     * |        |          |Note:
N     * |        |          |1. The byte reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
N     * |        |          |2. In Slave mode with level-trigger configuration, if the byte suspend function is enabled, the slave select pin must be kept at active state during the successive four bytes transfer.
N     * |        |          |3. The byte reorder function is not supported when the variable serial clock function or the dual I/O mode is enabled.
N     * |[21]    |FIFOM     |FIFO Mode Enable
N     * |        |          |0 = Normal mode.
N     * |        |          |1 = FIFO mode.
N     * |        |          |Note:
N     * |        |          |1. Before enabling FIFO mode, the other related settings should be set in advance.
N     * |        |          |2. In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set "1" automatically after the data was written into the 8-depth FIFO.
N     * |        |          |The user can clear this FIFO bit after the transmit FIFO status is empty and the GO_BUSY back to 0.
N     * |[22]    |TWOB      |2-Bit Transfer Mode Active
N     * |        |          |0 = 2-bit transfer mode Disabled.
N     * |        |          |1 = 2-bit transfer mode Enabled.
N     * |        |          |Note that when enabling TWOB, the serial transmitted 2-bits data are from SPI_TX1/0, and the received 2-bits data input are put into SPI_RX1/0.
N     * |[23]    |VARCLK_EN |Variable Clock Enable
N     * |        |          |0 = The serial clock output frequency is fixed and only decided by the value of DIVIDER1
N     * |        |          |1 = The serial clock output frequency is variable.
N     * |        |          |The output frequency is decided by the value of VARCLK (SPI_VARCLK), DIVIDER1, and DIVIDER2.
N     * |        |          |Note: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).
N     * |[28]    |DUAL_IO_DIR|Dual IO Mode Direction
N     * |        |          |0 = Date read in the Dual I/O Mode function.
N     * |        |          |1 = Data write in the Dual I/O Mode function.
N     * |[29]    |DUAL_IO_EN|Dual IO Mode Enable
N     * |        |          |0 = Dual I/O Mode function Disabled.
N     * |        |          |1 = Dual I/O Mode function Enabled.
N     * |[31]    |WKEUP_EN  |Wake-Up Enable
N     * |        |          |0 = Wake-up function Disabled when the system enters Power-down mode.
N     * |        |          |1 = Wake-up function Enabled.
N     * |        |          |When the system enters Power-down mode, the system can be wake-up from the SPI controller when this bit is enabled and if there is any toggle in the SPICLK port.
N     * |        |          |After the system wake-up, this bit must be cleared by user to disable the wake-up requirement.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x04  SPI Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_EMPTY  |Received FIFO_EMPTY Status
N     * |        |          |0 = Received data FIFO is not empty in the dual FIFO mode.
N     * |        |          |1 = Received data FIFO is empty in the dual FIFO mode.
N     * |[1]     |RX_FULL   |Received FIFO_FULL Status
N     * |        |          |0 = Received data FIFO is not full in dual FIFO mode.
N     * |        |          |1 = Received data FIFO is full in the dual FIFO mode.
N     * |[2]     |TX_EMPTY  |Transmitted FIFO_EMPTY Status
N     * |        |          |0 = Transmitted data FIFO is not empty in the dual FIFO mode.
N     * |        |          |1 =Transmitted data FIFO is empty in the dual FIFO mode.
N     * |[3]     |TX_FULL   |Transmitted FIFO_FULL Status
N     * |        |          |0 = Transmitted data FIFO is not full in the dual FIFO mode.
N     * |        |          |1 = Transmitted data FIFO is full in the dual FIFO mode.
N     * |[4]     |LTRIG_FLAG|Level Trigger Accomplish Flag
N     * |        |          |In Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.
N     * |        |          |0 = The transferred bit length of one transaction does not meet the specified requirement.
N     * |        |          |1 = The transferred bit length meets the specified requirement which defined in TX_BIT_LEN.
N     * |        |          |Note: This bit is READ only.
N     * |        |          |As the software sets the GO_BUSY bit to 1, the LTRIG_FLAG will be cleared to 0 after 4 SPI engine clock periods plus 1 system clock period.
N     * |        |          |In FIFO mode, this bit is unmeaning.
N     * |[6]     |SLV_START_INTSTS|Slave Start Interrupt Status
N     * |        |          |It is used to dedicate that the transfer has started in Slave mode with no slave select.
N     * |        |          |0 = Slave started transfer no active.
N     * |        |          |1 = Transfer has started in Slave mode with no slave select.
N     * |        |          |It is auto clear by transfer done or writing one clear.
N     * |[7]     |INTSTS    |Interrupt Status
N     * |        |          |0 = Transfer is not finished yet.
N     * |        |          |1 = Transfer is done. The interrupt is requested when the INTEN bit is enabled.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to this bit.
N     * |[8]     |RXINT_STS |RX FIFO Threshold Interrupt Status (Read Only)
N     * |        |          |0 = RX valid data counts small or equal than RXTHRESHOLD.
N     * |        |          |1 = RX valid data counts bigger than RXTHRESHOLD.
N     * |        |          |Note: If RXINT_EN = 1 and RX_INTSTS = 1, SPI will generate interrupt.
N     * |[9]     |RX_OVER_RUN|RX FIFO Over Run Status
N     * |        |          |If SPI receives data when RX FIFO is full, this bit will set to 1, and the received data will dropped.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[10]    |TXINT_STS |TX FIFO Threshold Interrupt Status (Read Only)
N     * |        |          |0 = TX valid data counts bigger than TXTHRESHOLD.
N     * |        |          |1 = TX valid data counts small or equal than TXTHRESHOLD.
N     * |[12]    |TIME_OUT_STS|TIMEOUT Interrupt Flag
N     * |        |          |0 = There is not timeout event on the received buffer.
N     * |        |          |1 = RX FIFO is not empty and there is not be read over the 64 SPI_CLK period in master mode and over the 576 ECLK period in slave mode.
N     * |        |          |When the received FIFO is read by user, the timeout status will be cleared automatically.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[19:16] |RX_FIFO_CNT|Data counts in RX FIFO (Read Only)
N     * |[23:20] |TX_FIFO_CNT|Data counts in TX FIFO (Read Only)
N    */
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x08  SPI Clock Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DIVIDER1  |Clock Divider 1 Register
N     * |        |          |The value in this field is the 1th frequency divider of the PCLK to generate the serial clock of SPI_SCLK.
N     * |        |          |The desired frequency is obtained according to the following equation:
N     * |        |          |Where
N     * |        |          |is the SPI engine clock source. It is defined in the CLK_SEL1.
N     * |[23:16] |DIVIDER2  |Clock Divider 2 Register
N     * |        |          |The value in this field is the 2nd frequency divider of the PCLK to generate the serial clock of SPI_SCLK.
N     * |        |          |The desired frequency is obtained according to the following equation:
N    */
N    __IO uint32_t CLKDIV;
X    volatile uint32_t CLKDIV;
N
N    /**
N     * SSR
N     * ===================================================================================================
N     * Offset: 0x0C  SPI Slave Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |SSR       |Slave Select Active Register (Master Only)
N     * |        |          |If AUTOSS bit is cleared, writing "1" to SSR[0] bit sets the SPISS[0] line to an active state and writing "0" sets the line back to inactive state.(the same as SSR[1] for SPISS[1])
N     * |        |          |If AUTOSS bit is set, writing "1" to any bit location of this field will select appropriate SPISS[1:0] line to be automatically driven to active state for the duration of the transaction, and will be driven to inactive state for the rest of the time.
N     * |        |          |(The active level of SPISS[1:0] is specified in SS_LVL).
N     * |        |          |Note:
N     * |        |          |1. This interface can only drive one device/slave at a given time.
N     * |        |          |Therefore, the slaves select of the selected device must be set to its active level before starting any read or write transfer.
N     * |        |          |2. SPISS[0] is also defined as device/slave select input in Slave mode.
N     * |        |          |And that the slave select input must be driven by edge active trigger which level depend on the SS_LVL setting, otherwise the SPI slave core will go into dead path until the edge active triggers again or reset the SPI core by software.
N     * |[2]     |SS_LVL    |Slave Select Active Level
N     * |        |          |It defines the active level of device/slave select signal (SPISS[1:0]).
N     * |        |          |0 = The SPI_SS slave select signal is active Low.
N     * |        |          |1 = The SPI_SS slave select signal is active High.
N     * |[3]     |AUTOSS    |Automatic Slave Selection (Master Only)
N     * |        |          |0 = If this bit is set as "0", slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register.
N     * |        |          |1 = If this bit is set as "1", SPISS[1:0] signals are generated automatically.
N     * |        |          |It means that device/slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started, and is de-asserted after each transaction is done.
N     * |[4]     |SS_LTRIG  |Slave Select Level Trigger
N     * |        |          |0 = The input slave select signal is edge-trigger.
N     * |        |          |1 = The slave select signal will be level-trigger.
N     * |        |          |It depends on SS_LVL to decide the signal is active low or active high.
N     * |[5]     |NOSLVSEL  |No Slave Selected In Slave Mode
N     * |        |          |This is used to ignore the slave select signal in Slave mode.
N     * |        |          |The SPI controller can work on 3 wire interface including SPICLK, SPI_MISO, and SPI_MOSI when it is set as a slave device.
N     * |        |          |0 = The controller is 4-wire bi-direction interface.
N     * |        |          |1 = The controller is 3-wire bi-direction interface in Slave mode.
N     * |        |          |When this bit is set as 1, the controller start to transmit/receive data after the GO_BUSY bit active and the serial clock input.
N     * |        |          |Note: In no slave select signal mode, the SS_LTRIG, SPI_SSR[4], shall be set as "1".
N     * |[8]     |SLV_ABORT |Abort In Slave Mode With No Slave Selected
N     * |        |          |In normal operation, there is interrupt event when the received data meet the required bits which define in TX_BIT_LEN.
N     * |        |          |If the received bits are less than the requirement and there is no more serial clock input over the time period which is defined by user in slave mode with no slave select, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event.
N     * |        |          |Note: It is auto cleared to "0" by hardware when the abort event is active.
N     * |[9]     |SSTA_INTEN|Slave Start Interrupt Enable
N     * |        |          |It is used to enable interrupt when the transfer has started in Slave mode with no slave select.
N     * |        |          |If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.
N     * |        |          |0 = Tansfer start interrupt Disabled.
N     * |        |          |1 = Transaction start interrupt Enabled.
N     * |        |          |It is cleared when the current transfer done or the SLV_START_INTSTS bit cleared (write 1 clear).
N     * |[16]    |SS_INT_OPT|Slave Select Interrupt Option
N     * |        |          |It is used to enable the interrupt when the transfer has done in slave mode.
N     * |        |          |0 = No any interrupt, even there is slave select inactive event.
N     * |        |          |1 = There is interrupt event when the slave select is inactive.
N     * |        |          |It is used to inform the user the transaction has finished and the slave select into the inactive state.
N    */
N    __IO uint32_t SSR;
X    volatile uint32_t SSR;
N
N    /**
N     * RX0
N     * ===================================================================================================
N     * Offset: 0x10  SPI Receive Data FIFO Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RDATA     |Receive Data FIFO Register
N     * |        |          |The received data can be read on it.
N     * |        |          |If the FIFO bit is set as 1, the user also checks the RX_EMPTY, SPI_STATUS[0], to check if there is any more received data or not.
N     * |        |          |Note: These registers are read only.
N    */
N    __I  uint32_t RX0;
X    volatile const  uint32_t RX0;
N
N    /**
N     * RX1
N     * ===================================================================================================
N     * Offset: 0x14  SPI Receive Data FIFO Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RDATA     |Receive Data FIFO Register
N     * |        |          |The received data can be read on it.
N     * |        |          |If the FIFO bit is set as 1, the user also checks the RX_EMPTY, SPI_STATUS[0], to check if there is any more received data or not.
N     * |        |          |Note: These registers are read only.
N    */
N    __I  uint32_t RX1;
X    volatile const  uint32_t RX1;
N    uint32_t RESERVE0[2];
N
N
N    /**
N     * TX0
N     * ===================================================================================================
N     * Offset: 0x20  SPI Transmit Data FIFO Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |TDATA     |Transmit Data FIFO Register
N     * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer.
N     * |        |          |The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.
N     * |        |          |For example, if TX_BIT_LEN is set to 0x08, the bit SPI_TX[7:0] will be transmitted in next transfer.
N     * |        |          |If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.
N     * |        |          |Note: When the SPI controller is configured as a slave device and the FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the software must update the transmit data register before setting the GO_BUSY bit to 1
N    */
N    __O  uint32_t TX0;
X    volatile  uint32_t TX0;
N
N    /**
N     * TX1
N     * ===================================================================================================
N     * Offset: 0x24  SPI Transmit Data FIFO Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |TDATA     |Transmit Data FIFO Register
N     * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer.
N     * |        |          |The number of valid bits depends on the setting of transmit bit length field of the SPI_CTL register.
N     * |        |          |For example, if TX_BIT_LEN is set to 0x08, the bit SPI_TX[7:0] will be transmitted in next transfer.
N     * |        |          |If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.
N     * |        |          |Note: When the SPI controller is configured as a slave device and the FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the software must update the transmit data register before setting the GO_BUSY bit to 1
N    */
N    __O  uint32_t TX1;
X    volatile  uint32_t TX1;
N    uint32_t RESERVE1[3];
N
N
N    /**
N     * VARCLK
N     * ===================================================================================================
N     * Offset: 0x34  SPI Variable Clock Pattern Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |VARCLK    |Variable Clock Pattern Flag
N     * |        |          |The value in this field is the frequency patterns of the SPICLK.
N     * |        |          |If the bit pattern of VARCLK is '0', the output frequency of SPICLK is according the value of DIVIDER1.
N     * |        |          |If the bit patterns of VARCLK are '1', the output frequency of SPICLK is according the value of DIVIDER2.
N     * |        |          |Note: It is used for CLKP = 0 only.
N    */
N    __IO uint32_t VARCLK;
X    volatile uint32_t VARCLK;
N
N    /**
N     * DMA
N     * ===================================================================================================
N     * Offset: 0x38  SPI DMA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TX_DMA_EN |Transmit PDMA Enable (PDMA Writes Data To SPI)
N     * |        |          |Set this bit to 1 will start the transmit PDMA process.
N     * |        |          |SPI controller will issue request to PDMA controller automatically.
N     * |        |          |If using PDMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register.
N     * |        |          |The DMA controller inside SPI controller will set it automatically whenever necessary.
N     * |        |          |Note:
N     * |        |          |1. Two transaction need minimal 18 APB clock + 8 SPI serial clocks suspend interval in master mode for edge mode and 18 APB clock + 9.5 serial clocks for level mode.
N     * |        |          |2. If the 2-bit function is enabled, the requirement timing shall append 18 APB clock based on the above clock period.
N     * |        |          |Hardware will clear this bit to 0 automatically after PDMA transfer done. If FIFO mode not release, it should be remove.
N     * |[1]     |RX_DMA_EN |Receiving PDMA Enable(PDMA Reads SPI Data To Memory)
N     * |        |          |Set this bit to "1" will start the receive PDMA process.
N     * |        |          |SPI controller will issue request to PDMA controller automatically when there is data written into the received buffer or the status of RX_EMPTY status is set to 0 in FIFO mode.
N     * |        |          |If using the RX_PDMA mode to receive data but TX_DMA is disabled, the GO_BUSY bit shall be set by user.
N     * |        |          |Hardware will clear this bit to 0 automatically after PDMA transfer done.
N     * |        |          |In Slave mode and the FIFO bit is disabled, if the receive PDMA is enabled but the transmit PDMA is disabled, the minimal suspend interval between two successive transactions input is need to be larger than 9 SPI slave engine clock + 4 APB clock for edge mode and 9.5 SPI slave engine clock + 4 APB clock
N     * |[2]     |PDMA_RST  |PDMA Reset
N     * |        |          |It is used to reset the SPI PDMA function into default state.
N     * |        |          |0 = After reset PDMA function or in normal operation.
N     * |        |          |1 = Reset PDMA function.
N     * |        |          |Note: it is auto cleared to "0" after the reset function done.
N    */
N    __IO uint32_t DMA;
X    volatile uint32_t DMA;
N
N    /**
N     * FFCTL
N     * ===================================================================================================
N     * Offset: 0x3C  SPI FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_CLR    |Receiving FIFO Counter Clear
N     * |        |          |This bit is used to clear the receiver counter in FIFO Mode.
N     * |        |          |This bit can be written "1" to clear the receiver counter and this bit will be cleared to "0" automatically after clearing receiving counter.
N     * |        |          |After the clear operation, the flag of RX_EMPTY in SPI_STATUS[0] will be set to "1".
N     * |[1]     |TX_CLR    |Transmitting FIFO Counter Clear
N     * |        |          |This bit is used to clear the transmit counter in FIFO Mode.
N     * |        |          |This bit can be written "1" to clear the transmitting counter and this bit will be cleared to "0" automatically after clearing transmitting counter.
N     * |        |          |After the clear operation, the flag of TX_EMPTY in SPI_STATUS[2] will be set to "1".
N     * |[2]     |RXINT_EN  |RX Threshold Interrupt Enable
N     * |        |          |0 = Rx threshold interrupt Disabled.
N     * |        |          |1 = RX threshold interrupt Enable.
N     * |[3]     |TXINT_EN  |TX Threshold Interrupt Enable
N     * |        |          |0 = Tx threshold interrupt Disabled.
N     * |        |          |1 = TX threshold interrupt Enable.
N     * |[4]     |RXOVINT_EN|RX FIFO Over Run Interrupt Enable
N     * |        |          |0 = RX FIFO over run interrupt Disabled.
N     * |        |          |1 = RX FIFO over run interrupt Enabled.
N     * |[7]     |TIMEOUT_EN|RX Read Timeout Function Enable
N     * |        |          |0 = RX read Timeout function Disabled.
N     * |        |          |1 = RX read Timeout function Enabled.
N     * |[26:24] |RX_THRESHOLD|Received FIFO Threshold
N     * |        |          |3-bits register, value from 0 ~7.
N     * |        |          |If RX valid data counts large than RXTHRESHOLD, RXINT_STS will set to 1, else RXINT_STS will set to 0.
N     * |[30:28] |TX_THRESHOLD|Transmit FIFO Threshold
N     * |        |          |3-bit register, value from 0 ~7.
N     * |        |          |If TX valid data counts small or equal than TXTHRESHOLD, TXINT_STS will set to 1, else TXINT_STS will set to 0
N    */
N    __IO uint32_t FFCTL;
X    volatile uint32_t FFCTL;
N} SPI_T;
N
N/**
N    @addtogroup SPI_CONST SPI Bit Field Definition
N    Constant Definitions for SPI Controller
N@{ */
N
N#define SPI_CTL_GO_BUSY_Pos              (0)                                               /*!< SPI_T::CTL: GO_BUSY Position              */
N#define SPI_CTL_GO_BUSY_Msk              (0x1ul << SPI_CTL_GO_BUSY_Pos)                    /*!< SPI_T::CTL: GO_BUSY Mask                  */
N
N#define SPI_CTL_RX_NEG_Pos               (1)                                               /*!< SPI_T::CTL: RX_NEG Position               */
N#define SPI_CTL_RX_NEG_Msk               (0x1ul << SPI_CTL_RX_NEG_Pos)                     /*!< SPI_T::CTL: RX_NEG Mask                   */
N
N#define SPI_CTL_TX_NEG_Pos               (2)                                               /*!< SPI_T::CTL: TX_NEG Position               */
N#define SPI_CTL_TX_NEG_Msk               (0x1ul << SPI_CTL_TX_NEG_Pos)                     /*!< SPI_T::CTL: TX_NEG Mask                   */
N
N#define SPI_CTL_TX_BIT_LEN_Pos           (3)                                               /*!< SPI_T::CTL: TX_BIT_LEN Position           */
N#define SPI_CTL_TX_BIT_LEN_Msk           (0x1ful << SPI_CTL_TX_BIT_LEN_Pos)                /*!< SPI_T::CTL: TX_BIT_LEN Mask               */
N
N#define SPI_CTL_LSB_Pos                  (10)                                              /*!< SPI_T::CTL: LSB Position                  */
N#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI_T::CTL: LSB Mask                      */
N
N#define SPI_CTL_CLKP_Pos                 (11)                                              /*!< SPI_T::CTL: CLKP Position                 */
N#define SPI_CTL_CLKP_Msk                 (0x1ul << SPI_CTL_CLKP_Pos)                       /*!< SPI_T::CTL: CLKP Mask                     */
N
N#define SPI_CTL_SP_CYCLE_Pos             (12)                                              /*!< SPI_T::CTL: SP_CYCLE Position             */
N#define SPI_CTL_SP_CYCLE_Msk             (0xful << SPI_CTL_SP_CYCLE_Pos)                   /*!< SPI_T::CTL: SP_CYCLE Mask                 */
N
N#define SPI_CTL_INTEN_Pos                (17)                                              /*!< SPI_T::CTL: INTEN Position                */
N#define SPI_CTL_INTEN_Msk                (0x1ul << SPI_CTL_INTEN_Pos)                      /*!< SPI_T::CTL: INTEN Mask                    */
N
N#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI_T::CTL: SLAVE Position                */
N#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI_T::CTL: SLAVE Mask                    */
N
N#define SPI_CTL_REORDER_Pos              (19)                                              /*!< SPI_T::CTL: REORDER Position              */
N#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI_T::CTL: REORDER Mask                  */
N
N#define SPI_CTL_FIFOM_Pos                (21)                                              /*!< SPI_T::CTL: FIFOM Position                */
N#define SPI_CTL_FIFOM_Msk                (0x1ul << SPI_CTL_FIFOM_Pos)                      /*!< SPI_T::CTL: FIFOM Mask                    */
N
N#define SPI_CTL_TWOB_Pos                 (22)                                              /*!< SPI_T::CTL: TWOB Position                 */
N#define SPI_CTL_TWOB_Msk                 (0x1ul << SPI_CTL_TWOB_Pos)                       /*!< SPI_T::CTL: TWOB Mask                     */
N
N#define SPI_CTL_VARCLK_EN_Pos            (23)                                              /*!< SPI_T::CTL: VARCLK_EN Position            */
N#define SPI_CTL_VARCLK_EN_Msk            (0x1ul << SPI_CTL_VARCLK_EN_Pos)                  /*!< SPI_T::CTL: VARCLK_EN Mask                */
N
N#define SPI_CTL_DUAL_IO_DIR_Pos          (28)                                              /*!< SPI_T::CTL: DUAL_IO_DIR Position          */
N#define SPI_CTL_DUAL_IO_DIR_Msk          (0x1ul << SPI_CTL_DUAL_IO_DIR_Pos)                /*!< SPI_T::CTL: DUAL_IO_DIR Mask              */
N
N#define SPI_CTL_DUAL_IO_EN_Pos           (29)                                              /*!< SPI_T::CTL: DUAL_IO_EN Position           */
N#define SPI_CTL_DUAL_IO_EN_Msk           (0x1ul << SPI_CTL_DUAL_IO_EN_Pos)                 /*!< SPI_T::CTL: DUAL_IO_EN Mask               */
N
N#define SPI_CTL_WKEUP_EN_Pos             (31)                                              /*!< SPI_T::CTL: WKEUP_EN Position             */
N#define SPI_CTL_WKEUP_EN_Msk             (0x1ul << SPI_CTL_WKEUP_EN_Pos)                   /*!< SPI_T::CTL: WKEUP_EN Mask                 */
N
N#define SPI_STATUS_RX_EMPTY_Pos          (0)                                               /*!< SPI_T::STATUS: RX_EMPTY Position          */
N#define SPI_STATUS_RX_EMPTY_Msk          (0x1ul << SPI_STATUS_RX_EMPTY_Pos)                /*!< SPI_T::STATUS: RX_EMPTY Mask              */
N
N#define SPI_STATUS_RX_FULL_Pos           (1)                                               /*!< SPI_T::STATUS: RX_FULL Position           */
N#define SPI_STATUS_RX_FULL_Msk           (0x1ul << SPI_STATUS_RX_FULL_Pos)                 /*!< SPI_T::STATUS: RX_FULL Mask               */
N
N#define SPI_STATUS_TX_EMPTY_Pos          (2)                                               /*!< SPI_T::STATUS: TX_EMPTY Position          */
N#define SPI_STATUS_TX_EMPTY_Msk          (0x1ul << SPI_STATUS_TX_EMPTY_Pos)                /*!< SPI_T::STATUS: TX_EMPTY Mask              */
N
N#define SPI_STATUS_TX_FULL_Pos           (3)                                               /*!< SPI_T::STATUS: TX_FULL Position           */
N#define SPI_STATUS_TX_FULL_Msk           (0x1ul << SPI_STATUS_TX_FULL_Pos)                 /*!< SPI_T::STATUS: TX_FULL Mask               */
N
N#define SPI_STATUS_LTRIG_FLAG_Pos        (4)                                               /*!< SPI_T::STATUS: LTRIG_FLAG Position        */
N#define SPI_STATUS_LTRIG_FLAG_Msk        (0x1ul << SPI_STATUS_LTRIG_FLAG_Pos)              /*!< SPI_T::STATUS: LTRIG_FLAG Mask            */
N
N#define SPI_STATUS_SLV_START_INTSTS_Pos  (6)                                               /*!< SPI_T::STATUS: SLV_START_INTSTS Position  */
N#define SPI_STATUS_SLV_START_INTSTS_Msk  (0x1ul << SPI_STATUS_SLV_START_INTSTS_Pos)        /*!< SPI_T::STATUS: SLV_START_INTSTS Mask      */
N
N#define SPI_STATUS_INTSTS_Pos            (7)                                               /*!< SPI_T::STATUS: INTSTS Position            */
N#define SPI_STATUS_INTSTS_Msk            (0x1ul << SPI_STATUS_INTSTS_Pos)                  /*!< SPI_T::STATUS: INTSTS Mask                */
N
N#define SPI_STATUS_RXINT_STS_Pos         (8)                                               /*!< SPI_T::STATUS: RXINT_STS Position         */
N#define SPI_STATUS_RXINT_STS_Msk         (0x1ul << SPI_STATUS_RXINT_STS_Pos)               /*!< SPI_T::STATUS: RXINT_STS Mask             */
N
N#define SPI_STATUS_RX_OVER_RUN_Pos       (9)                                               /*!< SPI_T::STATUS: RX_OVER_RUN Position       */
N#define SPI_STATUS_RX_OVER_RUN_Msk       (0x1ul << SPI_STATUS_RX_OVER_RUN_Pos)             /*!< SPI_T::STATUS: RX_OVER_RUN Mask           */
N
N#define SPI_STATUS_TXINT_STS_Pos         (10)                                              /*!< SPI_T::STATUS: TXINT_STS Position         */
N#define SPI_STATUS_TXINT_STS_Msk         (0x1ul << SPI_STATUS_TXINT_STS_Pos)               /*!< SPI_T::STATUS: TXINT_STS Mask             */
N
N#define SPI_STATUS_TIME_OUT_STS_Pos      (12)                                              /*!< SPI_T::STATUS: TIME_OUT_STS Position      */
N#define SPI_STATUS_TIME_OUT_STS_Msk      (0x1ul << SPI_STATUS_TIME_OUT_STS_Pos)            /*!< SPI_T::STATUS: TIME_OUT_STS Mask          */
N
N#define SPI_STATUS_RX_FIFO_CNT_Pos       (16)                                              /*!< SPI_T::STATUS: RX_FIFO_CNT Position       */
N#define SPI_STATUS_RX_FIFO_CNT_Msk       (0xful << SPI_STATUS_RX_FIFO_CNT_Pos)             /*!< SPI_T::STATUS: RX_FIFO_CNT Mask           */
N
N#define SPI_STATUS_TX_FIFO_CNT_Pos       (20)                                              /*!< SPI_T::STATUS: TX_FIFO_CNT Position       */
N#define SPI_STATUS_TX_FIFO_CNT_Msk       (0xful << SPI_STATUS_TX_FIFO_CNT_Pos)             /*!< SPI_T::STATUS: TX_FIFO_CNT Mask           */
N
N#define SPI_CLKDIV_DIVIDER1_Pos          (0)                                               /*!< SPI_T::CLKDIV: DIVIDER1 Position          */
N#define SPI_CLKDIV_DIVIDER1_Msk          (0xfful << SPI_CLKDIV_DIVIDER1_Pos)               /*!< SPI_T::CLKDIV: DIVIDER1 Mask              */
N
N#define SPI_CLKDIV_DIVIDER2_Pos          (16)                                              /*!< SPI_T::CLKDIV: DIVIDER2 Position          */
N#define SPI_CLKDIV_DIVIDER2_Msk          (0xfful << SPI_CLKDIV_DIVIDER2_Pos)               /*!< SPI_T::CLKDIV: DIVIDER2 Mask              */
N
N#define SPI_SSR_SSR_Pos                  (0)                                               /*!< SPI_T::SSR: SSR Position                  */
N#define SPI_SSR_SSR_Msk                  (0x3ul << SPI_SSR_SSR_Pos)                        /*!< SPI_T::SSR: SSR Mask                      */
N
N#define SPI_SSR_SS_LVL_Pos               (2)                                               /*!< SPI_T::SSR: SS_LVL Position               */
N#define SPI_SSR_SS_LVL_Msk               (0x1ul << SPI_SSR_SS_LVL_Pos)                     /*!< SPI_T::SSR: SS_LVL Mask                   */
N
N#define SPI_SSR_AUTOSS_Pos               (3)                                               /*!< SPI_T::SSR: AUTOSS Position               */
N#define SPI_SSR_AUTOSS_Msk               (0x1ul << SPI_SSR_AUTOSS_Pos)                     /*!< SPI_T::SSR: AUTOSS Mask                   */
N
N#define SPI_SSR_SS_LTRIG_Pos             (4)                                               /*!< SPI_T::SSR: SS_LTRIG Position             */
N#define SPI_SSR_SS_LTRIG_Msk             (0x1ul << SPI_SSR_SS_LTRIG_Pos)                   /*!< SPI_T::SSR: SS_LTRIG Mask                 */
N
N#define SPI_SSR_NOSLVSEL_Pos             (5)                                               /*!< SPI_T::SSR: NOSLVSEL Position             */
N#define SPI_SSR_NOSLVSEL_Msk             (0x1ul << SPI_SSR_NOSLVSEL_Pos)                   /*!< SPI_T::SSR: NOSLVSEL Mask                 */
N
N#define SPI_SSR_SLV_ABORT_Pos            (8)                                               /*!< SPI_T::SSR: SLV_ABORT Position            */
N#define SPI_SSR_SLV_ABORT_Msk            (0x1ul << SPI_SSR_SLV_ABORT_Pos)                  /*!< SPI_T::SSR: SLV_ABORT Mask                */
N
N#define SPI_SSR_SSTA_INTEN_Pos           (9)                                               /*!< SPI_T::SSR: SSTA_INTEN Position           */
N#define SPI_SSR_SSTA_INTEN_Msk           (0x1ul << SPI_SSR_SSTA_INTEN_Pos)                 /*!< SPI_T::SSR: SSTA_INTEN Mask               */
N
N#define SPI_SSR_SS_INT_OPT_Pos           (16)                                              /*!< SPI_T::SSR: SS_INT_OPT Position           */
N#define SPI_SSR_SS_INT_OPT_Msk           (0x1ul << SPI_SSR_SS_INT_OPT_Pos)                 /*!< SPI_T::SSR: SS_INT_OPT Mask               */
N
N#define SPI_RX0_RDATA_Pos                (0)                                               /*!< SPI_T::RX0: RDATA Position                */
N#define SPI_RX0_RDATA_Msk                (0xfffffffful << SPI_RX0_RDATA_Pos)               /*!< SPI_T::RX0: RDATA Mask                    */
N
N#define SPI_RX1_RDATA_Pos                (0)                                               /*!< SPI_T::RX1: RDATA Position                */
N#define SPI_RX1_RDATA_Msk                (0xfffffffful << SPI_RX1_RDATA_Pos)               /*!< SPI_T::RX1: RDATA Mask                    */
N
N#define SPI_TX0_TDATA_Pos                (0)                                               /*!< SPI_T::TX0: TDATA Position                */
N#define SPI_TX0_TDATA_Msk                (0xfffffffful << SPI_TX0_TDATA_Pos)               /*!< SPI_T::TX0: TDATA Mask                    */
N
N#define SPI_TX1_TDATA_Pos                (0)                                               /*!< SPI_T::TX1: TDATA Position                */
N#define SPI_TX1_TDATA_Msk                (0xfffffffful << SPI_TX1_TDATA_Pos)               /*!< SPI_T::TX1: TDATA Mask                    */
N
N#define SPI_VARCLK_VARCLK_Pos            (0)                                               /*!< SPI_T::VARCLK: VARCLK Position            */
N#define SPI_VARCLK_VARCLK_Msk            (0xfffffffful << SPI_VARCLK_VARCLK_Pos)           /*!< SPI_T::VARCLK: VARCLK Mask                */
N
N#define SPI_DMA_TX_DMA_EN_Pos            (0)                                               /*!< SPI_T::DMA: TX_DMA_EN Position            */
N#define SPI_DMA_TX_DMA_EN_Msk            (0x1ul << SPI_DMA_TX_DMA_EN_Pos)                  /*!< SPI_T::DMA: TX_DMA_EN Mask                */
N
N#define SPI_DMA_RX_DMA_EN_Pos            (1)                                               /*!< SPI_T::DMA: RX_DMA_EN Position            */
N#define SPI_DMA_RX_DMA_EN_Msk            (0x1ul << SPI_DMA_RX_DMA_EN_Pos)                  /*!< SPI_T::DMA: RX_DMA_EN Mask                */
N
N#define SPI_DMA_PDMA_RST_Pos             (2)                                               /*!< SPI_T::DMA: PDMA_RST Position             */
N#define SPI_DMA_PDMA_RST_Msk             (0x1ul << SPI_DMA_PDMA_RST_Pos)                   /*!< SPI_T::DMA: PDMA_RST Mask                 */
N
N#define SPI_FFCTL_RX_CLR_Pos             (0)                                               /*!< SPI_T::FFCTL: RX_CLR Position             */
N#define SPI_FFCTL_RX_CLR_Msk             (0x1ul << SPI_FFCTL_RX_CLR_Pos)                   /*!< SPI_T::FFCTL: RX_CLR Mask                 */
N
N#define SPI_FFCTL_TX_CLR_Pos             (1)                                               /*!< SPI_T::FFCTL: TX_CLR Position             */
N#define SPI_FFCTL_TX_CLR_Msk             (0x1ul << SPI_FFCTL_TX_CLR_Pos)                   /*!< SPI_T::FFCTL: TX_CLR Mask                 */
N
N#define SPI_FFCTL_RX_INTEN_Pos           (2)                                               /*!< SPI_T::FFCTL: RX_INTEN Position           */
N#define SPI_FFCTL_RX_INTEN_Msk           (0x1ul << SPI_FFCTL_RX_INTEN_Pos)                 /*!< SPI_T::FFCTL: RX_INTEN Mask               */
N
N#define SPI_FFCTL_TX_INTEN_Pos           (3)                                               /*!< SPI_T::FFCTL: TX_INTEN Position           */
N#define SPI_FFCTL_TX_INTEN_Msk           (0x1ul << SPI_FFCTL_TX_INTEN_Pos)                 /*!< SPI_T::FFCTL: TX_INTEN Mask               */
N
N#define SPI_FFCTL_RXOVR_INTEN_Pos        (4)                                               /*!< SPI_T::FFCTL: RXOVR_INTEN Position        */
N#define SPI_FFCTL_RXOVR_INTEN_Msk        (0x1ul << SPI_FFCTL_RXOVR_INTEN_Pos)              /*!< SPI_T::FFCTL: RXOVR_INTEN Mask            */
N
N#define SPI_FFCTL_TIMEOUT_EN_Pos         (7)                                               /*!< SPI_T::FFCTL: TIMEOUT_EN Position         */
N#define SPI_FFCTL_TIMEOUT_EN_Msk         (0x1ul << SPI_FFCTL_TIMEOUT_EN_Pos)               /*!< SPI_T::FFCTL: TIMEOUT_EN Mask             */
N
N#define SPI_FFCTL_RX_THRESHOLD_Pos       (24)                                              /*!< SPI_T::FFCTL: RX_THRESHOLD Position       */
N#define SPI_FFCTL_RX_THRESHOLD_Msk       (0x7ul << SPI_FFCTL_RX_THRESHOLD_Pos)             /*!< SPI_T::FFCTL: RX_THRESHOLD Mask           */
N
N#define SPI_FFCTL_TX_THRESHOLD_Pos       (28)                                              /*!< SPI_T::FFCTL: TX_THRESHOLD Position       */
N#define SPI_FFCTL_TX_THRESHOLD_Msk       (0x7ul << SPI_FFCTL_TX_THRESHOLD_Pos)             /*!< SPI_T::FFCTL: TX_THRESHOLD Mask           */
N
N/**@}*/ /* SPI_CONST */
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller(TIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  Timer x Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TMR_EN    |Timer Counter Enable Bit
N     * |        |          |0 = Stops/Suspends counting.
N     * |        |          |1 = Starts counting.
N     * |        |          |Note1: Set TMR_EN to 1 enables 24-bit counter keeps up counting from the last stop counting value.
N     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (MODE_SEL [5:4] =2'b00) once the value of 24-bit up counter equals the TMRx_CMPR.
N     * |[1]     |SW_RST    |Software Reset
N     * |        |          |Set this bit will reset the timer counter, pre-scale counter and also force TMR_CTL [TMR_EN] to 0.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset Timer's pre-scale counter, internal 24-bit up-counter and TMR_CTL [TMR_EN] bit.
N     * |        |          |Note: This bit will be auto cleared and takes at least 3 TMRx_CLK clock cycles.
N     * |[2]     |WAKE_EN   |Wake-Up Enable
N     * |        |          |When WAKE_EN is set and the TMR_IS or TCAP_IS is set, the timer controller will generate a wake-up trigger event to CPU.
N     * |        |          |0 = Wake-up trigger event Disabled.
N     * |        |          |1 = Wake-up trigger event Enabled.
N     * |[3]     |DBGACK_EN |ICE Debug Mode Acknowledge Ineffective Enable
N     * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting and TIMER counter will be held while ICE debug mode acknowledged.
N     * |        |          |1 = ICE debug mode acknowledgement is ineffective and TIMER counter will keep going no matter ICE debug mode acknowledged or not.
N     * |[5:4]   |MODE_SEL  |Timer Operating Mode Select
N     * |        |          |00 = The timer is operating in the one-shot mode.
N     * |        |          |In this mode, the associated interrupt signal is generated (if TMR_IER [TMR_IE] is enabled) once the value of 24-bit up counter equals the TMRx_CMPR.
N     * |        |          |And TMR_CTL [TMR_EN] is automatically cleared by hardware.
N     * |        |          |01 = The timer is operating in the periodic mode.
N     * |        |          |In this mode, the associated interrupt signal is generated periodically (if TMR_IER [TMR_IE] is enabled) while the value of 24-bit up counter equals the TMRx_CMPR.
N     * |        |          |After that, the 24-bit counter will be reset and starts counting from zero again.
N     * |        |          |10 = The timer is operating in the periodic mode with output toggling.
N     * |        |          |In this mode, the associated interrupt signal is generated periodically (if TMR_IER [TMR_IE] is enabled) while the value of 24-bit up counter equals the TMRx_CMPR.
N     * |        |          |After that, the 24-bit counter will be reset and starts counting from zero again.
N     * |        |          |At the same time, timer controller will also toggle the output pin TMRx_TOG_OUT to its inverse level (from low to high or from high to low).
N     * |        |          |Note: The default level of TMRx_TOG_OUT after reset is low.
N     * |        |          |11 = The timer is operating in continuous counting mode.
N     * |        |          |In this mode, the associated interrupt signal is generated when TMR_DR = TMR_CMPR (if TMR_IER [TMR_IE] is enabled).
N     * |        |          |However, the 24-bit up-counter counts continuously without reset.
N     * |[7]     |TMR_ACT   |Timer Active Status Bit (Read Only)
N     * |        |          |This bit indicates the timer counter status of timer.
N     * |        |          |0 = Timer is not active.
N     * |        |          |1 = Timer is in active.
N     * |[8]     |ADC_TEEN  |TMR_IS Or TCAP_IS Trigger ADC Enable
N     * |        |          |This bit controls if TMR_IS or TCAP_IS could trigger ADC.
N     * |        |          |When ADC_TEEN is set, TMR_IS is set and the CAP_TRG_EN is low, the timer controller will generate an internal trigger event to ADC controller.
N     * |        |          |When ADC_TEEN is set, TCAP_IS is set and the CAP_TRG_EN is high, the timer controller will generate an internal trigger event to ADC controller.
N     * |        |          |0 = TMR_IS or TCAP_IS trigger ADC Disabled.
N     * |        |          |1 = TMR_IS or TCAP_IS trigger ADC Enabled.
N     * |[9]     |DAC_TEEN  |TMR_IS Or TCAP_IS Trigger DAC Enable
N     * |        |          |This bit controls if TMR_IS or TCAP_IS could trigger DAC.
N     * |        |          |When DAC_TEEN is set, TMR_IS is set and the CAP_TRG_EN is low, the timer controller will generate an internal trigger event to DAC controller.
N     * |        |          |When DAC_TEEN is set, TCAP_IS is set and the CAP_TRG_EN is high, the timer controller will generate an internal trigger event to DAC controller.
N     * |        |          |0 = TMR_IS or TCAP_IS trigger DAC Disabled.
N     * |        |          |1 = TMR_IS or TCAP_IS trigger DAC Enabled.
N     * |[10]    |PDMA_TEEN |TMR_IS Or TCAP_IS Trigger PDMA Enable
N     * |        |          |This bit controls if TMR_IS or TCAP_IS could trigger PDMA.
N     * |        |          |When PDMA_TEEN is set, TMR_IS is set and the CAP_TRG_EN is low, the timer controller will generate an internal trigger event to PDMA controller.
N     * |        |          |When PDMA_TEEN is set, TCAP_IS is set and the CAP_TRG_EN is high, the timer controller will generate an internal trigger event to PDMA controller.
N     * |        |          |0 = TMR_IS or TCAP_IS trigger PDMA Disabled.
N     * |        |          |1 = TMR_IS or TCAP_IS trigger PDMA Enabled.
N     * |[11]    |CAP_TRG_EN|TCAP_IS Trigger Mode Enable
N     * |        |          |This bit controls if the TMR_IS or TCAP_IS is used to trigger PDMA, DAC and ADC while TMR_IS or TCAP_IS is set.
N     * |        |          |If this bit is low and TMR_IS is set, timer will generate an internal trigger event to PDMA, DAC or ADC while related trigger enable bit (PDMA_TEEN, DAC_TEEN or ADC_TEEN) is also set.
N     * |        |          |If this bit is set high and TCAP_IS is set, timer will generate an internal trigger event to PDMA, DAC or ADC while related trigger enable bit (PDMA_TEEN, DAC_TEEN or ADC_TEEN) is also set.
N     * |        |          |0 = TMR_IS is used to trigger PDMA, DAC and ADC.
N     * |        |          |1 = TCAP_IS is used to trigger PDMA, DAC and ADC.
N     * |[12]    |EVENT_EN  |Event Counting Mode Enable
N     * |        |          |When EVENT_EN is set, the increase of 24-bit up-counting timer is controlled by external event pin.
N     * |        |          |While the transition of external event pin matches the definition of EVENT_EDGE, the 24-bit up-counting timer increases by 1.
N     * |        |          |Or, the 24-bit up-counting timer will keep its value unchanged.
N     * |        |          |0 = Timer counting is not controlled by external event pin.
N     * |        |          |1 = Timer counting is controlled by external event pin.
N     * |        |          |Note: When EVENT_EN is enabled, user can not choose EXT_TMx(GPB) as clock source.
N     * |        |          |However, the speed of chosen clock must 3 times greater than the speed of EXT_TMx(GPB).
N     * |[13]    |EVENT_EDGE|Event Counting Mode Edge Selection
N     * |        |          |This bit indicates which edge of external event pin enabling the timer to increase 1.
N     * |        |          |0 = A falling edge of external event enabling the timer to increase 1.
N     * |        |          |1 = A rising edge of external event enabling the timer to increase 1.
N     * |[14]    |EVNT_DEB_EN|External Event De-Bounce Enable
N     * |        |          |When EVNT_DEB_EN is set, the external event pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.
N     * |        |          |In de-bounce circuit the external event pin will be sampled 4 times by TMRx_CLK.
N     * |        |          |0 = De-bounce circuit Disabled.
N     * |        |          |1 = De-bounce circuit Enabled.
N     * |        |          |Note: When EVENT_EN is enabled, enable this bit is recommended.
N     * |        |          |And, while EVENT_EN is disabled, disable this bit is recommended to save power consumption.
N     * |[16]    |TCAP_EN   |Tcapture Pin Functional Enable
N     * |        |          |This bit controls if the transition on Tcapture pin could be used as timer counter reset function or timer capture function.
N     * |        |          |0 = The transition on Tcapture pin is ignored.
N     * |        |          |1 = The transition on Tcapture pin will result in the capture or reset of 24-bit timer counter.
N     * |        |          |Note: For TMRx_CTL, if INTR_TRG_EN is set, the TCAP_EN will be forced to low and the Tcapture pin transition is ignored.
N     * |        |          |Note: For TMRx+1_CTL, if INTR_TRG_EN is set, the TCAP_EN will be forced to high.
N     * |[17]    |TCAP_MODE |Tcapture Pin Function Mode Selection
N     * |        |          |This bit indicates if the transition on Tcapture pin is used as timer counter reset function or timer capture function.
N     * |        |          |0 = The transition on Tcapture pin is used as timer capture function.
N     * |        |          |1 = The transition on Tcapture pin is used as timer counter reset function.
N     * |        |          |Note: For TMRx+1_CTL, if INTR_TRG_EN is set, the TCAP_MODE will be forced to low.
N     * |[19:18] |TCAP_EDGE |Tcapture Pin Edge Detect Selection
N     * |        |          |This field defines that active transition of Tcapture pin is for timer counter reset function or for timer capture function.
N     * |        |          |For timer counter reset function and free-counting mode of timer capture function, the configurations are:
N     * |        |          |00 = A falling edge (1 to 0 transition) on Tcapture pin is   an active transition.
N     * |        |          |01 = A rising edge (0 to 1 transition) on Tcapture pin is   an active transition.
N     * |        |          |10 = Both falling edge (1 to 0 transition) and rising edge   (0 to 1 transition) on Tcapture pin are active transitions.
N     * |        |          |11 = Both falling edge (1 to 0 transition) and rising edge   (0 to 1 transition) on Tcapture pin are active transitions.
N     * |        |          |For trigger-counting mode of timer capture function, the configurations are:
N     * |        |          |00 = 1st falling edge on Tcapture pin triggers   24-bit timer to start counting, while 2nd falling edge   triggers 24-bit timer to stop counting.
N     * |        |          |01 = 1st rising edge on Tcapture pin triggers   24-bit timer to start counting, while 2nd rising edge   triggers 24-bit timer to stop counting.
N     * |        |          |10 = Falling edge on Tcapture pin triggers 24-bit timer to   start counting, while rising edge triggers 24-bit timer to stop counting.
N     * |        |          |11 = Rising edge on Tcapture pin triggers 24-bit timer to   start counting, while falling edge triggers 24-bit timer to stop counting.
N     * |        |          |Note: For TMRx+1_CTL, if INTR_TRG_EN is set, the TCAP_EDGE will be forced to 11.
N     * |[20]    |TCAP_CNT_MODE|Timer Capture Counting Mode Selection
N     * |        |          |This bit indicates the behavior of 24-bit up-counting timer while TCAP_EN is set to high.
N     * |        |          |If this bit is 0, the free-counting mode, the behavior of 24-bit up-counting timer is defined by MODE_SEL field.
N     * |        |          |When TCAP_EN is set, TCAP_MODE is 0, and the transition of Tcapture pin matches the TCAP_EDGE setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAPn.
N     * |        |          |If this bit is 1, Trigger-counting mode, 24-bit up-counting timer will be not counting and keep its value at zero.
N     * |        |          |When TCAP_EN is set, TCAP_MODE is 0, and once the transition of external pin matches the 1st transition of TCAP_EDGE setting, the 24-bit up-counting timer will start counting.
N     * |        |          |And then if the transition of external pin matches the 2nd transition of TCAP_EDGE setting, the 24-bit up-counting timer will stop counting.
N     * |        |          |And its value will be saved into register TMRx_TCAPn.
N     * |        |          |0 = Capture with free-counting timer mode.
N     * |        |          |1 = Capture with trigger-counting timer mode.
N     * |        |          |Note: For TMRx+1_CTL, if INTR_TRG_EN is set, the CAP_CNT_MOD will be forced to high, the capture with Trigger-counting Timer mode.
N     * |[22]    |TCAP_DEB_EN|Tcapture Pin De-Bounce Enable
N     * |        |          |When CAP_DEB_EN is set, the Tcapture pin de-bounce circuit will be enabled to eliminate the bouncing of the signal.
N     * |        |          |In de-bounce circuit the Tcapture pin signal will be sampled 4 times by TMRx_CLK.
N     * |        |          |0 = De-bounce circuit Disabled.
N     * |        |          |1 = De-bounce circuit Enabled.
N     * |        |          |Note: When TCAP_EN is enabled, enable this bit is recommended.
N     * |        |          |And, while TCAP_EN is disabled, disable this bit is recommended to save power consumption.
N     * |[24]    |INTR_TRG_EN|Inter-Timer Trigger Mode Enable
N     * |        |          |This bit controls if Inter-timer Trigger mode is enabled.
N     * |        |          |If Inter-timer Trigger mode is enabled, the TMRx will be in counter mode and counting with external Clock Source or event.
N     * |        |          |And, TMRx+1 will be in trigger-counting mode of capture function.
N     * |        |          |0 = Inter-timer trigger mode Disabled.
N     * |        |          |1 = Inter-timer trigger mode Enabled.
N     * |        |          |Note: For TMRx+1_CTL, this bit is ignored and the read back value is always 1'b0.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * PRECNT
N     * ===================================================================================================
N     * Offset: 0x04  Timer x Pre-Scale Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |PRESCALE_CNT|Pre-Scale Counter
N     * |        |          |Clock input is divided by PRESCALE_CNT + 1 before it is fed to the counter.
N     * |        |          |If PRESCALE_CNT =0, then there is no scaling.
N    */
N    __IO uint32_t PRECNT;
X    volatile uint32_t PRECNT;
N
N    /**
N     * CMPR
N     * ===================================================================================================
N     * Offset: 0x08  Timer x Compare Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TMR_CMP   |Timer Compared Value
N     * |        |          |TMR_CMP is a 24-bit compared register.
N     * |        |          |When the internal 24-bit up-counter counts and its value is equal to TMR_CMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TMR_IER [TMR_IE] is enabled.
N     * |        |          |The TMR_CMP value defines the timer counting cycle time.
N     * |        |          |Time-out period = (Period of timer clock input) * (8-bit PRESCALE_CNT + 1) * (24-bit TMR_CMP).
N     * |        |          |Note1: Never write 0x0 or 0x1 in TMR_CMP, or the core will run into unknown state.
N     * |        |          |Note2: No matter TMR_CTL [TMR_EN] is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.
N    */
N    __IO uint32_t CMPR;
X    volatile uint32_t CMPR;
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x0C  Timer x Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TMR_IE    |Timer Interrupt Enable
N     * |        |          |0 = Timer Interrupt Disabled.
N     * |        |          |1 = Timer Interrupt Enabled.
N     * |        |          |Note: If timer interrupt is enabled, the timer asserts its interrupt signal when the associated counter is equal to TMR_CMPR.
N     * |[1]     |TCAP_IE   |Timer Capture Function Interrupt Enable
N     * |        |          |0 = Timer External Pin Function Interrupt Disabled.
N     * |        |          |1 = Timer External Pin Function Interrupt Enabled.
N     * |        |          |Note: If timer external pin function interrupt is enabled, the timer asserts its interrupt signal when the TCAP_EN is set and the transition of external pin matches the TCAP_EDGE setting
N    */
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N
N    /**
N     * ISR
N     * ===================================================================================================
N     * Offset: 0x10  Timer x Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TMR_IS    |Timer Interrupt Status
N     * |        |          |This bit indicates the interrupt status of Timer.
N     * |        |          |This bit is set by hardware when the up counting value of internal 24-bit counter matches the timer compared value (TMR_CMPR).
N     * |        |          |Write 1 to clear this bit to 0.
N     * |        |          |If this bit is active and TMR_IE is enabled, Timer will trigger an interrupt to CPU.
N     * |[1]     |TCAP_IS   |Timer Capture Function Interrupt Status
N     * |        |          |This bit indicates the external pin function interrupt status of Timer.
N     * |        |          |This bit is set by hardware when TCAP_EN is set high, and the transition of external pin matches the TCAP_EDGE setting.
N     * |        |          |Write 1 to clear this bit to zero.
N     * |        |          |If this bit is active and TCAP_IE is enabled, Timer will trigger an interrupt to CPU.
N     * |[4]     |TMR_Wake_STS|Timer Wake-Up Status
N     * |        |          |If timer causes CPU wakes up from power-down mode, this bit will be set to high.
N     * |        |          |It must be cleared by software with a write 1 to this bit.
N     * |        |          |0 = Timer does not cause system wake-up.
N     * |        |          |1 = Wakes system up from power-down mode by Timer timeout.
N     * |[5]     |NCAP_DET_STS|New Capture Detected Status
N     * |        |          |This status is to indicate there is a new incoming capture event detected before CPU clearing the TCAP_IS status.
N     * |        |          |If the above condition occurred, the Timer will keep register TMRx_CAP unchanged and drop the new capture value.
N     * |        |          |This bit is also cleared to 0 while TCAP_IS is cleared.
N     * |        |          |0 = New incoming capture event didn't detect before CPU clearing TCAP_IS status.
N     * |        |          |1 = New incoming capture event detected before CPU clearing TCAP_IS status.
N    */
N    __IO uint32_t ISR;
X    volatile uint32_t ISR;
N
N    /**
N     * DR
N     * ===================================================================================================
N     * Offset: 0x14  Timer x Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TDR       |Timer Data Register
N     * |        |          |User can read this register for internal 24-bit timer up-counter value.
N    */
N    __I  uint32_t DR;
X    volatile const  uint32_t DR;
N
N    /**
N     * TCAP
N     * ===================================================================================================
N     * Offset: 0x18  Timer x Capture Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CAP       |Timer Capture Data Register
N     * |        |          |When TCAP_EN is set, TCAP_MODE is 0, and the transition of external pin matches the TCAP_EDGE setting, the value of 24-bit up-counting timer will be saved into register TMRx_TCAP.
N     * |        |          |User can read this register for the counter value.
N    */
N    __I  uint32_t TCAP;
X    volatile const  uint32_t TCAP;
N} TIMER_T;
N
N
N/**
N    @addtogroup TMR_CONST TIMER Bit Field Definition
N    Constant Definitions for TIMER Controller
N@{ */
N
N#define TIMER_CTL_TMR_EN_Pos             (0)                                               /*!< TIMER_T::CTL: TMR_EN Position             */
N#define TIMER_CTL_TMR_EN_Msk             (0x1ul << TIMER_CTL_TMR_EN_Pos)                   /*!< TIMER_T::CTL: TMR_EN Mask                 */
N
N#define TIMER_CTL_SW_RST_Pos             (1)                                               /*!< TIMER_T::CTL: SW_RST Position               */
N#define TIMER_CTL_SW_RST_Msk             (0x1ul << TIMER_CTL_SW_RST_Pos)                   /*!< TIMER_T::CTL: SW_RST Mask                   */
N
N#define TIMER_CTL_WAKE_EN_Pos            (2)                                               /*!< TIMER_T::CTL: WAKE_EN Position              */
N#define TIMER_CTL_WAKE_EN_Msk            (0x1ul << TIMER_CTL_WAKE_EN_Pos)                  /*!< TIMER_T::CTL: WAKE_EN Mask                  */
N
N#define TIMER_CTL_DBGACK_EN_Pos          (3)                                               /*!< TIMER_T::CTL: DBGACK_EN Position            */
N#define TIMER_CTL_DBGACK_EN_Msk          (0x1ul << TIMER_CTL_DBGACK_EN_Pos)                /*!< TIMER_T::CTL: DBGACK_EN Mask                */
N
N#define TIMER_CTL_MODE_SEL_Pos           (4)                                               /*!< TIMER_T::CTL: MODE_SEL Position             */
N#define TIMER_CTL_MODE_SEL_Msk           (0x3ul << TIMER_CTL_MODE_SEL_Pos)                 /*!< TIMER_T::CTL: MODE_SEL Mask                 */
N
N#define TIMER_CTL_TMR_ACT_Pos            (7)                                               /*!< TIMER_T::CTL: TMR_ACT Position            */
N#define TIMER_CTL_TMR_ACT_Msk            (0x1ul << TIMER_CTL_TMR_ACT_Pos)                  /*!< TIMER_T::CTL: TMR_ACT Mask                */
N
N#define TIMER_CTL_ADC_TEEN_Pos           (8)                                               /*!< TIMER_T::CTL: ADC_TEEN Position             */
N#define TIMER_CTL_ADC_TEEN_Msk           (0x1ul << TIMER_CTL_ADC_TEEN_Pos)                 /*!< TIMER_T::CTL: ADC_TEEN Mask                 */
N
N#define TIMER_CTL_DAC_TEEN_Pos           (9)                                               /*!< TIMER_T::CTL: DAC_TEEN Position             */
N#define TIMER_CTL_DAC_TEEN_Msk           (0x1ul << TIMER_CTL_DAC_TEEN_Pos)                 /*!< TIMER_T::CTL: DAC_TEEN Mask                 */
N
N#define TIMER_CTL_PDMA_TEEN_Pos          (10)                                              /*!< TIMER_T::CTL: PDMA_TEEN Position            */
N#define TIMER_CTL_PDMA_TEEN_Msk          (0x1ul << TIMER_CTL_PDMA_TEEN_Pos)                /*!< TIMER_T::CTL: PDMA_TEEN Mask                */
N
N#define TIMER_CTL_CAP_TRG_EN_Pos         (11)                                              /*!< TIMER_T::CTL: CAP_TRG_EN Position           */
N#define TIMER_CTL_CAP_TRG_EN_Msk         (0x1ul << TIMER_CTL_CAP_TRG_EN_Pos)               /*!< TIMER_T::CTL: CAP_TRG_EN Mask               */
N
N#define TIMER_CTL_EVENT_EN_Pos           (12)                                              /*!< TIMER_T::CTL: EVENT_EN Position             */
N#define TIMER_CTL_EVENT_EN_Msk           (0x1ul << TIMER_CTL_EVENT_EN_Pos)                 /*!< TIMER_T::CTL: EVENT_EN Mask                 */
N
N#define TIMER_CTL_EVENT_EDGE_Pos         (13)                                              /*!< TIMER_T::CTL: EVENT_EDGE Position           */
N#define TIMER_CTL_EVENT_EDGE_Msk         (0x1ul << TIMER_CTL_EVENT_EDGE_Pos)               /*!< TIMER_T::CTL: EVENT_EDGE Mask               */
N
N#define TIMER_CTL_EVNT_DEB_EN_Pos        (14)                                              /*!< TIMER_T::CTL: EVNT_DEB_EN Position          */
N#define TIMER_CTL_EVNT_DEB_EN_Msk        (0x1ul << TIMER_CTL_EVNT_DEB_EN_Pos)              /*!< TIMER_T::CTL: EVNT_DEB_EN Mask              */
N
N#define TIMER_CTL_TCAP_EN_Pos            (16)                                              /*!< TIMER_T::CTL: TCAP_EN Position              */
N#define TIMER_CTL_TCAP_EN_Msk            (0x1ul << TIMER_CTL_TCAP_EN_Pos)                  /*!< TIMER_T::CTL: TCAP_EN Mask                  */
N
N#define TIMER_CTL_TCAP_MODE_Pos          (17)                                              /*!< TIMER_T::CTL: TCAP_MODE Position            */
N#define TIMER_CTL_TCAP_MODE_Msk          (0x1ul << TIMER_CTL_TCAP_MODE_Pos)                /*!< TIMER_T::CTL: TCAP_MODE Mask                */
N
N#define TIMER_CTL_TCAP_EDGE_Pos          (18)                                              /*!< TIMER_T::CTL: TCAP_EDGE Position            */
N#define TIMER_CTL_TCAP_EDGE_Msk          (0x3ul << TIMER_CTL_TCAP_EDGE_Pos)                /*!< TIMER_T::CTL: TCAP_EDGE Mask                */
N
N#define TIMER_CTL_TCAP_CNT_MODE_Pos      (20)                                              /*!< TIMER_T::CTL: TCAP_CNT_MODE Position        */
N#define TIMER_CTL_TCAP_CNT_MODE_Msk      (0x1ul << TIMER_CTL_TCAP_CNT_MODE_Pos)            /*!< TIMER_T::CTL: TCAP_CNT_MODE Mask            */
N
N#define TIMER_CTL_TCAP_DEB_EN_Pos        (22)                                              /*!< TIMER_T::CTL: TCAP_DEB_EN Position          */
N#define TIMER_CTL_TCAP_DEB_EN_Msk        (0x1ul << TIMER_CTL_TCAP_DEB_EN_Pos)              /*!< TIMER_T::CTL: TCAP_DEB_EN Mask              */
N
N#define TIMER_CTL_INTR_TRG_EN_Pos        (24)                                              /*!< TIMER_T::CTL: INTR_TRG_EN Position          */
N#define TIMER_CTL_INTR_TRG_EN_Msk        (0x1ul << TIMER_CTL_INTR_TRG_EN_Pos)              /*!< TIMER_T::CTL: INTR_TRG_EN Mask              */
N
N#define TIMER_PRECNT_PRESCALE_CNT_Pos    (0)                                               /*!< TIMER_T::PRECNT: PRESCALE_CNT Position      */
N#define TIMER_PRECNT_PRESCALE_CNT_Msk    (0xfful << TIMER_PRECNT_PRESCALE_CNT_Pos)         /*!< TIMER_T::PRECNT: PRESCALE_CNT Mask          */
N
N#define TIMER_CMPR_TMR_CMP_Pos           (0)                                               /*!< TIMER_T::CMPR: TMR_CMP Position           */
N#define TIMER_CMPR_TMR_CMP_Msk           (0xfffffful << TIMER_CMPR_TMR_CMP_Pos)            /*!< TIMER_T::CMPR: TMR_CMP Mask               */
N
N#define TIMER_IER_TMR_IE_Pos             (0)                                               /*!< TIMER_T::IER: TMR_IE Position             */
N#define TIMER_IER_TMR_IE_Msk             (0x1ul << TIMER_IER_TMR_IE_Pos)                   /*!< TIMER_T::IER: TMR_IE Mask                 */
N
N#define TIMER_IER_TCAP_IE_Pos            (1)                                               /*!< TIMER_T::IER: TCAP_IE Position              */
N#define TIMER_IER_TCAP_IE_Msk            (0x1ul << TIMER_IER_TCAP_IE_Pos)                  /*!< TIMER_T::IER: TCAP_IE Mask                  */
N
N#define TIMER_ISR_TMR_IS_Pos             (0)                                               /*!< TIMER_T::ISR: TMR_IS Position             */
N#define TIMER_ISR_TMR_IS_Msk             (0x1ul << TIMER_ISR_TMR_IS_Pos)                   /*!< TIMER_T::ISR: TMR_IS Mask                 */
N
N#define TIMER_ISR_TCAP_IS_Pos            (1)                                               /*!< TIMER_T::ISR: TCAP_IS Position              */
N#define TIMER_ISR_TCAP_IS_Msk            (0x1ul << TIMER_ISR_TCAP_IS_Pos)                  /*!< TIMER_T::ISR: TCAP_IS Mask                  */
N
N#define TIMER_ISR_TMR_WAKE_STS_Pos       (4)                                               /*!< TIMER_T::ISR: TMR_WAKE_STS Position       */
N#define TIMER_ISR_TMR_WAKE_STS_Msk       (0x1ul << TIMER_ISR_TMR_WAKE_STS_Pos)             /*!< TIMER_T::ISR: TMR_WAKE_STS Mask           */
N
N#define TIMER_ISR_NCAP_DET_STS_Pos       (5)                                               /*!< TIMER_T::ISR: NCAP_DET_STS Position         */
N#define TIMER_ISR_NCAP_DET_STS_Msk       (0x1ul << TIMER_ISR_NCAP_DET_STS_Pos)             /*!< TIMER_T::ISR: NCAP_DET_STS Mask             */
N
N#define TIMER_DR_TDR_Pos                 (0)                                               /*!< TIMER_T::DR: TDR Position                   */
N#define TIMER_DR_TDR_Msk                 (0xfffffful << TIMER_DR_TDR_Pos)                  /*!< TIMER_T::DR: TDR Mask                       */
N
N#define TIMER_TCAP_CAP_Pos               (0)                                               /*!< TIMER_T::TCAP: CAP Position                 */
N#define TIMER_TCAP_CAP_Msk               (0xfffffful << TIMER_TCAP_CAP_Pos)                /*!< TIMER_T::TCAP: CAP Mask                     */
N
N/**@}*/ /* TMR_CONST */
N
N
N/**@}*/ /* end of TMR register group */
N
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    union
N    {
N
N        /**
N         * RBR
N         * ===================================================================================================
N         * Offset: 0x00  UART Receive Buffer Register
N         * ---------------------------------------------------------------------------------------------------
N         * |Bits    |Field     |Descriptions
N         * | :----: | :----:   | :---- |
N         * |[7:0]   |RBR       |Receiving Buffer
N         * |        |          |By reading this register, the UART Controller will return an 8-bit data received from RX pin (LSB first).
N        */
N        __I  uint32_t  RBR;
X        volatile const  uint32_t  RBR;
N
N
N        /**
N         * THR
N         * ===================================================================================================
N         * Offset: 0x00  UART Transmit Buffer Register
N         * ---------------------------------------------------------------------------------------------------
N         * |Bits    |Field     |Descriptions
N         * | :----: | :----:   | :---- |
N         * |[7:0]   |THR       |Transmit Buffer
N         * |        |          |By writing to this register, the UART sends out an 8-bit data through the TX pin (LSB first).
N        */
N        __O  uint32_t  THR;
X        volatile  uint32_t  THR;
N    };
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x04  UART Control State Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_RST    |RX Software Reset
N     * |        |          |When RX_RST is set, all the bytes in the receiving FIFO and RX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the RX internal state machine and pointers.
N     * |        |          |Note: This bit will be auto cleared and take at least 3 UART engine clock cycles.
N     * |[1]     |TX_RST    |TX Software Reset
N     * |        |          |When TX_RST is set, all the bytes in the transmitting FIFO and TX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the TX internal state machine and pointers.
N     * |        |          |Note: This bit will be auto cleared and take at least 3 UART engine clock cycles.
N     * |[2]     |RX_DIS    |Receiver Disable Register
N     * |        |          |The receiver is disabled or not (set "1" to disable receiver)
N     * |        |          |0 = Receiver Enabled.
N     * |        |          |1 = Receiver Disabled.
N     * |        |          |Note1: When used for RS-485 NMM mode, user can set this bit to receive data before detecting address byte.
N     * |        |          |Note2: In RS-485 AAD mode, this bit will be setting to "1" automatically.
N     * |        |          |Note3: In RS-485 AUD mode and LIN "break + sync +PID" header mode, hardware will control data automatically, so don't fill any value to this bit.
N     * |[3]     |TX_DIS    |Transfer Disable Register
N     * |        |          |The transceiver is disabled or not (set "1" to disable transceiver)
N     * |        |          |0 = Transfer Enabled.
N     * |        |          |1 = Transfer Disabled.
N     * |[4]     |AUTO_RTS_EN|RTSn Auto-Flow Control Enable
N     * |        |          |0 = RTSn auto-flow control. Disabled.
N     * |        |          |1 = RTSn auto-flow control Enabled.
N     * |        |          |Note: When RTSn auto-flow is enabled, if the number of bytes in the RX-FIFO equals the UART_FCR [RTS_Tri_Lev], the UART will reassert RTSn signal.
N     * |[5]     |AUTO_CTS_EN|CTSn Auto-Flow Control Enable
N     * |        |          |0 = CTSn auto-flow control. Disabled
N     * |        |          |1 = CTSn auto-flow control Enabled.
N     * |        |          |Note: When CTSn auto-flow is enabled, the UART will send data to external device when CTSn input assert (UART will not send data to device until CTSn is asserted).
N     * |[6]     |DMA_RX_EN |RX DMA Enable
N     * |        |          |This bit can enable or disable RX PDMA service.
N     * |        |          |0 = RX PDMA service function Disabled.
N     * |        |          |1 = RX PDMA service function Enabled.
N     * |[7]     |DMA_TX_EN |TX DMA Enable
N     * |        |          |This bit can enable or disable TX PDMA service.
N     * |        |          |0 = TX PDMA service function Disabled.
N     * |        |          |1 = TX PDMA service function Enabled.
N     * |[8]     |WAKE_CTS_EN|CTSn Wake-Up Function Enable
N     * |        |          |0 = CTSn wake-up system function Disabled.
N     * |        |          |1 = Wake-up function Enabled when the system is in power-down mode, an external CTSn change will wake-up system from power-down mode.
N     * |[9]     |WAKE_DATA_EN|Incoming Data Wake-Up Function Enable
N     * |        |          |0 = Incoming data wake-up system Disabled.
N     * |        |          |1 = Incoming data wake-up function Enabled when the system is in power-down mode, incoming data will wake-up system from power-down mode.
N     * |        |          |Note: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable
N     * |[12]    |ABAUD_EN  |Auto-Baud Rate Detect Enable
N     * |        |          |0 = Auto-baud rate detect function Disabled.
N     * |        |          |1 = Auto-baud rate detect function Enabled.
N     * |        |          |Note: When the auto-baud rate detect operation finishes, hardware will clear this bit and the associated interrupt (INT_ABAUD) will be generated (If UART_IER [ABAUD_IE] be enabled).
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * TLCTL
N     * ===================================================================================================
N     * Offset: 0x08  UART Transfer Line Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |DATA_LEN  |Data Length
N     * |        |          |00 = 5 bits.
N     * |        |          |01 = 6 bits.
N     * |        |          |10 = 7 bits.
N     * |        |          |11 = 8 bits.
N     * |[2]     |NSB       |Number Of STOP Bit Length
N     * |        |          |1 = 1.5 "STOP bit" is generated in the transmitted data when 5-bit word length is selected, and 2 STOP bit" is generated when 6, 7 and 8 bits data length is selected.
N     * |        |          |0 = 1 " STOP bit" is generated in the transmitted data.
N     * |[3]     |PBE       |Parity Bit Enable
N     * |        |          |1 = Parity bit is generated or checked bet"een the "last data"word "it" and "stop bit" of the serial data.
N     * |        |          |0 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
N     * |[4]     |EPE       |Even Parity Enable
N     * |        |          |1 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
N     * |        |          |0 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
N     * |        |          |Note: This bit has effect only when PBE bit (parity bit enable) is set.
N     * |[5]     |SPE       |Stick Parity Enable
N     * |        |          |1 = When bits PBE, EPE and SPE are set, the parity bit is transmitted and checked as "0".
N     * |        |          |When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as "1".
N     * |        |          |In RS-485 mode, PBE, EPE and SPE can control bit 9.
N     * |        |          |0 = Stick parity Disabled.
N     * |[6]     |BCB       |Break Control Bit
N     * |        |          |When this bit is set to logic "1", the serial data output (TX) is forced to the Spacing State (logic "0").
N     * |        |          |This bit acts only on TX pin and has no effect on the transmitter logic.
N     * |[9:8]   |RFITL     |RX-FIFO Interrupt (INT_RDA) Trigger Level
N     * |        |          |When the number of bytes in the receiving FIFO is equal to the RFITL then the RDA_IF will be set (if IER [RDA_IEN] is enabled, an interrupt will be generated)
N     * |        |          |00 = INTR_RDA Trigger Level 1 byte.
N     * |        |          |01 = INTR_RDA Trigger Level 4 byte.
N     * |        |          |10 = INTR_RDA Trigger Level 8 byte.
N     * |        |          |11 = INTR_RDA Trigger Level 14 byte.
N     * |        |          |Note: When operating in IrDA mode or RS-485 mode, the RFITL must be set to "0".
N     * |[13:12] |RTS_TRI_LEV|RTSn Trigger Level (For Auto-Flow Control Use)
N     * |        |          |00 = Trigger level 1 byte.
N     * |        |          |01 = Trigger level 4 bytes.
N     * |        |          |10 = Trigger level 8 bytes.
N     * |        |          |11 = Trigger level 14 bytes.
N     * |        |          |Note: This field is used for auto RTSn flow control.
N    */
N    __IO uint32_t TLCTL;
X    volatile uint32_t TLCTL;
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x0C  UART Interrupt Enable Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IE    |Receive Data Available Interrupt Enable
N     * |        |          |0 = INT_RDA Masked off.
N     * |        |          |1 = INT_RDA Enabled.
N     * |[1]     |THRE_IE   |Transmit Holding Register Empty Interrupt Enable
N     * |        |          |0 = INT_THRE Masked off.
N     * |        |          |1 = INT_THRE Enabled.
N     * |[2]     |RLS_IE    |Receive Line Status Interrupt Enable
N     * |        |          |0 = INT_RLS Masked off.
N     * |        |          |1 = INT_RLS Enabled.
N     * |[3]     |MODEM_IE  |Modem Status Interrupt Enable
N     * |        |          |0 = INT_MOS Masked off.
N     * |        |          |1 = INT_MOS Enabled.
N     * |[4]     |RTO_IE    |RX Time-Out Interrupt Enable
N     * |        |          |0 = INT_TOUT Masked off.
N     * |        |          |1 = INT_TOUT Enabled.
N     * |[5]     |BUF_ERR_IE|Buffer Error Interrupt Enable
N     * |        |          |0 = INT_BUT_ERR Masked off.
N     * |        |          |1 = INT_BUF_ERR Enabled.
N     * |[6]     |WAKE_IE   |Wake-Up Interrupt Enable
N     * |        |          |0 = INT_WAKE Masked off.
N     * |        |          |1 = INT_WAKE Enabled.
N     * |[7]     |ABAUD_IE  |Auto-Baud Rate Interrupt Enable
N     * |        |          |0 = INT_ABAUD Masked off.
N     * |        |          |1 = INT_ABAUD Enabled.
N     * |[8]     |LIN_IE    |LIN Interrupt Enable
N     * |        |          |0 = INT_LIN Masked off.
N     * |        |          |1 = INT_LIN Enabled.
N    */
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N
N    /**
N     * ISR
N     * ===================================================================================================
N     * Offset: 0x10  UART Interrupt Status Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IS    |Receive Data Available Interrupt Flag (Read Only)
N     * |        |          |When the number of bytes in the RX-FIFO equals the RFITL then the RDA_IF will be set.
N     * |        |          |If IER [RDA_IEN] is set then the RDA interrupt will be generated.
N     * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX-FIFO drops below the threshold level (RFITL).
N     * |[1]     |THRE_IS   |Transmit Holding Register Empty Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the last data of TX-FIFO is transferred to Transmitter Shift Register.
N     * |        |          |If IER [THRE_IEN] is set that the THRE interrupt will be generated.
N     * |        |          |Note: This bit is read only and it will be cleared when writing data into THR (TX-FIFO not empty).
N     * |[2]     |RLS_IS    |Receive Line Interrupt Status Flag (Read Only)
N     * |        |          |This bit is set when the RX received data has parity error (UART_FSR [PE_F]), framing error (UART_FSR [FE_F]), break error (UART_FSR [BI_F]) or RS-485 detect address byte (UART_TRSR [RS-485_ADDET_F]).If IER [RLS_IEN] is set then the RLS interrupt will be generated.
N     * |        |          |Note1: This bit is read only, but can be cleared by it by writing "1" to UART_FSR [BI_F], UART_FSR [FE_F], UART_FSR [PE_F] or UART_TRSR [RS-485_ADDET_F].
N     * |        |          |Note2: This bit is cleared when all the BI_F, FE_F, PE_F and RS-485_ADDET_F are cleared.
N     * |[3]     |MODEM_IS  |MODEM Interrupt Status Flag (Read Only)
N     * |        |          |This bit is set when the CTSn pin has state change (DCTSF = "1").
N     * |        |          |If IER [MODEM_IEN] is set then the modem interrupt will be generated.
N     * |        |          |Note: This bit is read only, but can be cleared by it by writing "1" to UART_MCSR [DCT_F].
N     * |[4]     |RTO_IS    |RX Time-Out Interrupt Status Flag (Read Only)
N     * |        |          |This bit is set when the RX-FIFO is not empty and no activities occur in the RX-FIFO and the time-out counter equal to TOIC.
N     * |        |          |If IER [Tout_IEN] is set then the tout interrupt will be generated.
N     * |        |          |Note: This bit is read only and user can read UART_RBR (RX is in active) to clear it.
N     * |[5]     |BUF_ERR_IS|Buffer Error Interrupt Status Flag (Read Only)
N     * |        |          |This bit is set when the TX or RX-FIFO overflowed.
N     * |        |          |When BUF_ERR_IS is set, the transfer maybe not correct.
N     * |        |          |If IER [BUF_ER_IEN] is set then the buffer error interrupt will be generated.
N     * |        |          |Note1: This bit is read only, but can be cleared by it by writing "1" to UART_FSR [TX_OVER_F] or UART_FSR [RX_OVER_F].
N     * |        |          |Note2: This bit is cleared when both the TX_OVER_F and RX_OVER_F are cleared.
N     * |[6]     |WAKE_IS   |Wake-Up Interrupt Status Flag (Read Only)
N     * |        |          |This bit is set in Power-down mode, the receiver received data or CTSn signal.
N     * |        |          |If IER [WAKE_IE] is set then the wake-up interrupt will be generated.
N     * |        |          |Note: This bit is read only, but can be cleared by it by writing "1" to it.
N     * |[7]     |ABAUD_IS  |Auto-Baud Rate Interrupt Status Flag (Read Only)
N     * |        |          |This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if IER [ABAUD_IE] is set then the auto-baud rate interrupt will be generated.
N     * |        |          |Note1: This bit is read only, but can be cleared by it by writing "1" to UART_TRSR [ABAUD_TOUT_F] or UART_TRSR [ABAUD_F].
N     * |        |          |Note2: This bit is cleared when both the ABAUD_TOUT_F and ABAUD_F are cleared.
N     * |[8]     |LIN_IS    |LIN Interrupt Status Flag (Read Only)
N     * |        |          |This bit is set when the LIN TX header transmitted, RX header received or the SIN does not equal SOUT and if IER [LIN_IE] is set then the LIN interrupt will be generated.
N     * |        |          |Note1: This bit is read only, but can be cleared by it by writing "1" to UART_TRSR [BIT_ERR_F], UART_TRSR [BIT_TX_F] or UART_TRSR [LIN_RX_F].
N     * |        |          |Note2: This bit is cleared when both the BIT_ERR_F, BIT_TX_F and LIN_RX_F are cleared.
N    */
N    __IO  uint32_t ISR;
X    volatile  uint32_t ISR;
N
N    /**
N     * TRSR
N     * ===================================================================================================
N     * Offset: 0x14  UART Transfer State Status Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RS485_ADDET_F|RS-485 Address Byte Detection Status Flag (Read Only)
N     * |        |          |This bit is set to logic "1" and set UART_ALT_CTL [RS-485_ADD_EN] whenever in RS-485 mode the receiver detected any address byte character (bit 9 ='1') bit".
N     * |        |          |This bit is reset whenever the CPU writes "1" to this bit.
N     * |        |          |Note1: This field is used for RS-485 mode.
N     * |        |          |Note2: This bit is read only, but can be cleared by writing "1" to it.
N     * |[1]     |ABAUD_F   |Auto-Baud Rate Interrupt (Read Only)
N     * |        |          |This bit is set to logic "1" when auto-baud rate detect function finished.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[2]     |ABAUD_TOUT_F|Auto-Baud Rate Time-Out Interrupt (Read Only)
N     * |        |          |This bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[3]     |LIN_TX_F  |LIN TX Interrupt Flag (Read Only)
N     * |        |          |This bit is set to logic "1" when LIN transmitted header field.
N     * |        |          |The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", it can be choose by setting UART_ALT_CTL[LIN_HEAD_SEL] register.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[4]     |LIN_RX_F  |LIN RX Interrupt Flag (Read Only)
N     * |        |          |This bit is set to logic "1" when received LIN header field.
N     * |        |          |The header may be "break field" or "break field + sync field" or "break field + sync field + PID field", and it can be choose by setting UART_ALT_CTL [LIN_HEAD_SEL] register.
N     * |        |          |If the field includes "break field", when the receiver received break field then the LIN_RX_F will be set.
N     * |        |          |The controller will receive next data and put it in FIFO.
N     * |        |          |If the field includes "break field + sync field", hardware will wait for the flag LIN_RX_F in UART_TRSR to check RX received break field and sync field.
N     * |        |          |If the break and sync field is received, hardware will set UART_TRSR [LIN_RX_F] flag, and if the break is received but the sync field does not equal 0x55, then hardware will set UART_TRSR [LIN_RX_F] and UART_TRSR [LIN_RX_SYNC_ERR_F] flag.
N     * |        |          |The break and sync data (equals 0x55 or not) will not be stored in FIFO.
N     * |        |          |If the field includes "break field + sync field + PID field", In this operation mode, hardware will control data automatically.
N     * |        |          |Hardware will ignore any data until received break + sync (0x55) + PID value match the UART_ALT_CTL [ADDR_MATCH] value (break + sync + PID will not be stored in FIFO).
N     * |        |          |When received break + sync (0x55) + PID value match the UART_ALT_CTL [ADDR_MATCH] value, hardware will set UART_TRSR [LIN_RX_F] and the following all data will be accepted and stored in the RX-FIFO until detect next break field.
N     * |        |          |If the receiver received break + wrong sync (not equal 0x55) + PID value, hardware will set UART_TRSR [LIN_RX_F] and UART_TRSR [LIN_RX_SYNC_ERR_F] flag and the receiver will be disabled.
N     * |        |          |If the receiver received break + sync (0x55) + wrong PID value, hardware will set UART_TRSR [LIN_RX_F] flag and the receiver will be disabled.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[5]     |BIT_ERR_F |Bit Error Detect Status Flag (Read Only)
N     * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state is not equal to the output pin (SOUT) state, BIT_ERR_F will be set.
N     * |        |          |When occur bit error, hardware will generate an interrupt to CPU (INT_LIN).
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2: This bit is only valid when enabling the bit error detection function (UART_ALT_CTL [BIT_ERR_EN] = "1").
N     * |[8]     |LIN_RX_SYNC_ERR_F|LIN RX SYNC Error Flag (Read Only)
N     * |        |          |This bit is set to logic "1" when LIN received incorrect SYNC field.
N     * |        |          |User can choose the header by setting UART_ALT_CTL [LIN_HEAD_SEL] register.
N     * |        |          |If the field includes "break field + sync field" and if the sync data does not equal 0x55, the LIN_RX_F and LIN_RX_SYNC_ERR_F will be set and the wrong sync data will be ignored.
N     * |        |          |The controller will receive next data and put it in FIFO.
N     * |        |          |If the field includes "break field + sync field + PID field" and if the sync data does not equal 0x55, the LIN_RX_F and LIN_RX_SYNC_ERR_F will be set and the wrong sync data will be ignored.
N     * |        |          |The controller will receive next data and put it in FIFO.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to LIN_RX_F.
N    */
N    __IO  uint32_t TRSR;
X    volatile  uint32_t TRSR;
N
N    /**
N     * FSR
N     * ===================================================================================================
N     * Offset: 0x18  UART FIFO State Status Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_OVER_F |RX Overflow Error Status Flag (Read Only)
N     * |        |          |This bit is set when RX-FIFO overflow.
N     * |        |          |If the number of bytes of received data is greater than RX-FIFO (UART_RBR) size, 16 bytes of UART0/UART1, this bit will be set.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[1]     |RX_EMPTY_F|Receiver FIFO Empty (Read Only)
N     * |        |          |This bit initiate RX-FIFO empty or not.
N     * |        |          |When the last byte of RX-FIFO has been read by CPU, hardware sets this bit high.
N     * |        |          |It will be cleared when UART receives any new data.
N     * |[2]     |RX_FULL_F |Receiver FIFO Full (Read Only)
N     * |        |          |This bit initiates RX-FIFO full or not.
N     * |        |          |This bit is set when RX_POINTER_F is equal to 16, otherwise is cleared by hardware.
N     * |[4]     |PE_F      |Parity Error State Status Flag (Read Only)
N     * |        |          |This bit is set to logic "1" whenever the received character does not have a valid "parity bit", and it is reset whenever the CPU writes "1" to this bit.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[5]     |FE_F      |Framing Error Status Flag (Read Only)
N     * |        |          |This bit is set to logic "1" whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic "0"), and it is reset whenever the CPU writes "1" to this bit.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[6]     |BI_F      |Break Status Flag (Read Only)
N     * |        |          |This bit is set to a logic "1" whenever the received data input(RX) is held in the "spacing state" (logic "0") for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and it is reset whenever the CPU writes "1" to this bit.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[8]     |TX_OVER_F |TX Overflow Error Interrupt Status Flag (Read Only)
N     * |        |          |If TX-FIFO (UART_THR) is full, an additional write to UART_THR will cause this bit to logic "1".
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N     * |[9]     |TX_EMPTY_F|Transmitter FIFO Empty (Read Only)
N     * |        |          |This bit indicates TX-FIFO empty or not.
N     * |        |          |When the last byte of TX-FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
N     * |        |          |It will be cleared when writing data into THR (TX-FIFO not empty).
N     * |[10]    |TX_FULL_F |Transmitter FIFO Full (Read Only)
N     * |        |          |This bit indicates TX-FIFO full or not.
N     * |        |          |This bit is set when TX_POINTER_F is equal to 16, otherwise is cleared by hardware.
N     * |[11]    |TE_F      |Transmitter Empty Status Flag (Read Only)
N     * |        |          |Bit is set by hardware when TX is inactive. (TX shift register does not have data)
N     * |        |          |Bit is cleared automatically when TX-FIFO is transfer data to TX shift register or TX is empty but the transfer does not finish.
N     * |[20:16] |RX_POINTER_F|RX-FIFO Pointer (Read Only)
N     * |        |          |This field indicates the RX-FIFO Buffer Pointer.
N     * |        |          |When UART receives one byte from external device, RX_POINTER_F increases one.
N     * |        |          |When one byte of RX-FIFO is read by CPU, RX_POINTER_F decreases one.
N     * |[28:24] |TX_POINTER_F|TX-FIFO Pointer (Read Only)
N     * |        |          |This field indicates the TX-FIFO Buffer Pointer.
N     * |        |          |When CPU writes one byte data into UART_THR, TX_POINTER_F increases one.
N     * |        |          |When one byte of TX-FIFO is transferred to Transmitter Shift Register, TX_POINTER_F decreases one.
N    */
N    __IO  uint32_t FSR;
X    volatile  uint32_t FSR;
N
N    /**
N     * MCSR
N     * ===================================================================================================
N     * Offset: 0x1C  UART Modem State Status Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LEV_RTS   |RTSn Trigger Level
N     * |        |          |This bit can change the RTSn trigger level.
N     * |        |          |0 = low level triggered.
N     * |        |          |1 = high level triggered.
N     * |        |          |Note: In RS-485 AUD mode and RTS Auto-flow control mode, hardware will control the output RTS pin automatically, so the table indicates the default value.
N     * |        |          |Note: The default setting in UART mode is LEV_RTS = "0" and RTS_ST = "1".
N     * |[1]     |RTS_ST    |RTSn Pin State (Read Only)
N     * |        |          |This bit is the pin status of RTSn.
N     * |[16]    |LEV_CTS   |CTSn Trigger Level
N     * |        |          |This bit can change the CTSn trigger level.
N     * |        |          |0 = Low level triggered.
N     * |        |          |1 = High level triggered.
N     * |[17]    |CTS_ST    |CTSn Pin Status (Read Only)
N     * |        |          |This bit is the pin status of CTSn.
N     * |[18]    |DCT_F     |Detect CTSn State Change Status Flag (Read Only)
N     * |        |          |This bit is set whenever CTSn input has change state, and it will generate Modem interrupt to CPU when UART_IER [Modem_IEN].
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to it.
N    */
N    __IO uint32_t MCSR;
X    volatile uint32_t MCSR;
N
N    /**
N     * TMCTL
N     * ===================================================================================================
N     * Offset: 0x20  UART Time-Out Control State Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |TOIC      |Time-Out Comparator
N     * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX-FIFO receives a new data word.
N     * |        |          |Once the content of time-out counter (TOUT_CNT) is equal to time-out interrupt comparator (TOIC), a receiver time-out interrupt (INT_TOUT) is generated if UART_IER [RTO_IEN].
N     * |        |          |A new incoming data word or RX-FIFO empty clears INT_TOUT.
N     * |        |          |Note1: Fill all "0" to this field indicates to disable this function.
N     * |        |          |Note2: The real time-out value is TOIC + 1.
N     * |        |          |Note3: The counting clock is baud rate clock.
N     * |        |          |Note4: The UART data format is start bit + 8 data bits + parity bit + stop bit, although software can configure this field by any value but it is recommend to filled this field great than 0xA.
N     * |[23:16] |DLY       |TX Delay Time Value
N     * |        |          |This field is use to program the transfer delay time between the last stop bit leaving the TX-FIFO and the de-assertion of by setting UART_TMCTL [DLY] register.
N     * |        |          |Note1: Fill all "0" to this field indicates to disable this function.
N     * |        |          |Note2: The real delay value is DLY.
N     * |        |          |Note3: The counting clock is baud rate clock.
N    */
N    __IO uint32_t TMCTL;
X    volatile uint32_t TMCTL;
N
N    /**
N     * BAUD
N     * ===================================================================================================
N     * Offset: 0x24  UART Baud Rate Divisor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |BRD       |Baud Rate Divider
N     * |[31]    |DIV_16_EN |Divider 16 Enable
N     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is  Baud Rate = UART_CLK/ [16 * (BRD + 1)]; The default value of M is 16.
N     * |        |          |0 = The equation of baud rate is UART_CLK / [ (BRD+1)].
N     * |        |          |1 = The equation of baud rate is UART_CLK / [16 * (BRD+1)].
N     * |        |          |Note: In IrDA mode, this bit must disable.
N    */
N    __IO uint32_t BAUD;
X    volatile uint32_t BAUD;
N    uint32_t RESERVE0[2];
N
N
N    /**
N     * IRCR
N     * ===================================================================================================
N     * Offset: 0x30  UART IrDA Control Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TX_SELECT |TX_SELECT
N     * |        |          |0 = IrDA receiver Enabled.
N     * |        |          |1 = IrDA transmitter Enabled.
N     * |        |          |Note: In IrDA mode, the UART_BAUD [DIV_16_EN) register must be set (the baud equation must be Clock / 16 * (BRD)
N     * |[5]     |INV_TX    |INV_TX
N     * |        |          |0 = No inversion.
N     * |        |          |1 = Inverse TX output signal.
N     * |[6]     |INV_RX    |INV_RX
N     * |        |          |0 = No inversion.
N     * |        |          |1 = Inverse RX input signal.
N    */
N    __IO uint32_t IRCR;
X    volatile uint32_t IRCR;
N
N    /**
N     * ALT_CTL
N     * ===================================================================================================
N     * Offset: 0x34  UART Alternate Control State Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |LIN_TX_BCNT|LIN TX Break Field Count Register
N     * |        |          |The field contains 3-bit LIN TX break field count.
N     * |        |          |Note: The break field length is LIN_TX_BCNT + 8.
N     * |[5:4]   |LIN_HEAD_SEL|LIN Header Selection
N     * |        |          |00 = The LIN header includes "break field".
N     * |        |          |01 = The LIN header includes "break field + sync field".
N     * |        |          |10 = The LIN header includes "break field + sync field + PID field".
N     * |        |          |11 = Reserved.
N     * |[6]     |LIN_RX_EN |LIN RX Enable
N     * |        |          |When LIN RX mode enabled and received a break field or sync field or PID field (Select by LIN_Header_SEL), the controller will generator a interrupt to CPU (INT_LIN)
N     * |        |          |0 = LIN RX mode Disabled.
N     * |        |          |1 = LIN RX mode Enabled.
N     * |[7]     |LIN_TX_EN |LIN TX Header Trigger Enable
N     * |        |          |0 = LIN TX Header Trigger Disabled.
N     * |        |          |1 = LIN TX Header Trigger Enabled.
N     * |        |          |Note1: When TX header field (break field or break and sync field or break, sync and PID field) transfer operation finished, this bit will be cleared automatically and generate a interrupt to CPU (INT_LIN).
N     * |        |          |Note2: If user wants to receive transmit data, it recommended to enable LIN_RX_EN bit.
N     * |[8]     |Bit_ERR_EN|Bit Error Detect Enable
N     * |        |          |0 = Bit error detection function Disabled.
N     * |        |          |1 = Bit error detection Enabled.
N     * |        |          |Note: In LIN function mode, when bit error occurs, hardware will generate an interrupt to CPU (INT_LIN).
N     * |[16]    |RS485_NMM |RS-485 Normal Multi-Drop Operation Mode (RS-485 NMM Mode)
N     * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
N     * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
N     * |        |          |Note: It can't be active in RS-485_AAD Operation mode.
N     * |[17]    |RS485_AAD |RS-485 Auto Address Detection Operation Mode (RS-485 AAD Mode)
N     * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
N     * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
N     * |        |          |Note: It can't be active in RS-485_NMM Operation mode.
N     * |[18]    |RS485_AUD |RS-485 Auto Direction Mode (RS-485 AUD Mode)
N     * |        |          |0 = RS-485 Auto Direction mode (AUD) Disabled.
N     * |        |          |1 = RS-485 Auto Direction mode (AUD) Enabled.
N     * |        |          |Note: It can be active in RS-485_AAD or RS-485_NMM operation mode.
N     * |[19]    |RS485_ADD_EN|RS-485 Address Detection Enable
N     * |        |          |This bit is used to enable RS-485 hardware address detection mode.
N     * |        |          |If hardware detects address byte, and then the controller will set UART_TRSR [RS485_ADDET_F] = "1".
N     * |        |          |0 = Address detection mode Disabled.
N     * |        |          |1 = Address detection mode Enabled.
N     * |        |          |Note: This field is used for RS-485 any operation mode.
N     * |[31:24] |ADDR_PID_MATCH|Address / PID Match Value Register
N     * |        |          |This field contains the RS-485 address match values in RS-485 Function mode.
N     * |        |          |This field contains the LIN protected identifier field n LIN Function mode, software fills ID0~ID5 (ADDR_PID_MATCH [5:0]), hardware will calculate P0 and P1.
N     * |        |          |Note: This field is used for RS-485 auto address detection mode or used for LIN protected identifier field (PID).
N    */
N    __IO uint32_t ALT_CTL;
X    volatile uint32_t ALT_CTL;
N
N    /**
N     * FUN_SEL
N     * ===================================================================================================
N     * Offset: 0x38  UART Function Select Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |FUN_SEL   |Function Select Enable
N     * |        |          |00 = UART function mode.
N     * |        |          |01 = LIN function mode.
N     * |        |          |10 = IrDA Function.
N     * |        |          |11 = RS-485 Function.
N    */
N    __IO uint32_t FUN_SEL;
X    volatile uint32_t FUN_SEL;
N
N} UART_T;
N
N/**
N    @addtogroup UART_CONST UART Bit Field Definition
N    Constant Definitions for UART Controller
N@{ */
N
N#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART_T::DAT: DAT Position                 */
N#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART_T::DAT: DAT Mask                     */
N
N#define UART_CTL_RX_RST_Pos              (0)                                               /*!< UART_T::CTL: RX_RST Position              */
N#define UART_CTL_RX_RST_Msk              (0x1ul << UART_CTL_RX_RST_Pos)                    /*!< UART_T::CTL: RX_RST Mask                  */
N
N#define UART_CTL_TX_RST_Pos              (1)                                               /*!< UART_T::CTL: TX_RST Position              */
N#define UART_CTL_TX_RST_Msk              (0x1ul << UART_CTL_TX_RST_Pos)                    /*!< UART_T::CTL: TX_RST Mask                  */
N
N#define UART_CTL_RX_DIS_Pos              (2)                                               /*!< UART_T::CTL: RX_DIS Position              */
N#define UART_CTL_RX_DIS_Msk              (0x1ul << UART_CTL_RX_DIS_Pos)                    /*!< UART_T::CTL: RX_DIS Mask                  */
N
N#define UART_CTL_TX_DIS_Pos              (3)                                               /*!< UART_T::CTL: TX_DIS Position              */
N#define UART_CTL_TX_DIS_Msk              (0x1ul << UART_CTL_TX_DIS_Pos)                    /*!< UART_T::CTL: TX_DIS Mask                  */
N
N#define UART_CTL_AUTO_RTS_EN_Pos         (4)                                               /*!< UART_T::CTL: AUTO_RTS_EN Position         */
N#define UART_CTL_AUTO_RTS_EN_Msk         (0x1ul << UART_CTL_AUTO_RTS_EN_Pos)               /*!< UART_T::CTL: AUTO_RTS_EN Mask             */
N
N#define UART_CTL_AUTO_CTS_EN_Pos         (5)                                               /*!< UART_T::CTL: AUTO_CTS_EN Position         */
N#define UART_CTL_AUTO_CTS_EN_Msk         (0x1ul << UART_CTL_AUTO_CTS_EN_Pos)               /*!< UART_T::CTL: AUTO_CTS_EN Mask             */
N
N#define UART_CTL_DMA_RX_EN_Pos           (6)                                               /*!< UART_T::CTL: DMA_RX_EN Position           */
N#define UART_CTL_DMA_RX_EN_Msk           (0x1ul << UART_CTL_DMA_RX_EN_Pos)                 /*!< UART_T::CTL: DMA_RX_EN Mask               */
N
N#define UART_CTL_DMA_TX_EN_Pos           (7)                                               /*!< UART_T::CTL: DMA_TX_EN Position           */
N#define UART_CTL_DMA_TX_EN_Msk           (0x1ul << UART_CTL_DMA_TX_EN_Pos)                 /*!< UART_T::CTL: DMA_TX_EN Mask               */
N
N#define UART_CTL_WAKE_CTS_EN_Pos         (8)                                               /*!< UART_T::CTL: WAKE_CTS_EN Position         */
N#define UART_CTL_WAKE_CTS_EN_Msk         (0x1ul << UART_CTL_WAKE_CTS_EN_Pos)               /*!< UART_T::CTL: WAKE_CTS_EN Mask             */
N
N#define UART_CTL_WAKE_DATA_EN_Pos        (9)                                               /*!< UART_T::CTL: WAKE_DATA_EN Position        */
N#define UART_CTL_WAKE_DATA_EN_Msk        (0x1ul << UART_CTL_WAKE_DATA_EN_Pos)              /*!< UART_T::CTL: WAKE_DATA_EN Mask            */
N
N#define UART_CTL_ABAUD_EN_Pos            (12)                                              /*!< UART_T::CTL: ABAUD_EN Position            */
N#define UART_CTL_ABAUD_EN_Msk            (0x1ul << UART_CTL_ABAUD_EN_Pos)                  /*!< UART_T::CTL: ABAUD_EN Mask                */
N
N#define UART_TLCTL_DATA_LEN_Pos          (0)                                               /*!< UART_T::TLCTL: DATA_LEN Position          */
N#define UART_TLCTL_DATA_LEN_Msk          (0x3ul << UART_TLCTL_DATA_LEN_Pos)                /*!< UART_T::TLCTL: DATA_LEN Mask              */
N
N#define UART_TLCTL_NSB_Pos               (2)                                               /*!< UART_T::TLCTL: NSB Position               */
N#define UART_TLCTL_NSB_Msk               (0x1ul << UART_TLCTL_NSB_Pos)                     /*!< UART_T::TLCTL: NSB Mask                   */
N
N#define UART_TLCTL_PBE_Pos               (3)                                               /*!< UART_T::TLCTL: PBE Position               */
N#define UART_TLCTL_PBE_Msk               (0x1ul << UART_TLCTL_PBE_Pos)                     /*!< UART_T::TLCTL: PBE Mask                   */
N
N#define UART_TLCTL_EPE_Pos               (4)                                               /*!< UART_T::TLCTL: EPE Position               */
N#define UART_TLCTL_EPE_Msk               (0x1ul << UART_TLCTL_EPE_Pos)                     /*!< UART_T::TLCTL: EPE Mask                   */
N
N#define UART_TLCTL_SPE_Pos               (5)                                               /*!< UART_T::TLCTL: SPE Position               */
N#define UART_TLCTL_SPE_Msk               (0x1ul << UART_TLCTL_SPE_Pos)                     /*!< UART_T::TLCTL: SPE Mask                   */
N
N#define UART_TLCTL_BCB_Pos               (6)                                               /*!< UART_T::TLCTL: BCB Position               */
N#define UART_TLCTL_BCB_Msk               (0x1ul << UART_TLCTL_BCB_Pos)                     /*!< UART_T::TLCTL: BCB Mask                   */
N
N#define UART_TLCTL_RFITL_Pos             (8)                                               /*!< UART_T::TLCTL: RFITL Position             */
N#define UART_TLCTL_RFITL_Msk             (0x3ul << UART_TLCTL_RFITL_Pos)                   /*!< UART_T::TLCTL: RFITL Mask                 */
N
N#define UART_TLCTL_RTS_TRI_LEV_Pos       (12)                                              /*!< UART_T::TLCTL: RTS_TRI_LEV Position       */
N#define UART_TLCTL_RTS_TRI_LEV_Msk       (0x3ul << UART_TLCTL_RTS_TRI_LEV_Pos)             /*!< UART_T::TLCTL: RTS_TRI_LEV Mask           */
N
N#define UART_IER_RDA_IE_Pos              (0)                                               /*!< UART_T::IER: RDA_IE Position              */
N#define UART_IER_RDA_IE_Msk              (0x1ul << UART_IER_RDA_IE_Pos)                    /*!< UART_T::IER: RDA_IE Mask                  */
N
N#define UART_IER_THRE_IE_Pos             (1)                                               /*!< UART_T::IER: THRE_IE Position             */
N#define UART_IER_THRE_IE_Msk             (0x1ul << UART_IER_THRE_IE_Pos)                   /*!< UART_T::IER: THRE_IE Mask                 */
N
N#define UART_IER_RLS_IE_Pos              (2)                                               /*!< UART_T::IER: RLS_IE Position              */
N#define UART_IER_RLS_IE_Msk              (0x1ul << UART_IER_RLS_IE_Pos)                    /*!< UART_T::IER: RLS_IE Mask                  */
N
N#define UART_IER_MODEM_IE_Pos            (3)                                               /*!< UART_T::IER: MODEM_IE Position            */
N#define UART_IER_MODEM_IE_Msk            (0x1ul << UART_IER_MODEM_IE_Pos)                  /*!< UART_T::IER: MODEM_IE Mask                */
N
N#define UART_IER_RTO_IE_Pos              (4)                                               /*!< UART_T::IER: RTO_IE Position              */
N#define UART_IER_RTO_IE_Msk              (0x1ul << UART_IER_RTO_IE_Pos)                    /*!< UART_T::IER: RTO_IE Mask                  */
N
N#define UART_IER_BUF_ERR_IE_Pos          (5)                                               /*!< UART_T::IER: BUF_ERR_IE Position          */
N#define UART_IER_BUF_ERR_IE_Msk          (0x1ul << UART_IER_BUF_ERR_IE_Pos)                /*!< UART_T::IER: BUF_ERR_IE Mask              */
N
N#define UART_IER_WAKE_IE_Pos             (6)                                               /*!< UART_T::IER: WAKE_IE Position             */
N#define UART_IER_WAKE_IE_Msk             (0x1ul << UART_IER_WAKE_IE_Pos)                   /*!< UART_T::IER: WAKE_IE Mask                 */
N
N#define UART_IER_ABAUD_IE_Pos            (7)                                               /*!< UART_T::IER: ABAUD_IE Position            */
N#define UART_IER_ABAUD_IE_Msk            (0x1ul << UART_IER_ABAUD_IE_Pos)                  /*!< UART_T::IER: ABAUD_IE Mask                */
N
N#define UART_IER_LIN_IE_Pos              (8)                                               /*!< UART_T::IER: LIN_IE Position              */
N#define UART_IER_LIN_IE_Msk              (0x1ul << UART_IER_LIN_IE_Pos)                    /*!< UART_T::IER: LIN_IE Mask                  */
N
N#define UART_ISR_RDA_IS_Pos              (0)                                               /*!< UART_T::ISR: RDA_IS Position              */
N#define UART_ISR_RDA_IS_Msk              (0x1ul << UART_ISR_RDA_IS_Pos)                    /*!< UART_T::ISR: RDA_IS Mask                  */
N
N#define UART_ISR_THRE_IS_Pos             (1)                                               /*!< UART_T::ISR: THRE_IS Position             */
N#define UART_ISR_THRE_IS_Msk             (0x1ul << UART_ISR_THRE_IS_Pos)                   /*!< UART_T::ISR: THRE_IS Mask                 */
N
N#define UART_ISR_RLS_IS_Pos              (2)                                               /*!< UART_T::ISR: RLS_IS Position              */
N#define UART_ISR_RLS_IS_Msk              (0x1ul << UART_ISR_RLS_IS_Pos)                    /*!< UART_T::ISR: RLS_IS Mask                  */
N
N#define UART_ISR_MODEM_IS_Pos            (3)                                               /*!< UART_T::ISR: MODEM_IS Position            */
N#define UART_ISR_MODEM_IS_Msk            (0x1ul << UART_ISR_MODEM_IS_Pos)                  /*!< UART_T::ISR: MODEM_IS Mask                */
N
N#define UART_ISR_RTO_IS_Pos              (4)                                               /*!< UART_T::ISR: RTO_IS Position              */
N#define UART_ISR_RTO_IS_Msk              (0x1ul << UART_ISR_RTO_IS_Pos)                    /*!< UART_T::ISR: RTO_IS Mask                  */
N
N#define UART_ISR_BUF_ERR_IS_Pos          (5)                                               /*!< UART_T::ISR: BUF_ERR_IS Position          */
N#define UART_ISR_BUF_ERR_IS_Msk          (0x1ul << UART_ISR_BUF_ERR_IS_Pos)                /*!< UART_T::ISR: BUF_ERR_IS Mask              */
N
N#define UART_ISR_WAKE_IS_Pos             (6)                                               /*!< UART_T::ISR: WAKE_IS Position             */
N#define UART_ISR_WAKE_IS_Msk             (0x1ul << UART_ISR_WAKE_IS_Pos)                   /*!< UART_T::ISR: WAKE_IS Mask                 */
N
N#define UART_ISR_ABAUD_IS_Pos            (7)                                               /*!< UART_T::ISR: ABAUD_IS Position            */
N#define UART_ISR_ABAUD_IS_Msk            (0x1ul << UART_ISR_ABAUD_IS_Pos)                  /*!< UART_T::ISR: ABAUD_IS Mask                */
N
N#define UART_ISR_LIN_IS_Pos              (8)                                               /*!< UART_T::ISR: LIN_IS Position              */
N#define UART_ISR_LIN_IS_Msk              (0x1ul << UART_ISR_LIN_IS_Pos)                    /*!< UART_T::ISR: LIN_IS Mask                  */
N
N#define UART_TRSR_RS485_ADDET_F_Pos     (0)                                               /*!< UART_T::TRSR: RS485_ADDET_F Position     */
N#define UART_TRSR_RS485_ADDET_F_Msk     (0x1ul << UART_TRSR_RS485_ADDET_F_Pos)           /*!< UART_T::TRSR: RS485_ADDET_F Mask         */
N
N#define UART_TRSR_ABAUD_F_Pos            (1)                                               /*!< UART_T::TRSR: ABAUD_F Position            */
N#define UART_TRSR_ABAUD_F_Msk            (0x1ul << UART_TRSR_ABAUD_F_Pos)                  /*!< UART_T::TRSR: ABAUD_F Mask                */
N
N#define UART_TRSR_ABAUD_TOUT_F_Pos       (2)                                               /*!< UART_T::TRSR: ABAUD_TOUT_F Position       */
N#define UART_TRSR_ABAUD_TOUT_F_Msk       (0x1ul << UART_TRSR_ABAUD_TOUT_F_Pos)             /*!< UART_T::TRSR: ABAUD_TOUT_F Mask           */
N
N#define UART_TRSR_LIN_TX_F_Pos           (3)                                               /*!< UART_T::TRSR: LIN_TX_F Position           */
N#define UART_TRSR_LIN_TX_F_Msk           (0x1ul << UART_TRSR_LIN_TX_F_Pos)                 /*!< UART_T::TRSR: LIN_TX_F Mask               */
N
N#define UART_TRSR_LIN_RX_F_Pos           (4)                                               /*!< UART_T::TRSR: LIN_RX_F Position           */
N#define UART_TRSR_LIN_RX_F_Msk           (0x1ul << UART_TRSR_LIN_RX_F_Pos)                 /*!< UART_T::TRSR: LIN_RX_F Mask               */
N
N#define UART_TRSR_BIT_ERR_F_Pos          (5)                                               /*!< UART_T::TRSR: BIT_ERR_F Position          */
N#define UART_TRSR_BIT_ERR_F_Msk          (0x1ul << UART_TRSR_BIT_ERR_F_Pos)                /*!< UART_T::TRSR: BIT_ERR_F Mask              */
N
N#define UART_TRSR_LIN_RX_SYNC_ERR_F_Pos  (8)                                               /*!< UART_T::TRSR: LIN_RX_SYNC_ERR_F Position  */
N#define UART_TRSR_LIN_RX_SYNC_ERR_F_Msk  (0x1ul << UART_TRSR_LIN_RX_SYNC_ERR_F_Pos)        /*!< UART_T::TRSR: LIN_RX_SYNC_ERR_F Mask      */
N
N#define UART_FSR_RX_OVER_F_Pos           (0)                                               /*!< UART_T::FSR: RX_OVER_F Position           */
N#define UART_FSR_RX_OVER_F_Msk           (0x1ul << UART_FSR_RX_OVER_F_Pos)                 /*!< UART_T::FSR: RX_OVER_F Mask               */
N
N#define UART_FSR_RX_EMPTY_F_Pos          (1)                                               /*!< UART_T::FSR: RX_EMPTY_F Position          */
N#define UART_FSR_RX_EMPTY_F_Msk          (0x1ul << UART_FSR_RX_EMPTY_F_Pos)                /*!< UART_T::FSR: RX_EMPTY_F Mask              */
N
N#define UART_FSR_RX_FULL_F_Pos           (2)                                               /*!< UART_T::FSR: RX_FULL_F Position           */
N#define UART_FSR_RX_FULL_F_Msk           (0x1ul << UART_FSR_RX_FULL_F_Pos)                 /*!< UART_T::FSR: RX_FULL_F Mask               */
N
N#define UART_FSR_PE_F_Pos                (4)                                               /*!< UART_T::FSR: PE_F Position                */
N#define UART_FSR_PE_F_Msk                (0x1ul << UART_FSR_PE_F_Pos)                      /*!< UART_T::FSR: PE_F Mask                    */
N
N#define UART_FSR_FE_F_Pos                (5)                                               /*!< UART_T::FSR: FE_F Position                */
N#define UART_FSR_FE_F_Msk                (0x1ul << UART_FSR_FE_F_Pos)                      /*!< UART_T::FSR: FE_F Mask                    */
N
N#define UART_FSR_BI_F_Pos                (6)                                               /*!< UART_T::FSR: BI_F Position                */
N#define UART_FSR_BI_F_Msk                (0x1ul << UART_FSR_BI_F_Pos)                      /*!< UART_T::FSR: BI_F Mask                    */
N
N#define UART_FSR_TX_OVER_F_Pos           (8)                                               /*!< UART_T::FSR: TX_OVER_F Position           */
N#define UART_FSR_TX_OVER_F_Msk           (0x1ul << UART_FSR_TX_OVER_F_Pos)                 /*!< UART_T::FSR: TX_OVER_F Mask               */
N
N#define UART_FSR_TX_EMPTY_F_Pos          (9)                                               /*!< UART_T::FSR: TX_EMPTY_F Position          */
N#define UART_FSR_TX_EMPTY_F_Msk          (0x1ul << UART_FSR_TX_EMPTY_F_Pos)                /*!< UART_T::FSR: TX_EMPTY_F Mask              */
N
N#define UART_FSR_TX_FULL_F_Pos           (10)                                              /*!< UART_T::FSR: TX_FULL_F Position           */
N#define UART_FSR_TX_FULL_F_Msk           (0x1ul << UART_FSR_TX_FULL_F_Pos)                 /*!< UART_T::FSR: TX_FULL_F Mask               */
N
N#define UART_FSR_TE_F_Pos                (11)                                              /*!< UART_T::FSR: TE_F Position                */
N#define UART_FSR_TE_F_Msk                (0x1ul << UART_FSR_TE_F_Pos)                      /*!< UART_T::FSR: TE_F Mask                    */
N
N#define UART_FSR_RX_POINTER_F_Pos        (16)                                              /*!< UART_T::FSR: RX_POINTER_F Position        */
N#define UART_FSR_RX_POINTER_F_Msk        (0x1ful << UART_FSR_RX_POINTER_F_Pos)             /*!< UART_T::FSR: RX_POINTER_F Mask            */
N
N#define UART_FSR_TX_POINTER_F_Pos        (24)                                              /*!< UART_T::FSR: TX_POINTER_F Position        */
N#define UART_FSR_TX_POINTER_F_Msk        (0x1ful << UART_FSR_TX_POINTER_F_Pos)             /*!< UART_T::FSR: TX_POINTER_F Mask            */
N
N#define UART_MCSR_LEV_RTS_Pos            (0)                                               /*!< UART_T::MCSR: LEV_RTS Position            */
N#define UART_MCSR_LEV_RTS_Msk            (0x1ul << UART_MCSR_LEV_RTS_Pos)                  /*!< UART_T::MCSR: LEV_RTS Mask                */
N
N#define UART_MCSR_RTS_ST_Pos             (1)                                               /*!< UART_T::MCSR: RTS_ST Position             */
N#define UART_MCSR_RTS_ST_Msk             (0x1ul << UART_MCSR_RTS_ST_Pos)                   /*!< UART_T::MCSR: RTS_ST Mask                 */
N
N#define UART_MCSR_LEV_CTS_Pos            (16)                                              /*!< UART_T::MCSR: LEV_CTS Position            */
N#define UART_MCSR_LEV_CTS_Msk            (0x1ul << UART_MCSR_LEV_CTS_Pos)                  /*!< UART_T::MCSR: LEV_CTS Mask                */
N
N#define UART_MCSR_CTS_ST_Pos             (17)                                              /*!< UART_T::MCSR: CTS_ST Position             */
N#define UART_MCSR_CTS_ST_Msk             (0x1ul << UART_MCSR_CTS_ST_Pos)                   /*!< UART_T::MCSR: CTS_ST Mask                 */
N
N#define UART_MCSR_DCT_F_Pos              (18)                                              /*!< UART_T::MCSR: DCT_F Position              */
N#define UART_MCSR_DCT_F_Msk              (0x1ul << UART_MCSR_DCT_F_Pos)                    /*!< UART_T::MCSR: DCT_F Mask                  */
N
N#define UART_TMCTL_TOIC_Pos              (0)                                               /*!< UART_T::TMCTL: TOIC Position              */
N#define UART_TMCTL_TOIC_Msk              (0x1fful << UART_TMCTL_TOIC_Pos)                  /*!< UART_T::TMCTL: TOIC Mask                  */
N
N#define UART_TMCTL_DLY_Pos               (16)                                              /*!< UART_T::TMCTL: DLY Position               */
N#define UART_TMCTL_DLY_Msk               (0xfful << UART_TMCTL_DLY_Pos)                    /*!< UART_T::TMCTL: DLY Mask                   */
N
N#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART_T::BAUD: BRD Position                */
N#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART_T::BAUD: BRD Mask                    */
N
N#define UART_BAUD_DIV_16_EN_Pos          (31)                                              /*!< UART_T::BAUD: DIV_16_EN Position          */
N#define UART_BAUD_DIV_16_EN_Msk          (0x1ul << UART_BAUD_DIV_16_EN_Pos)                /*!< UART_T::BAUD: DIV_16_EN Mask              */
N
N#define UART_IRCR_TX_SELECT_Pos          (1)                                               /*!< UART_T::IRCR: TX_SELECT Position          */
N#define UART_IRCR_TX_SELECT_Msk          (0x1ul << UART_IRCR_TX_SELECT_Pos)                /*!< UART_T::IRCR: TX_SELECT Mask              */
N
N#define UART_IRCR_INV_TX_Pos             (5)                                               /*!< UART_T::IRCR: INV_TX Position             */
N#define UART_IRCR_INV_TX_Msk             (0x1ul << UART_IRCR_INV_TX_Pos)                   /*!< UART_T::IRCR: INV_TX Mask                 */
N
N#define UART_IRCR_INV_RX_Pos             (6)                                               /*!< UART_T::IRCR: INV_RX Position             */
N#define UART_IRCR_INV_RX_Msk             (0x1ul << UART_IRCR_INV_RX_Pos)                   /*!< UART_T::IRCR: INV_RX Mask                 */
N
N#define UART_ALT_CTL_LIN_TX_BCNT_Pos     (0)                                               /*!< UART_T::ALT_CTL: LIN_TX_BCNT Position     */
N#define UART_ALT_CTL_LIN_TX_BCNT_Msk     (0x7ul << UART_ALT_CTL_LIN_TX_BCNT_Pos)           /*!< UART_T::ALT_CTL: LIN_TX_BCNT Mask         */
N
N#define UART_ALT_CTL_LIN_HEAD_SEL_Pos    (4)                                               /*!< UART_T::ALT_CTL: LIN_HEAD_SEL Position    */
N#define UART_ALT_CTL_LIN_HEAD_SEL_Msk    (0x3ul << UART_ALT_CTL_LIN_HEAD_SEL_Pos)          /*!< UART_T::ALT_CTL: LIN_HEAD_SEL Mask        */
N
N#define UART_ALT_CTL_LIN_RX_EN_Pos       (6)                                               /*!< UART_T::ALT_CTL: LIN_RX_EN Position       */
N#define UART_ALT_CTL_LIN_RX_EN_Msk       (0x1ul << UART_ALT_CTL_LIN_RX_EN_Pos)             /*!< UART_T::ALT_CTL: LIN_RX_EN Mask           */
N
N#define UART_ALT_CTL_LIN_TX_EN_Pos       (7)                                               /*!< UART_T::ALT_CTL: LIN_TX_EN Position       */
N#define UART_ALT_CTL_LIN_TX_EN_Msk       (0x1ul << UART_ALT_CTL_LIN_TX_EN_Pos)             /*!< UART_T::ALT_CTL: LIN_TX_EN Mask           */
N
N#define UART_ALT_CTL_Bit_ERR_EN_Pos      (8)                                               /*!< UART_T::ALT_CTL: Bit_ERR_EN Position      */
N#define UART_ALT_CTL_Bit_ERR_EN_Msk      (0x1ul << UART_ALT_CTL_Bit_ERR_EN_Pos)            /*!< UART_T::ALT_CTL: Bit_ERR_EN Mask          */
N
N#define UART_ALT_CTL_RS485_NMM_Pos      (16)                                              /*!< UART_T::ALT_CTL: RS485_NMM Position      */
N#define UART_ALT_CTL_RS485_NMM_Msk      (0x1ul << UART_ALT_CTL_RS485_NMM_Pos)             /*!< UART_T::ALT_CTL: RS485_NMM Mask          */
N
N#define UART_ALT_CTL_RS485_AAD_Pos      (17)                                              /*!< UART_T::ALT_CTL: RS485_AAD Position      */
N#define UART_ALT_CTL_RS485_AAD_Msk      (0x1ul << UART_ALT_CTL_RS485_AAD_Pos)             /*!< UART_T::ALT_CTL: RS485_AAD Mask          */
N
N#define UART_ALT_CTL_RS485_AUD_Pos      (18)                                              /*!< UART_T::ALT_CTL: RS485_AUD Position      */
N#define UART_ALT_CTL_RS485_AUD_Msk      (0x1ul << UART_ALT_CTL_RS485_AUD_Pos)             /*!< UART_T::ALT_CTL: RS485_AUD Mask          */
N
N#define UART_ALT_CTL_RS485_ADD_EN_Pos   (19)                                              /*!< UART_T::ALT_CTL: RS485_ADD_EN Position   */
N#define UART_ALT_CTL_RS485_ADD_EN_Msk   (0x1ul << UART_ALT_CTL_RS485_ADD_EN_Pos)          /*!< UART_T::ALT_CTL: RS485_ADD_EN Mask       */
N
N#define UART_ALT_CTL_ADDR_PID_MATCH_Pos  (24)                                              /*!< UART_T::ALT_CTL: ADDR_PID_MATCH Position  */
N#define UART_ALT_CTL_ADDR_PID_MATCH_Msk  (0xfful << UART_ALT_CTL_ADDR_PID_MATCH_Pos)       /*!< UART_T::ALT_CTL: ADDR_PID_MATCH Mask      */
N
N#define UART_FUN_SEL_FUN_SEL_Pos         (0)                                               /*!< UART_T::FUN_SEL: FUN_SEL Position         */
N#define UART_FUN_SEL_FUN_SEL_Msk         (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)               /*!< UART_T::FUN_SEL: FUN_SEL Mask             */
N
N/**@}*/ /* UART_CONST */
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- USB Device Controller -------------------------*/
N/**
N    @addtogroup USBD USB Device Controller(USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N
N/**
N  * @brief USBD endpoints register
N  */
Ntypedef struct
N{
N
N
N    /**
N     * BUFSEGx
N     * ===================================================================================================
N     * Offset: 0x20+x*0x10  Endpoint x Buffer Segmentation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:3]   |BUFSEG    |It Is Used To Define The Offset Address For Each Endpoint With The USB SRAM Starting Address Its physical address is USB_SRAM address + {BUFSEG[5:0], 000}; where the USB_SRAM = USB_BASE + 0x100h.
N     * |        |          |Refer to the section 5.4.3.3 for the endpoint SRAM structure and its description.
N    */
N    __IO uint32_t BUFSEG;
X    volatile uint32_t BUFSEG;
N
N    /**
N     * MXPLDx
N     * ===================================================================================================
N     * Offset: 0x24+x*0x10  Endpoint x Maximal Payload Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |MXPLD     |Maximal Payload
N     * |        |          |It is used to define the length of data which is transmitted to host (IN token) or the actual length of data receiving from host (OUT token).
N     * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
N     * |        |          |(1). When the register is written by CPU,
N     * |        |          |For IN token, the value of MXPLD is used to define the length of data to be transmitted and indicate the data buffer is ready.
N     * |        |          |For OUT token, it means that the controller is ready to receive data from host and the value of MXPLD is the maximal data length comes from host.
N     * |        |          |(2). When the register is read by CPU,
N     * |        |          |For IN token, the value of MXPLD is indicated the length of data be transmitted to host
N     * |        |          |For OUT token, the value of MXPLD is indicated the actual length of data receiving from host.
N     * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
N    */
N    __IO uint32_t MXPLD;
X    volatile uint32_t MXPLD;
N
N    /**
N     * CFGx
N     * ===================================================================================================
N     * Offset: 0x28+x*0x10  Endpoint x Configuration Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |EP_NUM    |Endpoint Number
N     * |        |          |These bits are used to define the endpoint number of the current endpoint
N     * |[4]     |ISOCH     |Isochronous Endpoint
N     * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
N     * |[6:5]   |EPMODE    |Endpoint Mode
N     * |        |          |00 = Endpoint is disabled.
N     * |        |          |01 = Out endpoint.
N     * |        |          |10 = IN endpoint.
N     * |        |          |11 = Undefined.
N     * |[7]     |DSQ_SYNC  |Data Sequence Synchronization
N     * |        |          |0 = DATA0 PID.
N     * |        |          |1 = DATA1 PID.
N     * |        |          |It is used to specify the DATA0 or DATA1 PID in the current transaction.
N     * |        |          |It will toggle automatically in IN token after host response ACK.
N     * |        |          |In the other tokens, the user shall take care of it to confirm the right PID in its transaction.
N     * |[8]     |CSTALL    |Clear STALL Response
N     * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
N     * |        |          |1 = Clear the device to response STALL handshake in setup stage.
N     * |[9]     |SSTALL    |Set STALL Response
N     * |        |          |0 = Disable the device to response STALL.
N     * |        |          |1 = Set the device to respond STALL automatically.
N     * |[15]    |CLRRDY    |Clear Ready
N     * |        |          |When the USBD_MXPLDx register is set by user, it means that the endpoint is ready to transmit or receive data.
N     * |        |          |If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to disable it and it is auto clear to 0.
N     * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
N     * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
N     * |        |          |This bit is write 1 only and is always 0 when it is read back.
N    */
N    __IO uint32_t CFG;
X    volatile uint32_t CFG;
N    uint32_t RESERVE;
N
N} USBD_EP_T;
N
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  USB Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |USB_EN    |USB Function Enable
N     * |        |          |0 = USB Disabled.
N     * |        |          |1 = USB Enabled.
N     * |[1]     |PHY_EN    |PHY Transceiver Enable
N     * |        |          |0 = PHY transceiver Disabled.
N     * |        |          |1 = PHY transceiver Enabled.
N     * |[2]     |PWRDB     |Power Down PHY Transceiver, Low Active
N     * |        |          |0 = Power-down related circuit of PHY transceiver.
N     * |        |          |1 = Turn-on related circuit of PHY transceiver.
N     * |[3]     |DPPU_EN   |Pull-Up Resistor On USB_DP Enable
N     * |        |          |0 = Pull-up resistor in USB_DP bus Disabled.
N     * |        |          |1 = Pull-up resistor in USB_DP bus will be active.
N     * |[4]     |DRVSE0    |Force USB PHY Transceiver To Drive SE0 (Single Ended Zero)
N     * |        |          |The Single Ended Zero is present when both lines (USB_DP, USB_DM) are being pulled low.
N     * |        |          |0 = None.
N     * |        |          |1 = Force USB PHY transceiver to drive SE0.
N     * |        |          |The default value is "1".
N     * |[8]     |RWAKEUP   |Remote Wake-Up
N     * |        |          |0 = Don't force USB bus to K state.
N     * |        |          |1 = Force USB bus to K (USB_DP low, USB_DM: high) state, used for remote wake-up.
N     * |[9]     |WAKEUP_EN |Wake-Up Function Enable
N     * |        |          |0 = USB wake-up function Disabled.
N     * |        |          |1 = USB wake-up function Enabled.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * BUSSTS
N     * ===================================================================================================
N     * Offset: 0x04  USB Bus Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |USBRST    |USB Reset Status
N     * |        |          |1 = Bus reset when SE0 (single-ended 0) more than 2.5uS. It is read only.
N     * |[1]     |SUSPEND   |Suspend Status
N     * |        |          |1 = Bus idle more than 3 ms, either cable is plugged off or host is sleeping. It is read only.
N     * |[2]     |RESUME    |Resume Status
N     * |        |          |1 = Resume from suspend. It is read only.
N     * |[3]     |TIMEOUT   |Time-Out Flag
N     * |        |          |1 = Bus no any response more than 18 bits time. It is read only.
N     * |[4]     |FLDET     |Device Floating Detection
N     * |        |          |0 = The controller didn't attach into the USB.
N     * |        |          |1 = When the controller is attached into the USB, this bit will be set as "1".
N    */
N    __I  uint32_t BUSSTS;
X    volatile const  uint32_t BUSSTS;
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x08  Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BUSEVT_IE |Bus Event Interrupt Enable
N     * |        |          |0 = BUS event interrupt Disabled.
N     * |        |          |1 = BUS event interrupt Enabled.
N     * |[1]     |USBEVT_IE |USB Event Interrupt Enable
N     * |        |          |0 = USB event interrupt Disabled.
N     * |        |          |1 = USB event interrupt Enabled.
N     * |[2]     |FLDET_IE  |Floating Detect Interrupt Enable
N     * |        |          |0 = Floating detect Interrupt Disabled.
N     * |        |          |1 = Floating detect Interrupt Enabled.
N     * |[3]     |WAKEUP_IE |USB Wake-Up Interrupt Enable
N     * |        |          |0 = Wake-up Interrupt Disabled.
N     * |        |          |1 = Wake-up Interrupt Enabled.
N    */
N    __IO uint32_t INTEN;
X    volatile uint32_t INTEN;
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x0C  Interrupt Event Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BUS_STS   |BUS Interrupt Status
N     * |        |          |The BUS event means there is bus suspense or bus resume in the bus.
N     * |        |          |This bit is used to indicate that there is one of events in the bus.
N     * |        |          |0 = No BUS event is occurred.
N     * |        |          |1 = BUS event occurred; check USB_BUSSTS [3:0] to know which kind of bus event was occurred, cleared by write "1" to USB_INTSTS [0].
N     * |[1]     |USB_STS   |USB Interrupt Status
N     * |        |          |The USB event means that there is Setup Token, IN token, OUT ACK, ISO IN, or ISO OUT event in the bus.
N     * |        |          |This bit is used to indicate that there is one of events in the bus.
N     * |        |          |0 = No USB event is occurred.
N     * |        |          |1 = USB event occurred, check EPSTS0~7[3:0] in USB_EPSTS [31:8] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [1] or USB_INTSTS[31] or EPEVT0~7.
N     * |[2]     |FLD_STS   |Floating Interrupt Status
N     * |        |          |0 = There is not attached event in the USB.
N     * |        |          |1 = There is attached event in the USB and it is cleared by write "1" to USB_INTSTS [2].
N     * |[3]     |WKEUP_STS |Wake-Up Interrupt Status
N     * |        |          |0 = No wake-up event is occurred.
N     * |        |          |1 = Wake-up event occurred, cleared by write 1 to USB_INTSTS [3].
N     * |[16]    |EPEVT0    |USB Event Status On EP0
N     * |        |          |0 = No event occurred in Endpoint 0.
N     * |        |          |1 = USB event occurred on Endpoint 0, check USB_EPSTS[11:8] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [16] or USB_INTSTS [1].
N     * |[17]    |EPEVT1    |USB Event Status On EP1
N     * |        |          |0 = No event occurred in Endpoint 1.
N     * |        |          |1 = USB event occurred on Endpoint 1, check USB_EPSTS[15:12] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [17] or USB_INTSTS [1].
N     * |[18]    |EPEVT2    |USB Event Status On EP2
N     * |        |          |0 = No event occurred in Endpoint 2.
N     * |        |          |1 = USB event occurred on Endpoint 2, check USB_EPSTS[19:16] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [18] or USB_INTSTS [1].
N     * |[19]    |EPEVT3    |USB Event Status On EP3
N     * |        |          |0 = No event occurred in Endpoint 3.
N     * |        |          |1 = USB event occurred on Endpoint 3, check USB_EPSTS[23:20] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [19] or USB_INTSTS [1].
N     * |[20]    |EPEVT4    |USB Event Status On EP4
N     * |        |          |0 = No event occurred in Endpoint 4.
N     * |        |          |1 = USB event occurred on Endpoint 4, check USB_EPSTS[27:24] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [20] or USB_INTSTS [1].
N     * |[21]    |EPEVT5    |USB Event Status On EP5
N     * |        |          |0 = No event occurred in Endpoint 5.
N     * |        |          |1 = USB event occurred on Endpoint 5, check USB_EPSTS[31:28] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [21] or USB_INTSTS [1].
N     * |[22]    |EPEVT6    |USB Event Status On EP6
N     * |        |          |0 = No event occurred in Endpoint 6.
N     * |        |          |1 = USB event occurred on Endpoint 6, check USB_EPSTS2[2:0] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [22] or USB_INTSTS [1].
N     * |[23]    |EPEVT7    |USB Event Status On EP7
N     * |        |          |0 = No event occurred in Endpoint 7.
N     * |        |          |1 = USB event occurred on Endpoint 7, check USB_EPSTS2[6:4] to know which kind of USB event was occurred, cleared by write "1" to USB_INTSTS [23] or USB_INTSTS [1].
N     * |[31]    |SETUP     |Setup Event Status
N     * |        |          |0 = No Setup event.
N     * |        |          |1 = Setup event occurred, cleared by write "1" to USB_INTSTS[31].
N    */
N    __IO uint32_t INTSTS;
X    volatile uint32_t INTSTS;
N
N    /**
N     * FADDR
N     * ===================================================================================================
N     * Offset: 0x10  Device 's Function Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6:0]   |FADDR     |USB device's function address
N    */
N    __IO uint32_t FADDR;
X    volatile uint32_t FADDR;
N
N    /**
N     * EPSTS
N     * ===================================================================================================
N     * Offset: 0x14  Endpoint Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7]     |OVERRUN   |Overrun
N     * |        |          |It means the received data is over the maximum payload number or not.
N     * |        |          |0 = No overrun.
N     * |        |          |1 = Out Data more than the Max Payload in MXPLD register or the Setup Data more than 8 Bytes.
N     * |[11:8]  |EPSTS0    |Endpoint 0 Bus Status
N     * |        |          |These bits are used to show the current status of this endpoint.
N     * |        |          |Definition is the same with EPSTS5(USB_EPSTS[27:24]).
N     * |[15:12] |EPSTS1    |Endpoint 1 Bus Status
N     * |        |          |These bits are used to show the current status of this endpoint.
N     * |        |          |Definition is the same with EPSTS5(USB_EPSTS[27:24]).
N     * |[19:16] |EPSTS2    |Endpoint 2 Bus Status
N     * |        |          |These bits are used to show the current status of this endpoint.
N     * |        |          |Definition is the same with EPSTS5(USB_EPSTS[27:24]).
N     * |[23:20] |EPSTS3    |Endpoint 3 Bus Status
N     * |        |          |These bits are used to show the current status of this endpoint.
N     * |        |          |Definition is the same with EPSTS5(USB_EPSTS[27:24]).
N     * |[27:24] |EPSTS4    |Endpoint 4 Bus Status
N     * |        |          |These bits are used to show the current status of this endpoint.
N     * |        |          |Definition is the same with EPSTS5(USB_EPSTS[27:24]).
N     * |[31:28] |EPSTS5    |Endpoint 5 Bus Status
N     * |        |          |These bits are used to show the current status of this endpoint.
N     * |        |          |0000 = INACK.
N     * |        |          |0001 = IN NAK (INTERNAL ONLY).
N     * |        |          |0010 = OUT Packet Data0 ACK.
N     * |        |          |0011 = Setup ACK
N     * |        |          |0110 = OUT Packet Data1 ACK.
N     * |        |          |0111 = Isochronous transfer end.
N    */
N    __I  uint32_t EPSTS;
X    volatile const  uint32_t EPSTS;
N
N    /**
N     * BUFSEG
N     * ===================================================================================================
N     * Offset: 0x18  Setup Token Buffer Segmentation Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:3]   |BUFSEG    |This Register Is Used For Setup Token Only
N     * |        |          |It is used to define the offset address for the Setup Token with the USB SRAM starting address.
N     * |        |          |Its physical address is USB_SRAM address + {BUFSEG[5:0], 000} where the USB_SRAM = USB_BASE + 0x100h.
N    */
N    __IO uint32_t BUFSEG;
X    volatile uint32_t BUFSEG;
N
N    /**
N     * EPSTS2
N     * ===================================================================================================
N     * Offset: 0x1C  Endpoint Bus Status
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |EPSTS6    |Endpoint 6 Bus Status
N     * |        |          |These bits are used to show the current status of this endpoint.
N     * |        |          |Definition is the same with EPSTS5(USB_EPSTS[27:24]).
N     * |[6:4]   |EPSTS7    |Endpoint 7 Bus Status
N     * |        |          |These bits are used to show the current status of this endpoint.
N     * |        |          |Definition is the same with EPSTS5(USB_EPSTS[27:24]).
N    */
N    __I  uint32_t EPSTS2;
X    volatile const  uint32_t EPSTS2;
N
N
N    USBD_EP_T EP[8];
N
N    uint32_t RESERVE0;
N
N    /**
N     * PDMA
N     * ===================================================================================================
N     * Offset: 0xA4  USB PDMA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PDMA_RW   |PDMA_RW
N     * |        |          |0 = The PDMA will read data from memory to USB buffer.
N     * |        |          |1 = The PDMA will read data from USB buffer to memory.
N     * |[1]     |PDMA_TRG  |Active PDMA Function
N     * |        |          |0 = The PDMA function is not active.
N     * |        |          |1 = The PDMA function in USB is active.
N     * |        |          |This bit will be automatically cleared after PDMA transfer done.
N     * |[2]     |BYTEM     |CPU Access USB SRAM Size Mode Select
N     * |        |          |0 = Word Mode: The size of the transfer from CPU to USB SRAM is Word order.
N     * |        |          |1 = Byte Mode: The size of the transfer from CPU to USB SRAM is Byte order.
N     * |[3]     |PDMA_RST  |PDMA Reset
N     * |        |          |It is used to reset the USB PDMA function into default state.
N     * |        |          |0 = No Reset PDMA Reset Disable.
N     * |        |          |1 = Reset the PDMA function in this controller.
N     * |        |          |Note: it is auto cleared to 0 after the reset function done.
N    */
N    __IO uint32_t PDMA;
X    volatile uint32_t PDMA;
N
N} USBD_T;
N
N/**
N    @addtogroup USBD_CONST USBD Bit Field Definition
N    Constant Definitions for USBD Controller
N@{ */
N
N#define USBD_CTL_USB_EN_Pos              (0)                                               /*!< USBD_T::CTL: USB_EN Position              */
N#define USBD_CTL_USB_EN_Msk              (0x1ul << USBD_CTL_USB_EN_Pos)                    /*!< USBD_T::CTL: USB_EN Mask                  */
N
N#define USBD_CTL_PHY_EN_Pos              (1)                                               /*!< USBD_T::CTL: PHY_EN Position              */
N#define USBD_CTL_PHY_EN_Msk              (0x1ul << USBD_CTL_PHY_EN_Pos)                    /*!< USBD_T::CTL: PHY_EN Mask                  */
N
N#define USBD_CTL_PWRDB_Pos               (2)                                               /*!< USBD_T::CTL: PWRDB Position               */
N#define USBD_CTL_PWRDB_Msk               (0x1ul << USBD_CTL_PWRDB_Pos)                     /*!< USBD_T::CTL: PWRDB Mask                   */
N
N#define USBD_CTL_DPPU_EN_Pos             (3)                                               /*!< USBD_T::CTL: DPPU_EN Position             */
N#define USBD_CTL_DPPU_EN_Msk             (0x1ul << USBD_CTL_DPPU_EN_Pos)                   /*!< USBD_T::CTL: DPPU_EN Mask                 */
N
N#define USBD_CTL_DRVSE0_Pos              (4)                                               /*!< USBD_T::CTL: DRVSE0 Position              */
N#define USBD_CTL_DRVSE0_Msk              (0x1ul << USBD_CTL_DRVSE0_Pos)                    /*!< USBD_T::CTL: DRVSE0 Mask                  */
N
N#define USBD_CTL_RWAKEUP_Pos             (8)                                               /*!< USBD_T::CTL: RWAKEUP Position             */
N#define USBD_CTL_RWAKEUP_Msk             (0x1ul << USBD_CTL_RWAKEUP_Pos)                   /*!< USBD_T::CTL: RWAKEUP Mask                 */
N
N#define USBD_CTL_WAKEUP_EN_Pos           (9)                                               /*!< USBD_T::CTL: WAKEUP_EN Position           */
N#define USBD_CTL_WAKEUP_EN_Msk           (0x1ul << USBD_CTL_WAKEUP_EN_Pos)                 /*!< USBD_T::CTL: WAKEUP_EN Mask               */
N
N#define USBD_BUSSTS_USBRST_Pos           (0)                                               /*!< USBD_T::BUSSTS: USBRST Position           */
N#define USBD_BUSSTS_USBRST_Msk           (0x1ul << USBD_BUSSTS_USBRST_Pos)                 /*!< USBD_T::BUSSTS: USBRST Mask               */
N
N#define USBD_BUSSTS_SUSPEND_Pos          (1)                                               /*!< USBD_T::BUSSTS: SUSPEND Position          */
N#define USBD_BUSSTS_SUSPEND_Msk          (0x1ul << USBD_BUSSTS_SUSPEND_Pos)                /*!< USBD_T::BUSSTS: SUSPEND Mask              */
N
N#define USBD_BUSSTS_RESUME_Pos           (2)                                               /*!< USBD_T::BUSSTS: RESUME Position           */
N#define USBD_BUSSTS_RESUME_Msk           (0x1ul << USBD_BUSSTS_RESUME_Pos)                 /*!< USBD_T::BUSSTS: RESUME Mask               */
N
N#define USBD_BUSSTS_TIMEOUT_Pos          (3)                                               /*!< USBD_T::BUSSTS: TIMEOUT Position          */
N#define USBD_BUSSTS_TIMEOUT_Msk          (0x1ul << USBD_BUSSTS_TIMEOUT_Pos)                /*!< USBD_T::BUSSTS: TIMEOUT Mask              */
N
N#define USBD_BUSSTS_FLDET_Pos            (4)                                               /*!< USBD_T::BUSSTS: FLDET Position            */
N#define USBD_BUSSTS_FLDET_Msk            (0x1ul << USBD_BUSSTS_FLDET_Pos)                  /*!< USBD_T::BUSSTS: FLDET Mask                */
N
N#define USBD_INTEN_BUSEVT_IE_Pos         (0)                                               /*!< USBD_T::INTEN: BUSEVT_IE Position         */
N#define USBD_INTEN_BUSEVT_IE_Msk         (0x1ul << USBD_INTEN_BUSEVT_IE_Pos)               /*!< USBD_T::INTEN: BUSEVT_IE Mask             */
N
N#define USBD_INTEN_USBEVT_IE_Pos         (1)                                               /*!< USBD_T::INTEN: USBEVT_IE Position         */
N#define USBD_INTEN_USBEVT_IE_Msk         (0x1ul << USBD_INTEN_USBEVT_IE_Pos)               /*!< USBD_T::INTEN: USBEVT_IE Mask             */
N
N#define USBD_INTEN_FLDET_IE_Pos          (2)                                               /*!< USBD_T::INTEN: FLDET_IE Position          */
N#define USBD_INTEN_FLDET_IE_Msk          (0x1ul << USBD_INTEN_FLDET_IE_Pos)                /*!< USBD_T::INTEN: FLDET_IE Mask              */
N
N#define USBD_INTEN_WAKEUP_IE_Pos         (3)                                               /*!< USBD_T::INTEN: WAKEUP_IE Position         */
N#define USBD_INTEN_WAKEUP_IE_Msk         (0x1ul << USBD_INTEN_WAKEUP_IE_Pos)               /*!< USBD_T::INTEN: WAKEUP_IE Mask             */
N
N#define USBD_INTSTS_BUS_STS_Pos          (0)                                               /*!< USBD_T::INTSTS: BUS_STS Position          */
N#define USBD_INTSTS_BUS_STS_Msk          (0x1ul << USBD_INTSTS_BUS_STS_Pos)                /*!< USBD_T::INTSTS: BUS_STS Mask              */
N
N#define USBD_INTSTS_USB_STS_Pos          (1)                                               /*!< USBD_T::INTSTS: USB_STS Position          */
N#define USBD_INTSTS_USB_STS_Msk          (0x1ul << USBD_INTSTS_USB_STS_Pos)                /*!< USBD_T::INTSTS: USB_STS Mask              */
N
N#define USBD_INTSTS_FLD_STS_Pos          (2)                                               /*!< USBD_T::INTSTS: FLD_STS Position          */
N#define USBD_INTSTS_FLD_STS_Msk          (0x1ul << USBD_INTSTS_FLD_STS_Pos)                /*!< USBD_T::INTSTS: FLD_STS Mask              */
N
N#define USBD_INTSTS_WKEUP_STS_Pos        (3)                                               /*!< USBD_T::INTSTS: WKEUP_STS Position        */
N#define USBD_INTSTS_WKEUP_STS_Msk        (0x1ul << USBD_INTSTS_WKEUP_STS_Pos)              /*!< USBD_T::INTSTS: WKEUP_STS Mask            */
N
N#define USBD_INTSTS_EPEVT0_Pos           (16)                                              /*!< USBD_T::INTSTS: EPEVT0 Position           */
N#define USBD_INTSTS_EPEVT0_Msk           (0x1ul << USBD_INTSTS_EPEVT0_Pos)                 /*!< USBD_T::INTSTS: EPEVT0 Mask               */
N
N#define USBD_INTSTS_EPEVT1_Pos           (17)                                              /*!< USBD_T::INTSTS: EPEVT1 Position           */
N#define USBD_INTSTS_EPEVT1_Msk           (0x1ul << USBD_INTSTS_EPEVT1_Pos)                 /*!< USBD_T::INTSTS: EPEVT1 Mask               */
N
N#define USBD_INTSTS_EPEVT2_Pos           (18)                                              /*!< USBD_T::INTSTS: EPEVT2 Position           */
N#define USBD_INTSTS_EPEVT2_Msk           (0x1ul << USBD_INTSTS_EPEVT2_Pos)                 /*!< USBD_T::INTSTS: EPEVT2 Mask               */
N
N#define USBD_INTSTS_EPEVT3_Pos           (19)                                              /*!< USBD_T::INTSTS: EPEVT3 Position           */
N#define USBD_INTSTS_EPEVT3_Msk           (0x1ul << USBD_INTSTS_EPEVT3_Pos)                 /*!< USBD_T::INTSTS: EPEVT3 Mask               */
N
N#define USBD_INTSTS_EPEVT4_Pos           (20)                                              /*!< USBD_T::INTSTS: EPEVT4 Position           */
N#define USBD_INTSTS_EPEVT4_Msk           (0x1ul << USBD_INTSTS_EPEVT4_Pos)                 /*!< USBD_T::INTSTS: EPEVT4 Mask               */
N
N#define USBD_INTSTS_EPEVT5_Pos           (21)                                              /*!< USBD_T::INTSTS: EPEVT5 Position           */
N#define USBD_INTSTS_EPEVT5_Msk           (0x1ul << USBD_INTSTS_EPEVT5_Pos)                 /*!< USBD_T::INTSTS: EPEVT5 Mask               */
N
N#define USBD_INTSTS_EPEVT6_Pos           (22)                                              /*!< USBD_T::INTSTS: EPEVT6 Position           */
N#define USBD_INTSTS_EPEVT6_Msk           (0x1ul << USBD_INTSTS_EPEVT6_Pos)                 /*!< USBD_T::INTSTS: EPEVT6 Mask               */
N
N#define USBD_INTSTS_EPEVT7_Pos           (23)                                              /*!< USBD_T::INTSTS: EPEVT7 Position           */
N#define USBD_INTSTS_EPEVT7_Msk           (0x1ul << USBD_INTSTS_EPEVT7_Pos)                 /*!< USBD_T::INTSTS: EPEVT7 Mask               */
N
N#define USBD_INTSTS_SETUP_Pos            (31)                                              /*!< USBD_T::INTSTS: SETUP Position            */
N#define USBD_INTSTS_SETUP_Msk            (0x1ul << USBD_INTSTS_SETUP_Pos)                  /*!< USBD_T::INTSTS: SETUP Mask                */
N
N#define USBD_FADDR_FADDR_Pos             (0)                                               /*!< USBD_T::FADDR: FADDR Position             */
N#define USBD_FADDR_FADDR_Msk             (0x7ful << USBD_FADDR_FADDR_Pos)                  /*!< USBD_T::FADDR: FADDR Mask                 */
N
N#define USBD_EPSTS_OVERRUN_Pos           (7)                                               /*!< USBD_T::EPSTS: OVERRUN Position           */
N#define USBD_EPSTS_OVERRUN_Msk           (0x1ul << USBD_EPSTS_OVERRUN_Pos)                 /*!< USBD_T::EPSTS: OVERRUN Mask               */
N
N#define USBD_EPSTS_EPSTS0_Pos            (8)                                               /*!< USBD_T::EPSTS: EPSTS0 Position            */
N#define USBD_EPSTS_EPSTS0_Msk            (0xful << USBD_EPSTS_EPSTS0_Pos)                  /*!< USBD_T::EPSTS: EPSTS0 Mask                */
N
N#define USBD_EPSTS_EPSTS1_Pos            (12)                                              /*!< USBD_T::EPSTS: EPSTS1 Position            */
N#define USBD_EPSTS_EPSTS1_Msk            (0xful << USBD_EPSTS_EPSTS1_Pos)                  /*!< USBD_T::EPSTS: EPSTS1 Mask                */
N
N#define USBD_EPSTS_EPSTS2_Pos            (16)                                              /*!< USBD_T::EPSTS: EPSTS2 Position            */
N#define USBD_EPSTS_EPSTS2_Msk            (0xful << USBD_EPSTS_EPSTS2_Pos)                  /*!< USBD_T::EPSTS: EPSTS2 Mask                */
N
N#define USBD_EPSTS_EPSTS3_Pos            (20)                                              /*!< USBD_T::EPSTS: EPSTS3 Position            */
N#define USBD_EPSTS_EPSTS3_Msk            (0xful << USBD_EPSTS_EPSTS3_Pos)                  /*!< USBD_T::EPSTS: EPSTS3 Mask                */
N
N#define USBD_EPSTS_EPSTS4_Pos            (24)                                              /*!< USBD_T::EPSTS: EPSTS4 Position            */
N#define USBD_EPSTS_EPSTS4_Msk            (0xful << USBD_EPSTS_EPSTS4_Pos)                  /*!< USBD_T::EPSTS: EPSTS4 Mask                */
N
N#define USBD_EPSTS_EPSTS5_Pos            (28)                                              /*!< USBD_T::EPSTS: EPSTS5 Position            */
N#define USBD_EPSTS_EPSTS5_Msk            (0xful << USBD_EPSTS_EPSTS5_Pos)                  /*!< USBD_T::EPSTS: EPSTS5 Mask                */
N
N#define USBD_BUFSEG_BUFSEG_Pos           (3)                                               /*!< USBD_T::BUFSEG: BUFSEG Position           */
N#define USBD_BUFSEG_BUFSEG_Msk           (0x3ful << USBD_BUFSEG_BUFSEG_Pos)                /*!< USBD_T::BUFSEG: BUFSEG Mask               */
N
N#define USBD_EPSTS2_EPSTS6_Pos           (0)                                               /*!< USBD_T::EPSTS2: EPSTS6 Position           */
N#define USBD_EPSTS2_EPSTS6_Msk           (0x7ul << USBD_EPSTS2_EPSTS6_Pos)                 /*!< USBD_T::EPSTS2: EPSTS6 Mask               */
N
N#define USBD_EPSTS2_EPSTS7_Pos           (4)                                               /*!< USBD_T::EPSTS2: EPSTS7 Position           */
N#define USBD_EPSTS2_EPSTS7_Msk           (0x7ul << USBD_EPSTS2_EPSTS7_Pos)                 /*!< USBD_T::EPSTS2: EPSTS7 Mask               */
N
N#define USBD_BUFSEG_BUFSEG_Pos           (3)                                               /*!< USBD_T::BUFSEG: BUFSEG Position          */
N#define USBD_BUFSEG_BUFSEG_Msk           (0x3ful << USBD_BUFSEG_BUFSEG_Pos)                /*!< USBD_T::BUFSEG: BUFSEG Mask              */
N
N#define USBD_MXPLD_MXPLD_Pos             (0)                                               /*!< USBD_T::MXPLD: MXPLD Position            */
N#define USBD_MXPLD_MXPLD_Msk             (0x1fful << USBD_MXPLD_MXPLD_Pos)                 /*!< USBD_T::MXPLD: MXPLD Mask                */
N
N#define USBD_CFG_EP_NUM_Pos              (0)                                               /*!< USBD_T::CFG: EP_NUM Position             */
N#define USBD_CFG_EP_NUM_Msk              (0xful << USBD_CFG_EP_NUM_Pos)                    /*!< USBD_T::CFG: EP_NUM Mask                 */
N
N#define USBD_CFG_ISOCH_Pos               (4)                                               /*!< USBD_T::CFG: ISOCH Position              */
N#define USBD_CFG_ISOCH_Msk               (0x1ul << USBD_CFG_ISOCH_Pos)                     /*!< USBD_T::CFG: ISOCH Mask                  */
N
N#define USBD_CFG_EPMODE_Pos              (5)                                               /*!< USBD_T::CFG: EPMODE Position             */
N#define USBD_CFG_EPMODE_Msk              (0x3ul << USBD_CFG_EPMODE_Pos)                    /*!< USBD_T::CFG: EPMODE Mask                 */
N
N#define USBD_CFG_DSQ_SYNC_Pos            (7)                                               /*!< USBD_T::CFG: DSQ_SYNC Position           */
N#define USBD_CFG_DSQ_SYNC_Msk            (0x1ul << USBD_CFG_DSQ_SYNC_Pos)                  /*!< USBD_T::CFG: DSQ_SYNC Mask               */
N
N#define USBD_CFG_CSTALL_Pos              (8)                                               /*!< USBD_T::CFG: CSTALL Position             */
N#define USBD_CFG_CSTALL_Msk              (0x1ul << USBD_CFG_CSTALL_Pos)                    /*!< USBD_T::CFG: CSTALL Mask                 */
N
N#define USBD_CFG_SSTALL_Pos              (9)                                               /*!< USBD_T::CFG: SSTALL Position             */
N#define USBD_CFG_SSTALL_Msk              (0x1ul << USBD_CFG_SSTALL_Pos)                    /*!< USBD_T::CFG: SSTALL Mask                 */
N
N#define USBD_CFG_CLRRDY_Pos              (15)                                              /*!< USBD_T::CFG: CLRRDY Position             */
N#define USBD_CFG_CLRRDY_Msk              (0x1ul << USBD_CFG_CLRRDY_Pos)                    /*!< USBD_T::CFG: CLRRDY Mask                 */
N
N#define USBD_PDMA_PDMA_RW_Pos            (0)                                               /*!< USBD_T::PDMA: PDMA_RW Position            */
N#define USBD_PDMA_PDMA_RW_Msk            (0x1ul << USBD_PDMA_PDMA_RW_Pos)                  /*!< USBD_T::PDMA: PDMA_RW Mask                */
N
N#define USBD_PDMA_PDMA_TRG_Pos           (1)                                               /*!< USBD_T::PDMA: PDMA_TRG Position           */
N#define USBD_PDMA_PDMA_TRG_Msk           (0x1ul << USBD_PDMA_PDMA_TRG_Pos)                 /*!< USBD_T::PDMA: PDMA_TRG Mask               */
N
N#define USBD_PDMA_BYTEM_Pos              (2)                                               /*!< USBD_T::PDMA: BYTEM Position              */
N#define USBD_PDMA_BYTEM_Msk              (0x1ul << USBD_PDMA_BYTEM_Pos)                    /*!< USBD_T::PDMA: BYTEM Mask                  */
N
N#define USBD_PDMA_PDMA_RST_Pos           (3)                                               /*!< USBD_T::PDMA: PDMA_RST Position           */
N#define USBD_PDMA_PDMA_RST_Msk           (0x1ul << USBD_PDMA_PDMA_RST_Pos)                 /*!< USBD_T::PDMA: PDMA_RST Mask               */
N
N/**@}*/ /* USBD_CONST */
N/**@}*/ /* end of USBD register group */
N
N
N/*---------------------- Watch Dog Timer Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WTR       |Clear Watchdog Timer
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Set this bit will clear the Watchdog timer.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the contents of the Watchdog timer.
N     * |        |          |Note: This bit will be auto cleared after few clock cycles.
N     * |[1]     |WTRE      |Watchdog Timer Reset Function Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |Setting this bit will enable the Watchdog timer reset function.
N     * |        |          |0 = Watchdog timer reset function Disabled.
N     * |        |          |1 = Watchdog timer reset function Enabled.
N     * |[2]     |WTWKE     |Watchdog Timer Wake-Up Function Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Watchdog timer Wake-up CPU function Disabled.
N     * |        |          |1 = Wake-up function Enabled so that Watchdog timer time-out can wake up CPU from power-down mode.
N     * |[3]     |WTE       |Watchdog Timer Enable
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |0 = Watchdog timer Disabled (this action will reset the internal counter).
N     * |        |          |1 = Watchdog timer Enabled.
N     * |[6:4]   |WTIS      |Watchdog Timer Interval Selection
N     * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N     * |        |          |These three bits select the time-out interval for the Watchdog timer.
N     * |        |          |This count is free running counter.
N     * |        |          |Please refer to the Table 5-16.
N     * |[9:8]   |WTRDSEL   |Watchdog Timer Reset Delay Select
N     * |        |          |When watchdog timeout happened, software has a time named watchdog reset delay period to clear watchdog timer to prevent watchdog reset happened.
N     * |        |          |Software can select a suitable value of watchdog reset delay period for different watchdog timeout period.
N     * |        |          |00 = Watchdog reset delay period is 1026 watchdog clock
N     * |        |          |01 = Watchdog reset delay period is 130 watchdog clock
N     * |        |          |10 = Watchdog reset delay period is 18 watchdog clock
N     * |        |          |11 = Watchdog reset delay period is 3 watchdog clock
N     * |        |          |This register will be reset if watchdog reset happened
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x04  Watchdog Timer Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WDT_IE    |Watchdog Timer Interrupt Enable
N     * |        |          |0 = Watchdog timer interrupt Disabled.
N     * |        |          |1 = Watchdog timer interrupt Enabled.
N    */
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N
N    /**
N     * ISR
N     * ===================================================================================================
N     * Offset: 0x08  Watchdog Timer Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |IS        |Watchdog Timer Interrupt Status
N     * |        |          |If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred.
N     * |        |          |If the Watchdog timer interrupt is not enabled, then this bit indicates that a time-out period has elapsed.
N     * |        |          |0 = Watchdog timer interrupt did not occur.
N     * |        |          |1 = Watchdog timer interrupt occurs.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[1]     |RST_IS    |Watchdog Timer Reset Status
N     * |        |          |When the Watchdog timer initiates a reset, the hardware will set this bit.
N     * |        |          |This flag can be read by software to determine the source of reset.
N     * |        |          |Software is responsible to clear it manually by writing "1" to it.
N     * |        |          |If WTRE is disabled, then the Watchdog timer has no effect on this bit.
N     * |        |          |0 = Watchdog timer reset did not occur.
N     * |        |          |1 = Watchdog timer reset occurs.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[2]     |WAKE_IS   |Watchdog Timer Wake-Up Status
N     * |        |          |If Watchdog timer causes system to wake up from power-down mode, this bit will be set to high.
N     * |        |          |It must be cleared by software with a write "1" to this bit.
N     * |        |          |0 = Watchdog timer does not cause system wake-up.
N     * |        |          |1 = Wake system up from power-down mode by Watchdog time-out.
N     * |        |          |Note1: When system in power-down mode and watchdog time-out, hardware will set WDT_WAKE_IS and WDT_IS.
N     * |        |          |Note2: After one engine clock, this bit can be cleared by writing "1" to it
N    */
N    __IO uint32_t ISR;
X    volatile uint32_t ISR;
N
N} WDT_T;
N
N/**
N    @addtogroup WDT_CONST WDT Bit Field Definition
N    Constant Definitions for WDT Controller
N@{ */
N
N#define WDT_CTL_WTR_Pos                  (0)                                               /*!< WDT_T::CTL: WTR Position                  */
N#define WDT_CTL_WTR_Msk                  (0x1ul << WDT_CTL_WTR_Pos)                        /*!< WDT_T::CTL: WTR Mask                      */
N
N#define WDT_CTL_WTRE_Pos                 (1)                                               /*!< WDT_T::CTL: WTRE Position                 */
N#define WDT_CTL_WTRE_Msk                 (0x1ul << WDT_CTL_WTRE_Pos)                       /*!< WDT_T::CTL: WTRE Mask                     */
N
N#define WDT_CTL_WTWKE_Pos                (2)                                               /*!< WDT_T::CTL: WTWKE Position                */
N#define WDT_CTL_WTWKE_Msk                (0x1ul << WDT_CTL_WTWKE_Pos)                      /*!< WDT_T::CTL: WTWKE Mask                    */
N
N#define WDT_CTL_WTE_Pos                  (3)                                               /*!< WDT_T::CTL: WTE Position                  */
N#define WDT_CTL_WTE_Msk                  (0x1ul << WDT_CTL_WTE_Pos)                        /*!< WDT_T::CTL: WTE Mask                      */
N
N#define WDT_CTL_WTIS_Pos                 (4)                                               /*!< WDT_T::CTL: WTIS Position                 */
N#define WDT_CTL_WTIS_Msk                 (0x7ul << WDT_CTL_WTIS_Pos)                       /*!< WDT_T::CTL: WTIS Mask                     */
N
N#define WDT_CTL_WTRDSEL_Pos              (8)                                               /*!< WDT_T::CTL: WTRDSEL Position              */
N#define WDT_CTL_WTRDSEL_Msk              (0x3ul << WDT_CTL_WTRDSEL_Pos)                    /*!< WDT_T::CTL: WTRDSEL Mask                  */
N
N#define WDT_IER_IE_Pos                   (0)                                               /*!< WDT_T::IER: IE Position                   */
N#define WDT_IER_IE_Msk                   (0x1ul << WDT_IER_IE_Pos)                         /*!< WDT_T::IER: IE Mask                       */
N
N#define WDT_ISR_IS_Pos                   (0)                                               /*!< WDT_T::ISR: IS Position                   */
N#define WDT_ISR_IS_Msk                   (0x1ul << WDT_ISR_IS_Pos)                         /*!< WDT_T::ISR: IS Mask                       */
N
N#define WDT_ISR_RST_IS_Pos               (1)                                               /*!< WDT_T::ISR: RST_IS Position               */
N#define WDT_ISR_RST_IS_Msk               (0x1ul << WDT_ISR_RST_IS_Pos)                     /*!< WDT_T::ISR: RST_IS Mask                   */
N
N#define WDT_ISR_WAKE_IS_Pos              (2)                                               /*!< WDT_T::ISR: WAKE_IS Position              */
N#define WDT_ISR_WAKE_IS_Msk              (0x1ul << WDT_ISR_WAKE_IS_Pos)                    /*!< WDT_T::ISR: WAKE_IS Mask                  */
N
N/**@}*/ /* WDT_CONST */
N/**@}*/ /* end of WDT register group */
N
N
N/*---------------------- Window Watchdog Timer -------------------------*/
N/**
N    @addtogroup WWDT Window Watchdog Timer(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * RLD
N     * ===================================================================================================
N     * Offset: 0x00  Window Watchdog Timer Reload Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RLD       |Window Watchdog Timer Reload Counter Register
N     * |        |          |Writing 0x00005AA5 to this register will reload the Window Watchdog Timer counter value to 0x3F.
N     * |        |          |Note: SW only can write WWDTRLD when WWDT counter value between 0 and WINCMP.
N     * |        |          |If SW writes WWDTRLD when WWDT counter value larger than WINCMP, WWDT will generate RESET signal.
N    */
N    __O  uint32_t RLD;
X    volatile  uint32_t RLD;
N
N    /**
N     * CR
N     * ===================================================================================================
N     * Offset: 0x04  Window Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WWDTEN    |Window Watchdog Enable
N     * |        |          |Set this bit to enable Window Watchdog timer.
N     * |        |          |0 = Window Watchdog timer function Disabled.
N     * |        |          |1 = Window Watchdog timer function Enabled.
N     * |[11:8]  |PERIODSEL |WWDT Pre-Scale Period Select
N     * |        |          |These three bits select the pre-scale for the WWDT counter period.
N     * |        |          |Please refer to Table 5-17
N     * |[21:16] |WINCMP    |WWDT Window Compare Register
N     * |        |          |Set this register to adjust the valid reload window.
N     * |        |          |Note: SW only can write WWDTRLD when WWDT counter value between 0 and WINCMP.
N     * |        |          |If SW writes WWDTRLD when WWDT counter value larger than WWCMP, WWDT will generate RESET signal.
N     * |[31]    |DBGEN     |WWDT Debug Enable
N     * |        |          |0 = WWDT stopped count if system is in Debug mode.
N     * |        |          |1 = WWDT still counted even system is in Debug mode.
N    */
N    __IO uint32_t CR;
X    volatile uint32_t CR;
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x08  Window Watchdog Timer Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WWDTIE    |WWDT Interrupt Enable
N     * |        |          |Setting this bit will enable the Watchdog timer interrupt function.
N     * |        |          |0 = Watchdog timer interrupt function Disabled.
N     * |        |          |1 = Watchdog timer interrupt function Enabled.
N    */
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N
N    /**
N     * STS
N     * ===================================================================================================
N     * Offset: 0x0C  Window Watchdog Timer Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |IF        |WWDT Compare Match Interrupt Flag
N     * |        |          |When WWCMP match the WWDT counter, then this bit is set to 1.
N     * |        |          |This bit will be cleared by software write 1 to this bit.
N     * |[1]     |RF        |WWDT Reset Flag
N     * |        |          |When WWDT counter down count to 0 or write WWDTRLD during WWDT counter larger than WINCMP, chip will be reset and this bit is set to 1.
N     * |        |          |Software can write 1 to clear this bit to 0.
N    */
N    __IO uint32_t STS;
X    volatile uint32_t STS;
N
N    /**
N     * WWDTVAL
N     * ===================================================================================================
N     * Offset: 0x10  Window Watchdog Timer Counter Value Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |VAL       |WWDT Counter Value
N     * |        |          |This register reflects the counter value of window watchdog. This register is read only
N    */
N    __I  uint32_t VAL;
X    volatile const  uint32_t VAL;
N
N} WWDT_T;
N
N/**
N    @addtogroup WWDT_CONST WWDT Bit Field Definition
N    Constant Definitions for WWDT Controller
N@{ */
N
N#define WWDT_RLD_WWDTRLD_Pos             (0)                                               /*!< WWDT_T::RLD: RLD Position             */
N#define WWDT_RLD_WWDTRLD_Msk             (0xfffffffful << WWDT_RLD_RLD_Pos)                /*!< WWDT_T::RLD: RLD Mask                 */
N
N#define WWDT_CR_WWDTEN_Pos               (0)                                               /*!< WWDT_T::CR: WWDTEN Position           */
N#define WWDT_CR_WWDTEN_Msk               (0x1ul << WWDT_CR_WWDTEN_Pos)                     /*!< WWDT_T::CR: WWDTEN Mask               */
N
N#define WWDT_CR_PERIODSEL_Pos            (8)                                               /*!< WWDT_T::CR: PERIODSEL Position        */
N#define WWDT_CR_PERIODSEL_Msk            (0xful << WWDT_CR_PERIODSEL_Pos)                  /*!< WWDT_T::CR: PERIODSEL Mask            */
N
N#define WWDT_CR_WINCMP_Pos               (16)                                              /*!< WWDT_T::CR: WINCMP Position           */
N#define WWDT_CR_WINCMP_Msk               (0x3ful << WWDT_CR_WINCMP_Pos)                    /*!< WWDT_T::CR: WINCMP Mask               */
N
N#define WWDT_CR_DBGEN_Pos                (31)                                              /*!< WWDT_T::CR: DBGEN Position            */
N#define WWDT_CR_DBGEN_Msk                (0x1ul << WWDT_CR_DBGEN_Pos)                      /*!< WWDT_T::CR: DBGEN Mask                */
N
N#define WWDT_IER_WWDTIE_Pos              (0)                                               /*!< WWDT_T::IER: WWDTIE Position          */
N#define WWDT_IER_WWDTIE_Msk              (0x1ul << WWDT_IER_WWDTIE_Pos)                    /*!< WWDT_T::IER: WWDTIE Mask              */
N
N#define WWDT_STS_IF_Pos                  (0)                                               /*!< WWDT_T::STS: IF Position              */
N#define WWDT_STS_IF_Msk                  (0x1ul << WWDT_STS_IF_Pos)                        /*!< WWDT_T::STS: IF Mask                  */
N
N#define WWDT_STS_RF_Pos                  (1)                                               /*!< WWDT_T::STS: RF Position              */
N#define WWDT_STS_RF_Msk                  (0x1ul << WWDT_STS_RF_Pos)                        /*!< WWDT_T::STS: RF Mask                  */
N
N#define WWDT_VAL_WWDTVAL_Pos             (0)                                               /*!< WWDT_T::VAL: WWDTVAL Position         */
N#define WWDT_VAL_WWDTVAL_Msk             (0x3ful << WWDT_VAL_WWDTVAL_Pos)                  /*!< WWDT_T::VAL: WWDTVAL Mask             */
N
N/**@}*/ /* WWDT_CONST */
N/**@}*/ /* end of WWDT register group */
N
N
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N/** @addtogroup NANO100_PERIPHERAL_MEM_MAP NANO100 Peripheral Memory Map
N  Memory Mapped Structure for NANO100 Series Peripheral
N  @{
N */
N/*!<Peripheral and SRAM base address */
N#define FLASH_BASE            ((uint32_t)0x00000000)    ///< Flash base address
N#define SRAM_BASE             ((uint32_t)0x20000000)    ///< SRAM base address
N#define APB1PERIPH_BASE       ((uint32_t)0x40000000)    ///< APB1 base address
N#define APB2PERIPH_BASE       ((uint32_t)0x40100000)    ///< APB2 base address
N#define AHBPERIPH_BASE        ((uint32_t)0x50000000)    ///< AHB base address
N
N/*!<Peripheral memory map */
N
N#define WDT_BASE              (APB1PERIPH_BASE + 0x04000)    ///< WDT register base address
N#define WWDT_BASE             (APB1PERIPH_BASE + 0x04100)    ///< WWDT register base address
N#define RTC_BASE              (APB1PERIPH_BASE + 0x08000)    ///< RTC register base address
N#define TIMER0_BASE           (APB1PERIPH_BASE + 0x10000)    ///< TIMER0 register base address
N#define TIMER1_BASE           (APB1PERIPH_BASE + 0x10100)    ///< TIMER1 register base address
N#define I2C0_BASE             (APB1PERIPH_BASE + 0x20000)    ///< I2C0 register base address
N#define SPI0_BASE             (APB1PERIPH_BASE + 0x30000)    ///< SPI0 register base address
N#define PWM0_BASE             (APB1PERIPH_BASE + 0x40000)    ///< PWM0 register base address
N#define UART0_BASE            (APB1PERIPH_BASE + 0x50000)    ///< UART0 register base address
N#define DAC_BASE              (APB1PERIPH_BASE + 0xA0000)    ///< DAC register base address
N#define LCD_BASE              (APB1PERIPH_BASE + 0xB0000)    ///< LCD register base address
N#define SPI2_BASE             (APB1PERIPH_BASE + 0xD0000)    ///< SPI2 register base address
N#define ADC_BASE              (APB1PERIPH_BASE + 0xE0000)    ///< ADC register base address
N
N#define TIMER2_BASE           (APB2PERIPH_BASE + 0x10000)    ///< TIMER2 register base address
N#define TIMER3_BASE           (APB2PERIPH_BASE + 0x10100)    ///< TIMER3 register base address
N#define SHADOW_BASE           (APB1PERIPH_BASE + 0x10200)    ///< GPIO shadow register base address
N#define I2C1_BASE             (APB2PERIPH_BASE + 0x20000)    ///< I2C1 register base address
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x30000)    ///< SPI1 register base address
N#define PWM1_BASE             (APB2PERIPH_BASE + 0x40000)    ///< PWM1 register base address
N#define UART1_BASE            (APB2PERIPH_BASE + 0x50000)    ///< UART1 register base address
N#define USBD_BASE             (APB1PERIPH_BASE + 0x60000)    ///< USBD register base address
N#define SC0_BASE              (APB2PERIPH_BASE + 0x90000)    ///< SC0 register base address
N#define I2S_BASE              (APB2PERIPH_BASE + 0xA0000)    ///< I2S register base address
N#define SC1_BASE              (APB2PERIPH_BASE + 0xB0000)    ///< SC1 register base address
N#define SC2_BASE              (APB2PERIPH_BASE + 0xC0000)    ///< SC2 register base address
N
N#define SYS_BASE              (AHBPERIPH_BASE + 0x00000)     ///< SYS register base address
N#define CLK_BASE              (AHBPERIPH_BASE + 0x00200)     ///< CLK register base address
N#define INT_BASE              (AHBPERIPH_BASE + 0x00300)     ///< INT register base address
N#define GPIOA_BASE            (AHBPERIPH_BASE + 0x04000)     ///< GPIO port A register base address
N#define GPIOB_BASE            (AHBPERIPH_BASE + 0x04040)     ///< GPIO port B register base address
N#define GPIOC_BASE            (AHBPERIPH_BASE + 0x04080)     ///< GPIO port C register base address
N#define GPIOD_BASE            (AHBPERIPH_BASE + 0x040C0)     ///< GPIO port D register base address
N#define GPIOE_BASE            (AHBPERIPH_BASE + 0x04100)     ///< GPIO port E register base address
N#define GPIOF_BASE            (AHBPERIPH_BASE + 0x04140)     ///< GPIO port F register base address
N#define GPIODBNCE_BASE        (AHBPERIPH_BASE + 0x04180)     ///< GPIO debounce register base address
N#define GPIO_PIN_DATA_BASE    (AHBPERIPH_BASE + 0x04200)     ///< GPIO bit access register base address
N#define VDMA_BASE             (AHBPERIPH_BASE + 0x08000)     ///< VDMA register base address
N#define PDMA1_BASE            (AHBPERIPH_BASE + 0x08100)     ///< PDMA1 register base address
N#define PDMA2_BASE            (AHBPERIPH_BASE + 0x08200)     ///< PDMA2 register base address
N#define PDMA3_BASE            (AHBPERIPH_BASE + 0x08300)     ///< PDMA3 register base address
N#define PDMA4_BASE            (AHBPERIPH_BASE + 0x08400)     ///< PDMA4 register base address
N#define PDMA5_BASE            (AHBPERIPH_BASE + 0x08500)     ///< PDMA5 register base address
N#define PDMA6_BASE            (AHBPERIPH_BASE + 0x08600)     ///< PDMA6 register base address
N#define PDMACRC_BASE          (AHBPERIPH_BASE + 0x08E00)     ///< PDMA global control register base address
N#define PDMAGCR_BASE          (AHBPERIPH_BASE + 0x08F00)     ///< PDMA CRC register base address
N#define FMC_BASE              (AHBPERIPH_BASE + 0x0C000)     ///< FMC register base address
N#define EBI_BASE              (AHBPERIPH_BASE + 0x10000)     ///< EBI register base address
N
N/*@}*/ /* end of group NANO100_PERIPHERAL_MEM_MAP */
N
N
N/** @addtogroup NANO100_PERIPHERAL_DECLARATION NANO100 Peripheral Declaration
N  The Declaration of NANO100 Series Peripheral
N  @{
N */
N#define WDT                   ((WDT_T *) WDT_BASE)              ///< Pointer to WDT register structure
N#define WWDT                  ((WWDT_T *) WWDT_BASE)            ///< Pointer to WWDT register structure
N#define RTC                   ((RTC_T *) RTC_BASE)              ///< Pointer to RTC register structure
N#define TIMER0                ((TIMER_T *) TIMER0_BASE)         ///< Pointer to TIMER0 register structure
N#define TIMER1                ((TIMER_T *) TIMER1_BASE)         ///< Pointer to TIMER1 register structure
N#define TIMER2                ((TIMER_T *) TIMER2_BASE)         ///< Pointer to TIMER2 register structure
N#define TIMER3                ((TIMER_T *) TIMER3_BASE)         ///< Pointer to TIMER3 register structure
N#define SHADOW                ((SHADOW_T *) SHADOW_BASE)        ///< Pointer to GPIO shadow register structure
N#define I2C0                  ((I2C_T *) I2C0_BASE)             ///< Pointer to I2C0 register structure
N#define I2C1                  ((I2C_T *) I2C1_BASE)             ///< Pointer to I2C1 register structure
N#define SPI0                  ((SPI_T *) SPI0_BASE)             ///< Pointer to SPI0 register structure
N#define SPI1                  ((SPI_T *) SPI1_BASE)             ///< Pointer to SPI1 register structure
N#define SPI2                  ((SPI_T *) SPI2_BASE)             ///< Pointer to SPI2 register structure
N#define PWM0                  ((PWM_T *) PWM0_BASE)             ///< Pointer to PWM0 register structure
N#define PWM1                  ((PWM_T *) PWM1_BASE)             ///< Pointer to PWM1 register structure
N#define UART0                 ((UART_T *) UART0_BASE)           ///< Pointer to UART0 register structure
N#define UART1                 ((UART_T *) UART1_BASE)           ///< Pointer to UART1 register structure
N#define LCD                   ((LCD_T *) LCD_BASE)              ///< Pointer to LCD register structure
N#define ADC                   ((ADC_T *) ADC_BASE)              ///< Pointer to ADC register structure
N#define SC0                   ((SC_T *) SC0_BASE)               ///< Pointer to SC0 register structure
N#define SC1                   ((SC_T *) SC1_BASE)               ///< Pointer to SC1 register structure
N#define SC2                   ((SC_T *) SC2_BASE)               ///< Pointer to SC2 register structure
N#define USBD                  ((USBD_T *) USBD_BASE)            ///< Pointer to USBD register structure
N#define I2S                   ((I2S_T *) I2S_BASE)              ///< Pointer to I2S register structure
N#define DAC                   ((DAC_T *) DAC_BASE)              ///< Pointer to DAC register structure
N
N#define SYS                   ((SYS_T *) SYS_BASE)              ///< Pointer to SYS register structure
N#define CLK                   ((CLK_T *) CLK_BASE)              ///< Pointer to CLK register structure
N#define INTR                  ((INTR_T *) INT_BASE)             ///< Pointer to INTR register structure
N#define PA                    ((GPIO_T *) GPIOA_BASE)           ///< Pointer to GPIO port A register structure
N#define PB                    ((GPIO_T *) GPIOB_BASE)           ///< Pointer to GPIO port B register structure
N#define PC                    ((GPIO_T *) GPIOC_BASE)           ///< Pointer to GPIO port C register structure
N#define PD                    ((GPIO_T *) GPIOD_BASE)           ///< Pointer to GPIO port D register structure
N#define PE                    ((GPIO_T *) GPIOE_BASE)           ///< Pointer to GPIO port E register structure
N#define PF                    ((GPIO_T *) GPIOF_BASE)           ///< Pointer to GPIO port F register structure
N#define GPIO                  ((GP_DB_T *) GPIODBNCE_BASE)      ///< Pointer to GPIO debounce register structure
N#define VDMA                  ((VDMA_T *) VDMA_BASE)            ///< Pointer to VDMA register structure
N#define PDMA1                 ((PDMA_T *) PDMA1_BASE)           ///< Pointer to PDMA1 register structure
N#define PDMA2                 ((PDMA_T *) PDMA2_BASE)           ///< Pointer to PDMA2 register structure
N#define PDMA3                 ((PDMA_T *) PDMA3_BASE)           ///< Pointer to PDMA3 register structure
N#define PDMA4                 ((PDMA_T *) PDMA4_BASE)           ///< Pointer to PDMA4 register structure
N#define PDMA5                 ((PDMA_T *) PDMA5_BASE)           ///< Pointer to PDMA5 register structure
N#define PDMA6                 ((PDMA_T *) PDMA6_BASE)           ///< Pointer to PDMA6 register structure
N#define PDMACRC               ((DMA_CRC_T *) PDMACRC_BASE)      ///< Pointer to PDMA CRC register structure
N#define PDMAGCR               ((DMA_GCR_T *) PDMAGCR_BASE)      ///< Pointer to PDMA global control register structure
N#define FMC                   ((FMC_T *) FMC_BASE)              ///< Pointer to FMC register structure
N#define EBI                   ((EBI_T *) EBI_BASE)              ///< Pointer to EBI register structure
N
N/*@}*/ /* end of group NANO100_PERIPHERAL_DECLARATION */
N
N/*@}*/ /* end of group NANO100_Peripherals */
N
N/** @addtogroup NANO100_IO_ROUTINE NANO100 I/O Routines
N  The Declaration of NANO100 I/O Routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N/*@}*/ /* end of group NANO100_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup NANO100_legacy_Constants NANO100 Legacy Constants
N  NANO100 Legacy Constants
N  @{
N*/
N
N#ifndef NULL
S#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N/*@}*/ /* end of group NANO100_legacy_Constants */
N
N/*@}*/ /* end of group NANO100_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/
N#include "sys.h"
L 1 "..\..\..\..\Library\StdDriver\inc\sys.h" 1
N/**************************************************************************//**
N* @file     sys.h
N* @version  V1.00
N* $Revision: 17 $
N* $Date: 15/06/24 1:11p $
N* @brief    Nano100 Series system control header file.
N*
N* @note
N* Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup NANO100_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CHIP_RST  ((0x0<<24) | SYS_IPRST_CTL1_CHIP_RST_Pos  ) /*!< CHIP reset is one of the SYS_ResetModule parameter */
N#define CPU_RST   ((0x0<<24) | SYS_IPRST_CTL1_CPU_RST_Pos   ) /*!< CPU reset is one of the SYS_ResetModule parameter */
N#define DMA_RST   ((0x0<<24) | SYS_IPRST_CTL1_DMA_RST_Pos   ) /*!< DMA reset is one of the SYS_ResetModule parameter */
N#define EBI_RST   ((0x0<<24) | SYS_IPRST_CTL1_EBI_RST_Pos   ) /*!< EBI reset is one of the SYS_ResetModule parameter */
N#define SC1_RST   ((0x4<<24) | SYS_IPRST_CTL2_SC1_RST_Pos   ) /*!< SmartCard1 reset is one of the SYS_ResetModule parameter */
N#define SC0_RST   ((0x4<<24) | SYS_IPRST_CTL2_SC0_RST_Pos   ) /*!< SmartCard0 reset is one of the SYS_ResetModule parameter */
N#define I2S_RST   ((0x4<<24) | SYS_IPRST_CTL2_I2S_RST_Pos   ) /*!< I2S reset is one of the SYS_ResetModule parameter */
N#define ADC_RST   ((0x4<<24) | SYS_IPRST_CTL2_ADC_RST_Pos   ) /*!< ADC reset is one of the SYS_ResetModule parameter */
N#define USBD_RST  ((0x4<<24) | SYS_IPRST_CTL2_USBD_RST_Pos  ) /*!< USBD reset is one of the SYS_ResetModule parameter */
N#define DAC_RST   ((0x4<<24) | SYS_IPRST_CTL2_DAC_RST_Pos   ) /*!< DAC reset is one of the SYS_ResetModule parameter */
N#define PWM1_RST  ((0x4<<24) | SYS_IPRST_CTL2_PWM1_RST_Pos  ) /*!< PWM1 reset is one of the SYS_ResetModule parameter */
N#define PWM0_RST  ((0x4<<24) | SYS_IPRST_CTL2_PWM0_RST_Pos  ) /*!< PWM0 reset is one of the SYS_ResetModule parameter */
N#define UART1_RST ((0x4<<24) | SYS_IPRST_CTL2_UART1_RST_Pos ) /*!< UART1 reset is one of the SYS_ResetModule parameter */
N#define UART0_RST ((0x4<<24) | SYS_IPRST_CTL2_UART0_RST_Pos ) /*!< UART0 reset is one of the SYS_ResetModule parameter */
N#define SPI2_RST  ((0x4<<24) | SYS_IPRST_CTL2_SPI2_RST_Pos  ) /*!< SPI2 reset is one of the SYS_ResetModule parameter */
N#define SPI1_RST  ((0x4<<24) | SYS_IPRST_CTL2_SPI1_RST_Pos  ) /*!< SPI1 reset is one of the SYS_ResetModule parameter */
N#define SPI0_RST  ((0x4<<24) | SYS_IPRST_CTL2_SPI0_RST_Pos  ) /*!< SPI0 reset is one of the SYS_ResetModule parameter */
N#define I2C1_RST  ((0x4<<24) | SYS_IPRST_CTL2_I2C1_RST_Pos  ) /*!< I2C1 reset is one of the SYS_ResetModule parameter */
N#define I2C0_RST  ((0x4<<24) | SYS_IPRST_CTL2_I2C0_RST_Pos  ) /*!< I2C0 reset is one of the SYS_ResetModule parameter */
N#define TMR3_RST  ((0x4<<24) | SYS_IPRST_CTL2_TMR3_RST_Pos  ) /*!< Timer3 reset is one of the SYS_ResetModule parameter */
N#define TMR2_RST  ((0x4<<24) | SYS_IPRST_CTL2_TMR2_RST_Pos  ) /*!< Timer2 reset is one of the SYS_ResetModule parameter */
N#define TMR1_RST  ((0x4<<24) | SYS_IPRST_CTL2_TMR1_RST_Pos  ) /*!< Timer1 reset is one of the SYS_ResetModule parameter */
N#define TMR0_RST  ((0x4<<24) | SYS_IPRST_CTL2_TMR0_RST_Pos  ) /*!< Timer0 reset is one of the SYS_ResetModule parameter */
N#define GPIO_RST  ((0x4<<24) | SYS_IPRST_CTL2_GPIO_RST_Pos  ) /*!< GPIO reset is one of the SYS_ResetModule parameter */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/********************* Bit definition of VREFCTL register **********************/
N#define SYS_VREFCTL_BGP_EN      SYS_VREFCTL_BGP_EN_Msk       /*!<Band-gap Enable */
N#define SYS_VREFCTL_REG_EN      SYS_VREFCTL_REG_EN_Msk       /*!<Regulator Enable */
N#define SYS_VREFCTL_SEL25       SYS_VREFCTL_SEL25_Msk        /*!<Regulator Output Voltage 2.5V */
N#define SYS_VREFCTL_EXTMODE     SYS_VREFCTL_EXT_MODE_Msk     /*!<Regulator External Mode */
N
N/********************* Bit definition of IRCTRIMCTL register **********************/
N#define SYS_IRCTRIMCTL_TRIM_11_0592M (0x1UL<<SYS_IRCTRIMCTL_TRIM_SEL_Pos)      /*!<Trim HIRC to 11.0592 MHz */
N#define SYS_IRCTRIMCTL_TRIM_12M      (0x2UL<<SYS_IRCTRIMCTL_TRIM_SEL_Pos)      /*!<Trim HIRC to 12 MHz */
N#define SYS_IRCTRIMCTL_TRIM_12_288M  (0x3UL<<SYS_IRCTRIMCTL_TRIM_SEL_Pos)      /*!<Trim HIRC to 12.288 MHz */
N
N#define SYS_IRCTRIMCTL_LOOP_4CLK     (0x0UL<<SYS_IRCTRIMCTL_TRIM_LOOP_Pos)     /*!<Based on average difference in 4 x 32.768 kHz clock */
N#define SYS_IRCTRIMCTL_LOOP_8CLK     (0x1UL<<SYS_IRCTRIMCTL_TRIM_LOOP_Pos)     /*!<Based on average difference in 8 x 32.768 kHz clock */
N#define SYS_IRCTRIMCTL_LOOP_16CLK    (0x2UL<<SYS_IRCTRIMCTL_TRIM_LOOP_Pos)     /*!<Based on average difference in 16 x 32.768 kHz clock */
N#define SYS_IRCTRIMCTL_LOOP_32CLK    (0x3UL<<SYS_IRCTRIMCTL_TRIM_LOOP_Pos)     /*!<Based on average difference in 32 x 32.768 kHz clock */
N
N#define SYS_IRCTRIMCTL_RETRY_64     (0x0UL<<SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos) /*!<Trim retry count limitation is 64 */
N#define SYS_IRCTRIMCTL_RETRY_128    (0x1UL<<SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos) /*!<Trim retry count limitation is 128 */
N#define SYS_IRCTRIMCTL_RETRY_256    (0x2UL<<SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos) /*!<Trim retry count limitation is 256 */
N#define SYS_IRCTRIMCTL_RETRY_512    (0x3UL<<SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos) /*!<Trim retry count limitation is 512 */
N
N/********************* Bit definition of IRCTRIMIEN register **********************/
N#define SYS_IRCTRIMIEN_DISABLE      ((uint32_t)0x00000000)                /*!<Trim failure interrupt disable */
N#define SYS_IRCTRIMIEN_FAIL_EN      SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Msk      /*!<Trim failure interrupt enable */
N#define SYS_IRCTRIMIEN_32KERR_EN    SYS_IRCTRIMIEN_32K_ERR_IEN_Msk        /*!<32.768 kHz Clock Error Interrupt Enable */
N
N/********************* Bit definition of IRCTRIMINT register **********************/
N#define SYS_IRCTRIMINT_FREQLOCK     SYS_IRCTRIMINT_FREQ_LOCK_Msk          /*!<HIRC frequency lock status */
N#define SYS_IRCTRIMINT_FAIL_INT     SYS_IRCTRIMINT_TRIM_FAIL_INT_Msk      /*!<Trim failure interrupt status */
N#define SYS_IRCTRIMINT_32KERR_INT   SYS_IRCTRIMINT_32K_ERR_INT_Msk        /*!<32.768 kHz Clock Error Interrupt Status */
N
N/********************* Bit definition of PA_L_MFP register **********************/
N
N#define SYS_PA_L_MFP_PA7_MFP_GPA7         (0UL<<SYS_PA_L_MFP_PA7_MFP_Pos)     /*!<PA7 Pin Function - GPIOA[7] */
N#define SYS_PA_L_MFP_PA7_MFP_ADC_CH7      (1UL<<SYS_PA_L_MFP_PA7_MFP_Pos)     /*!<PA7 Pin Function - ADC input channel 7 */
N#define SYS_PA_L_MFP_PA7_MFP_EBI_AD6      (2UL<<SYS_PA_L_MFP_PA7_MFP_Pos)     /*!<PA7 Pin Function - EBI AD[6] */
N#define SYS_PA_L_MFP_PA7_MFP_TMR2_CAP     (3UL<<SYS_PA_L_MFP_PA7_MFP_Pos)     /*!<PA7 Pin Function - Timer 2 capture event */
N#define SYS_PA_L_MFP_PA7_MFP_SC2_DAT      (4UL<<SYS_PA_L_MFP_PA7_MFP_Pos)     /*!<PA7 Pin Function - SmartCard 2 data pin */
N#define SYS_PA_L_MFP_PA7_MFP_PWM0_CH2     (5UL<<SYS_PA_L_MFP_PA7_MFP_Pos)     /*!<PA7 Pin Function - PWM0 Channel 2 */
N#define SYS_PA_L_MFP_PA7_MFP_LCD_S36      (7UL<<SYS_PA_L_MFP_PA7_MFP_Pos)     /*!<PA7 Pin Function - LCD SEG 36 */
N
N#define SYS_PA_L_MFP_PA6_MFP_GPA6         (0UL<<SYS_PA_L_MFP_PA6_MFP_Pos)     /*!<PA6 Pin Function - GPIOA[6] */
N#define SYS_PA_L_MFP_PA6_MFP_ADC_CH6      (1UL<<SYS_PA_L_MFP_PA6_MFP_Pos)     /*!<PA6 Pin Function - ADC input channel 6 */
N#define SYS_PA_L_MFP_PA6_MFP_EBI_AD7      (2UL<<SYS_PA_L_MFP_PA6_MFP_Pos)     /*!<PA6 Pin Function - EBI AD[7] */
N#define SYS_PA_L_MFP_PA6_MFP_TMR3_CAP     (3UL<<SYS_PA_L_MFP_PA6_MFP_Pos)     /*!<PA6 Pin Function - Timer 3 Capture event */
N#define SYS_PA_L_MFP_PA6_MFP_SC2_CLK      (4UL<<SYS_PA_L_MFP_PA6_MFP_Pos)     /*!<PA6 Pin Function - SmartCard 2 clock */
N#define SYS_PA_L_MFP_PA6_MFP_PWM0_CH3     (5UL<<SYS_PA_L_MFP_PA6_MFP_Pos)     /*!<PA6 Pin Function - PWM0 Channel 3 */
N#define SYS_PA_L_MFP_PA6_MFP_LCD_S37      (7UL<<SYS_PA_L_MFP_PA6_MFP_Pos)     /*!<PA6 Pin Function - LCD SEG 37 */
N#define SYS_PA_L_MFP_PA6_MFP_LCD_S19      (7UL<<SYS_PA_L_MFP_PA6_MFP_Pos)     /*!<PA6 Pin Function - LCD SEG 19 */
N
N#define SYS_PA_L_MFP_PA5_MFP_GPA5         (0UL<<SYS_PA_L_MFP_PA5_MFP_Pos)     /*!<PA5 Pin Function - GPIOA[5] */
N#define SYS_PA_L_MFP_PA5_MFP_ADC_CH5      (1UL<<SYS_PA_L_MFP_PA5_MFP_Pos)     /*!<PA5 Pin Function - ADC input channel 5 */
N#define SYS_PA_L_MFP_PA5_MFP_EBI_AD8      (2UL<<SYS_PA_L_MFP_PA5_MFP_Pos)     /*!<PA5 Pin Function - EBI AD[8] */
N#define SYS_PA_L_MFP_PA5_MFP_SC2_RST      (4UL<<SYS_PA_L_MFP_PA5_MFP_Pos)     /*!<PA5 Pin Function - SmartCard2 RST */
N#define SYS_PA_L_MFP_PA5_MFP_I2C0_SCL     (5UL<<SYS_PA_L_MFP_PA5_MFP_Pos)     /*!<PA5 Pin Function - I2C0 clock */
N#define SYS_PA_L_MFP_PA5_MFP_LCD_S38      (7UL<<SYS_PA_L_MFP_PA5_MFP_Pos)     /*!<PA5 Pin Function - LCD SEG 38 */
N#define SYS_PA_L_MFP_PA5_MFP_LCD_S20      (7UL<<SYS_PA_L_MFP_PA5_MFP_Pos)     /*!<PA5 Pin Function - LCD SEG 20 */
N
N#define SYS_PA_L_MFP_PA4_MFP_GPA4         (0UL<<SYS_PA_L_MFP_PA4_MFP_Pos)     /*!<PA4 Pin Function - GPIOA[4] */
N#define SYS_PA_L_MFP_PA4_MFP_ADC_CH4      (1UL<<SYS_PA_L_MFP_PA4_MFP_Pos)     /*!<PA4 Pin Function - ADC input channel 4 */
N#define SYS_PA_L_MFP_PA4_MFP_EBI_AD9      (2UL<<SYS_PA_L_MFP_PA4_MFP_Pos)     /*!<PA4 Pin Function - EBI AD[9] */
N#define SYS_PA_L_MFP_PA4_MFP_SC2_PWR      (4UL<<SYS_PA_L_MFP_PA4_MFP_Pos)     /*!<PA4 Pin Function - SmartCard 2 power */
N#define SYS_PA_L_MFP_PA4_MFP_I2C0_SDA     (5UL<<SYS_PA_L_MFP_PA4_MFP_Pos)     /*!<PA4 Pin Function - I2C0 DATA */
N#define SYS_PA_L_MFP_PA4_MFP_LCD_S39      (7UL<<SYS_PA_L_MFP_PA4_MFP_Pos)     /*!<PA4 Pin Function - LCD SEG 39 */
N#define SYS_PA_L_MFP_PA4_MFP_LCD_S21      (7UL<<SYS_PA_L_MFP_PA4_MFP_Pos)     /*!<PA4 Pin Function - LCD SEG 21 */
N
N#define SYS_PA_L_MFP_PA3_MFP_GPA3         (0UL<<SYS_PA_L_MFP_PA3_MFP_Pos)     /*!<PA3 Pin Function - GPIOA[3] */
N#define SYS_PA_L_MFP_PA3_MFP_ADC_CH3      (1UL<<SYS_PA_L_MFP_PA3_MFP_Pos)     /*!<PA3 Pin Function - ADC input channel 3 */
N#define SYS_PA_L_MFP_PA3_MFP_EBI_AD10     (2UL<<SYS_PA_L_MFP_PA3_MFP_Pos)     /*!<PA3 Pin Function - EBI AD[10] */
N#define SYS_PA_L_MFP_PA3_MFP_UART1_TX     (5UL<<SYS_PA_L_MFP_PA3_MFP_Pos)     /*!<PA3 Pin Function - UART 1 RX */
N#define SYS_PA_L_MFP_PA3_MFP_LCD_S22      (7UL<<SYS_PA_L_MFP_PA3_MFP_Pos)     /*!<PA3 Pin Function - LCD SEG 22 */
N
N#define SYS_PA_L_MFP_PA2_MFP_GPA2         (0UL<<SYS_PA_L_MFP_PA2_MFP_Pos)     /*!<PA2 Pin Function - GPIOA[2] */
N#define SYS_PA_L_MFP_PA2_MFP_ADC_CH2      (1UL<<SYS_PA_L_MFP_PA2_MFP_Pos)     /*!<PA2 Pin Function - ADC input channel 2 */
N#define SYS_PA_L_MFP_PA2_MFP_EBI_AD11     (2UL<<SYS_PA_L_MFP_PA2_MFP_Pos)     /*!<PA2 Pin Function - EBI AD[11] */
N#define SYS_PA_L_MFP_PA2_MFP_UART1_RX     (5UL<<SYS_PA_L_MFP_PA2_MFP_Pos)     /*!<PA2 Pin Function - UART1 TX */
N#define SYS_PA_L_MFP_PA2_MFP_LCD_S23      (7UL<<SYS_PA_L_MFP_PA2_MFP_Pos)     /*!<PA2 Pin Function - LCD SEG 23 */
N
N#define SYS_PA_L_MFP_PA1_MFP_GPA1         (0UL<<SYS_PA_L_MFP_PA1_MFP_Pos)     /*!<PA1 Pin Function - GPIOA[1] */
N#define SYS_PA_L_MFP_PA1_MFP_ADC_CH1      (1UL<<SYS_PA_L_MFP_PA1_MFP_Pos)     /*!<PA1 Pin Function - ADC input channel 1 */
N#define SYS_PA_L_MFP_PA1_MFP_EBI_AD12     (2UL<<SYS_PA_L_MFP_PA1_MFP_Pos)     /*!<PA1 Pin Function - EBI AD[12] */
N
N#define SYS_PA_L_MFP_PA0_MFP_GPA0         (0UL<<SYS_PA_L_MFP_PA0_MFP_Pos)     /*!<PA0 Pin Function - GPIOA[0] */
N#define SYS_PA_L_MFP_PA0_MFP_ADC_CH0      (1UL<<SYS_PA_L_MFP_PA0_MFP_Pos)     /*!<PA0 Pin Function - ADC input channel 0 */
N#define SYS_PA_L_MFP_PA0_MFP_SC2_CD       (4UL<<SYS_PA_L_MFP_PA0_MFP_Pos)     /*!<PA0 Pin Function - SmartCard 2 card detect */
N
N/********************* Bit definition of PA_H_MFP register **********************/
N#define SYS_PA_H_MFP_PA15_MFP_GPA15       (0UL<<SYS_PA_H_MFP_PA15_MFP_Pos)    /*!<PA15 Pin Function - GPIOA[15] */
N#define SYS_PA_H_MFP_PA15_MFP_PWM0_CH3    (1UL<<SYS_PA_H_MFP_PA15_MFP_Pos)      /*!<PA15 Pin Function - PWM0 Channel 3 */
N#define SYS_PA_H_MFP_PA15_MFP_I2S_MCLK    (2UL<<SYS_PA_H_MFP_PA15_MFP_Pos)      /*!<PA15 Pin Function - I2S MCLK */
N#define SYS_PA_H_MFP_PA15_MFP_TMR3_CAP    (3UL<<SYS_PA_H_MFP_PA15_MFP_Pos)      /*!<PA15 Pin Function - Timer3 capture event */
N#define SYS_PA_H_MFP_PA15_MFP_SC0_PWR     (4UL<<SYS_PA_H_MFP_PA15_MFP_Pos)      /*!<PA15 Pin Function - SmartCard 0 power */
N#define SYS_PA_H_MFP_PA15_MFP_UART0_TX    (6UL<<SYS_PA_H_MFP_PA15_MFP_Pos)      /*!<PA15 Pin Function - UART0 TX */
N#define SYS_PA_H_MFP_PA15_MFP_LCD_S27     (7UL<<SYS_PA_H_MFP_PA15_MFP_Pos)      /*!<PA15 Pin Function - LCD SEG 27 */
N
N#define SYS_PA_H_MFP_PA14_MFP_GPA14       (0UL<<SYS_PA_H_MFP_PA14_MFP_Pos)      /*!<PA14 Pin Function - GPIOA[14] */
N#define SYS_PA_H_MFP_PA14_MFP_PWM0_CH2    (1UL<<SYS_PA_H_MFP_PA14_MFP_Pos)      /*!<PA14 Pin Function - PWM0 Channel 2 */
N#define SYS_PA_H_MFP_PA14_MFP_EBI_AD15    (2UL<<SYS_PA_H_MFP_PA14_MFP_Pos)      /*!<PA14 Pin Function - EBI AD[15] */
N#define SYS_PA_H_MFP_PA14_MFP_TMR2_CAP    (3UL<<SYS_PA_H_MFP_PA14_MFP_Pos)      /*!<PA14 Pin Function - Timer2 capture event */
N#define SYS_PA_H_MFP_PA14_MFP_UART0_RX    (6UL<<SYS_PA_H_MFP_PA14_MFP_Pos)      /*!<PA14 Pin Function - UART0 RX */
N#define SYS_PA_H_MFP_PA14_MFP_LCD_S26     (7UL<<SYS_PA_H_MFP_PA14_MFP_Pos)      /*!<PA14 Pin Function - LCD SEG 26 */
N
N#define SYS_PA_H_MFP_PA13_MFP_GPA13       (0UL<<SYS_PA_H_MFP_PA13_MFP_Pos)      /*!<PA13 Pin Function - GPIOA[13] */
N#define SYS_PA_H_MFP_PA13_MFP_PWM0_CH1    (1UL<<SYS_PA_H_MFP_PA13_MFP_Pos)      /*!<PA13 Pin Function - PWM0 Channel 1 */
N#define SYS_PA_H_MFP_PA13_MFP_EBI_AD14    (2UL<<SYS_PA_H_MFP_PA13_MFP_Pos)      /*!<PA13 Pin Function - EBI AD[14] */
N#define SYS_PA_H_MFP_PA13_MFP_TMR1_CAP    (3UL<<SYS_PA_H_MFP_PA13_MFP_Pos)      /*!<PA13 Pin Function - Timer1 capture event */
N#define SYS_PA_H_MFP_PA13_MFP_I2C0_SCL    (5UL<<SYS_PA_H_MFP_PA13_MFP_Pos)      /*!<PA13 Pin Function - I2C0 clock */
N#define SYS_PA_H_MFP_PA13_MFP_LCD_S25     (7UL<<SYS_PA_H_MFP_PA13_MFP_Pos)      /*!<PA13 Pin Function - LCD SEG 25 */
N
N#define SYS_PA_H_MFP_PA12_MFP_GPA12       (0UL<<SYS_PA_H_MFP_PA12_MFP_Pos)      /*!<PA12 Pin Function - GPIOA[12] */
N#define SYS_PA_H_MFP_PA12_MFP_PWM0_CH0    (1UL<<SYS_PA_H_MFP_PA12_MFP_Pos)      /*!<PA12 Pin Function - PWM0 Channel 0 */
N#define SYS_PA_H_MFP_PA12_MFP_EBI_AD13    (2UL<<SYS_PA_H_MFP_PA12_MFP_Pos)      /*!<PA12 Pin Function - EBI AD[13] */
N#define SYS_PA_H_MFP_PA12_MFP_TMR0_CAP    (3UL<<SYS_PA_H_MFP_PA12_MFP_Pos)      /*!<PA12 Pin Function - Timer0 capture event */
N#define SYS_PA_H_MFP_PA12_MFP_I2C0_SDA    (5UL<<SYS_PA_H_MFP_PA12_MFP_Pos)      /*!<PA12 Pin Function - I2C0 DATA */
N#define SYS_PA_H_MFP_PA12_MFP_LCD_S24     (7UL<<SYS_PA_H_MFP_PA12_MFP_Pos)      /*!<PA12 Pin Function - LCD SEG 24 */
N
N#define SYS_PA_H_MFP_PA11_MFP_GPA11       (0UL<<SYS_PA_H_MFP_PA11_MFP_Pos)      /*!<PA11 Pin Function - GPIOA[11] */
N#define SYS_PA_H_MFP_PA11_MFP_I2C1_SCL    (1UL<<SYS_PA_H_MFP_PA11_MFP_Pos)      /*!<PA11 Pin Function - I2C1 clock */
N#define SYS_PA_H_MFP_PA11_MFP_EBI_NRE     (2UL<<SYS_PA_H_MFP_PA11_MFP_Pos)      /*!<PA11 Pin Function - EBI nRE */
N#define SYS_PA_H_MFP_PA11_MFP_SC0_RST     (3UL<<SYS_PA_H_MFP_PA11_MFP_Pos)      /*!<PA11 Pin Function - SmartCard0 RST */
N#define SYS_PA_H_MFP_PA11_MFP_SPI2_MOSI0  (4UL<<SYS_PA_H_MFP_PA11_MFP_Pos)      /*!<PA11 Pin Function - SPI2 MOSI[0] */
N#define SYS_PA_H_MFP_PA11_MFP_LCD_S23     (7UL<<SYS_PA_H_MFP_PA11_MFP_Pos)      /*!<PA11 Pin Function - LCD SEG 23 */
N#define SYS_PA_H_MFP_PA11_MFP_LCD_S9      (7UL<<SYS_PA_H_MFP_PA11_MFP_Pos)      /*!<PA11 Pin Function - LCD SEG 9 */
N
N#define SYS_PA_H_MFP_PA10_MFP_GPA10       (0UL<<SYS_PA_H_MFP_PA10_MFP_Pos)      /*!<PA10 Pin Function - GPIOA[10] */
N#define SYS_PA_H_MFP_PA10_MFP_I2C1_SDA    (1UL<<SYS_PA_H_MFP_PA10_MFP_Pos)      /*!<PA10 Pin Function - I2C1 DATA */
N#define SYS_PA_H_MFP_PA10_MFP_EBI_NWE     (2UL<<SYS_PA_H_MFP_PA10_MFP_Pos)      /*!<PA10 Pin Function - EBI nWE */
N#define SYS_PA_H_MFP_PA10_MFP_SC0_PWR     (3UL<<SYS_PA_H_MFP_PA10_MFP_Pos)      /*!<PA10 Pin Function - SmartCard0 Power */
N#define SYS_PA_H_MFP_PA10_MFP_SPI2_MISO0  (4UL<<SYS_PA_H_MFP_PA10_MFP_Pos)      /*!<PA10 Pin Function - SPI2 MISO[0] */
N#define SYS_PA_H_MFP_PA10_MFP_LCD_S22     (7UL<<SYS_PA_H_MFP_PA10_MFP_Pos)      /*!<PA10 Pin Function - LCD SEG 22 */
N#define SYS_PA_H_MFP_PA10_MFP_LCD_S8      (7UL<<SYS_PA_H_MFP_PA10_MFP_Pos)      /*!<PA10 Pin Function - LCD SEG 8 */
N
N#define SYS_PA_H_MFP_PA9_MFP_GPA9         (0UL<<SYS_PA_H_MFP_PA9_MFP_Pos)     /*!<PA9 Pin Function - GPIOA[9] */
N#define SYS_PA_H_MFP_PA9_MFP_I2C0_SCL     (1UL<<SYS_PA_H_MFP_PA9_MFP_Pos)     /*!<PA9 Pin Function - I2C0 clock */
N#define SYS_PA_H_MFP_PA9_MFP_SC0_DAT      (3UL<<SYS_PA_H_MFP_PA9_MFP_Pos)     /*!<PA9 Pin Function - SmartCard0 DATA */
N#define SYS_PA_H_MFP_PA9_MFP_SPI2_SCLK    (4UL<<SYS_PA_H_MFP_PA9_MFP_Pos)     /*!<PA9 Pin Function - SPI2 SCLK */
N#define SYS_PA_H_MFP_PA9_MFP_LCD_S21      (7UL<<SYS_PA_H_MFP_PA9_MFP_Pos)     /*!<PA9 Pin Function - LCD SEG 21 */
N#define SYS_PA_H_MFP_PA9_MFP_LCD_S7       (7UL<<SYS_PA_H_MFP_PA9_MFP_Pos)     /*!<PA9 Pin Function - LCD SEG 7 */
N
N#define SYS_PA_H_MFP_PA8_MFP_GPA8         (0UL<<SYS_PA_H_MFP_PA8_MFP_Pos)     /*!<PA8 Pin Function - GPIOA[8] */
N#define SYS_PA_H_MFP_PA8_MFP_I2C0_SDA     (1UL<<SYS_PA_H_MFP_PA8_MFP_Pos)     /*!<PA8 Pin Function - I2C0 DATA */
N#define SYS_PA_H_MFP_PA8_MFP_SC0_CLK      (3UL<<SYS_PA_H_MFP_PA8_MFP_Pos)     /*!<PA8 Pin Function - SmartCard0 clock */
N#define SYS_PA_H_MFP_PA8_MFP_SPI2_SS0     (4UL<<SYS_PA_H_MFP_PA8_MFP_Pos)     /*!<PA8 Pin Function - SPI2 1st chip selection */
N#define SYS_PA_H_MFP_PA8_MFP_LCD_S20      (7UL<<SYS_PA_H_MFP_PA8_MFP_Pos)     /*!<PA8 Pin Function - LCD SEG 20 */
N#define SYS_PA_H_MFP_PA8_MFP_LCD_S6       (7UL<<SYS_PA_H_MFP_PA8_MFP_Pos)     /*!<PA8 Pin Function - LCD SEG 6 */
N
N/********************* Bit definition of PB_L_MFP register **********************/
N#define SYS_PB_L_MFP_PB7_MFP_GPB7         (0UL<<SYS_PB_L_MFP_PB7_MFP_Pos)     /*!<PB7 Pin Function - GPIOB[7] */
N#define SYS_PB_L_MFP_PB7_MFP_UART1_CTS    (1UL<<SYS_PB_L_MFP_PB7_MFP_Pos)     /*!<PB7 Pin Function - UART1 CTSn */
N#define SYS_PB_L_MFP_PB7_MFP_EBI_NCS      (2UL<<SYS_PB_L_MFP_PB7_MFP_Pos)     /*!<PB7 Pin Function - EBI nCS */
N#define SYS_PB_L_MFP_PB7_MFP_SPI2_MOSI0   (4UL<<SYS_PB_L_MFP_PB7_MFP_Pos)     /*!<PB7 Pin Function - SPI2 MOSI[0] */
N#define SYS_PB_L_MFP_PB7_MFP_LCD_S10      (7UL<<SYS_PB_L_MFP_PB7_MFP_Pos)     /*!<PB7 Pin Function - LCD SEG 10 */
N#define SYS_PB_L_MFP_PB7_MFP_LCD_S2       (7UL<<SYS_PB_L_MFP_PB7_MFP_Pos)     /*!<PB7 Pin Function - LCD SEG 2 */
N
N#define SYS_PB_L_MFP_PB6_MFP_GPB6         (0UL<<SYS_PB_L_MFP_PB6_MFP_Pos)     /*!<PB6 Pin Function - GPIOB[6] */
N#define SYS_PB_L_MFP_PB6_MFP_UART1_RTS    (1UL<<SYS_PB_L_MFP_PB6_MFP_Pos)     /*!<PB6 Pin Function - UART1 RTSn */
N#define SYS_PB_L_MFP_PB6_MFP_EBI_ALE      (2UL<<SYS_PB_L_MFP_PB6_MFP_Pos)     /*!<PB6 Pin Function - EBI ALE */
N#define SYS_PB_L_MFP_PB6_MFP_SPI2_MISO0   (4UL<<SYS_PB_L_MFP_PB6_MFP_Pos)     /*!<PB6 Pin Function - SPI2 MISO[0] */
N#define SYS_PB_L_MFP_PB6_MFP_LCD_S11      (7UL<<SYS_PB_L_MFP_PB6_MFP_Pos)     /*!<PB6 Pin Function - LCD SEG 11 */
N#define SYS_PB_L_MFP_PB6_MFP_LCD_S3       (7UL<<SYS_PB_L_MFP_PB6_MFP_Pos)     /*!<PB6 Pin Function - LCD SEG 3 */
N
N#define SYS_PB_L_MFP_PB5_MFP_GPB5         (0UL<<SYS_PB_L_MFP_PB5_MFP_Pos)     /*!<PB5 Pin Function - GPIOB[5] */
N#define SYS_PB_L_MFP_PB5_MFP_UART1_TX     (1UL<<SYS_PB_L_MFP_PB5_MFP_Pos)     /*!<PB5 Pin Function - UART1 TX */
N#define SYS_PB_L_MFP_PB5_MFP_SC0_RST      (3UL<<SYS_PB_L_MFP_PB5_MFP_Pos)     /*!<PB5 Pin Function - SmartCard0 RST */
N#define SYS_PB_L_MFP_PB5_MFP_SPI2_SCLK    (4UL<<SYS_PB_L_MFP_PB5_MFP_Pos)     /*!<PB5 Pin Function - SPI2 SCLK */
N#define SYS_PB_L_MFP_PB5_MFP_LCD_S12      (7UL<<SYS_PB_L_MFP_PB5_MFP_Pos)     /*!<PB5 Pin Function - LCD SEG 12 */
N#define SYS_PB_L_MFP_PB5_MFP_LCD_S4       (7UL<<SYS_PB_L_MFP_PB5_MFP_Pos)     /*!<PB5 Pin Function - LCD SEG 4 */
N
N#define SYS_PB_L_MFP_PB4_MFP_GPB4         (0UL<<SYS_PB_L_MFP_PB4_MFP_Pos)     /*!<PB4 Pin Function - GPIOB[4] */
N#define SYS_PB_L_MFP_PB4_MFP_UART1_RX     (1UL<<SYS_PB_L_MFP_PB4_MFP_Pos)     /*!<PB4 Pin Function - UART1 RX */
N#define SYS_PB_L_MFP_PB4_MFP_SC0_CD       (3UL<<SYS_PB_L_MFP_PB4_MFP_Pos)     /*!<PB4 Pin Function - SmartCard0 card detection */
N#define SYS_PB_L_MFP_PB4_MFP_SPI2_SS0     (4UL<<SYS_PB_L_MFP_PB4_MFP_Pos)     /*!<PB4 Pin Function - SPI2 chip selection 0 */
N#define SYS_PB_L_MFP_PB4_MFP_LCD_S13      (7UL<<SYS_PB_L_MFP_PB4_MFP_Pos)     /*!<PB4 Pin Function - LCD SEG 13 */
N#define SYS_PB_L_MFP_PB4_MFP_LCD_S5       (7UL<<SYS_PB_L_MFP_PB4_MFP_Pos)     /*!<PB4 Pin Function - LCD SEG 5 */
N
N#define SYS_PB_L_MFP_PB3_MFP_GPB3         (0UL<<SYS_PB_L_MFP_PB3_MFP_Pos)     /*!<PB3 Pin Function - GPIOB[3] */
N#define SYS_PB_L_MFP_PB3_MFP_UART0_CTS    (1UL<<SYS_PB_L_MFP_PB3_MFP_Pos)     /*!<PB3 Pin Function - UART0 CTSn */
N#define SYS_PB_L_MFP_PB3_MFP_EBI_NWRH     (2UL<<SYS_PB_L_MFP_PB3_MFP_Pos)     /*!<PB3 Pin Function - EBI nWRH */
N#define SYS_PB_L_MFP_PB3_MFP_SPI1_SS0     (3UL<<SYS_PB_L_MFP_PB3_MFP_Pos)     /*!<PB3 Pin Function - SPI1 chip selection 0 */
N#define SYS_PB_L_MFP_PB3_MFP_LCD_S4       (7UL<<SYS_PB_L_MFP_PB3_MFP_Pos)     /*!<PB3 Pin Function - LCD SEG 4 */
N#define SYS_PB_L_MFP_PB3_MFP_LCD_COM2     (7UL<<SYS_PB_L_MFP_PB3_MFP_Pos)     /*!<PB3 Pin Function - LCD COM 2 */
N
N#define SYS_PB_L_MFP_PB2_MFP_GPB2         (0UL<<SYS_PB_L_MFP_PB2_MFP_Pos)     /*!<PB2 Pin Function - GPIOB[2] */
N#define SYS_PB_L_MFP_PB2_MFP_UART0_RTS    (1UL<<SYS_PB_L_MFP_PB2_MFP_Pos)     /*!<PB2 Pin Function - UART0 RTSn */
N#define SYS_PB_L_MFP_PB2_MFP_EBI_NWRL     (2UL<<SYS_PB_L_MFP_PB2_MFP_Pos)     /*!<PB2 Pin Function - EBI nWRL */
N#define SYS_PB_L_MFP_PB2_MFP_SPI1_SCLK    (3UL<<SYS_PB_L_MFP_PB2_MFP_Pos)     /*!<PB2 Pin Function - SPI1 SCLK */
N#define SYS_PB_L_MFP_PB2_MFP_LCD_S5       (7UL<<SYS_PB_L_MFP_PB2_MFP_Pos)     /*!<PB2 Pin Function - LCD SEG 5 */
N#define SYS_PB_L_MFP_PB2_MFP_LCD_COM3     (7UL<<SYS_PB_L_MFP_PB2_MFP_Pos)     /*!<PB2 Pin Function - LCD COM 3 */
N
N#define SYS_PB_L_MFP_PB1_MFP_GPB1         (0UL<<SYS_PB_L_MFP_PB1_MFP_Pos)     /*!<PB1 Pin Function - GPIOB[1] */
N#define SYS_PB_L_MFP_PB1_MFP_UART0_TX     (1UL<<SYS_PB_L_MFP_PB1_MFP_Pos)     /*!<PB1 Pin Function - UART0 TX */
N#define SYS_PB_L_MFP_PB1_MFP_SPI1_MISO0   (3UL<<SYS_PB_L_MFP_PB1_MFP_Pos)     /*!<PB1 Pin Function - SPI1 MISO[0] */
N#define SYS_PB_L_MFP_PB1_MFP_LCD_S6       (7UL<<SYS_PB_L_MFP_PB1_MFP_Pos)     /*!<PB1 Pin Function - LCD SEG 6 */
N#define SYS_PB_L_MFP_PB1_MFP_LCD_S0       (7UL<<SYS_PB_L_MFP_PB1_MFP_Pos)     /*!<PB1 Pin Function - LCD SEG 0 */
N
N#define SYS_PB_L_MFP_PB0_MFP_GPB0         (0UL<<SYS_PB_L_MFP_PB0_MFP_Pos)     /*!<PB0 Pin Function - GPIOB[0] */
N#define SYS_PB_L_MFP_PB0_MFP_UART0_RX     (1UL<<SYS_PB_L_MFP_PB0_MFP_Pos)     /*!<PB0 Pin Function - UART0 RX */
N#define SYS_PB_L_MFP_PB0_MFP_SPI1_MOSI0   (3UL<<SYS_PB_L_MFP_PB0_MFP_Pos)     /*!<PB0 Pin Function - SPI1 MOSI[0] */
N#define SYS_PB_L_MFP_PB0_MFP_LCD_S7       (7UL<<SYS_PB_L_MFP_PB0_MFP_Pos)     /*!<PB0 Pin Function - LCD SEG 7 */
N#define SYS_PB_L_MFP_PB0_MFP_LCD_S1       (7UL<<SYS_PB_L_MFP_PB0_MFP_Pos)     /*!<PB0 Pin Function - LCD SEG 1 */
N
N/********************* Bit definition of PB_H_MFP register **********************/
N#define SYS_PB_H_MFP_PB15_MFP_GPB15       (0UL<<SYS_PB_H_MFP_PB15_MFP_Pos)      /*!<PB15 Pin Function - GPIOB[15] */
N#define SYS_PB_H_MFP_PB15_MFP_EXT_INT1    (1UL<<SYS_PB_H_MFP_PB15_MFP_Pos)      /*!<PB15 Pin Function - External interrupt 1 */
N#define SYS_PB_H_MFP_PB15_MFP_SNOOPER     (3UL<<SYS_PB_H_MFP_PB15_MFP_Pos)      /*!<PB15 Pin Function - Snooper pin */
N#define SYS_PB_H_MFP_PB15_MFP_SC1_CD      (4UL<<SYS_PB_H_MFP_PB15_MFP_Pos)      /*!<PB15 Pin Function - SmartCard1 card detect */
N#define SYS_PB_H_MFP_PB15_MFP_LCD_S31     (7UL<<SYS_PB_H_MFP_PB15_MFP_Pos)      /*!<PB15 Pin Function - LCD SEG 31 */
N#define SYS_PB_H_MFP_PB15_MFP_LCD_S14     (7UL<<SYS_PB_H_MFP_PB15_MFP_Pos)      /*!<PB15 Pin Function - LCD SEG 14 */
N
N#define SYS_PB_H_MFP_PB14_MFP_GPB14       (0UL<<SYS_PB_H_MFP_PB14_MFP_Pos)      /*!<PB14 Pin Function - GPIOB[14] */
N#define SYS_PB_H_MFP_PB14_MFP_EXT_INT0    (1UL<<SYS_PB_H_MFP_PB14_MFP_Pos)      /*!<PB14 Pin Function - External interrupt 0 */
N#define SYS_PB_H_MFP_PB14_MFP_SC2_CD      (3UL<<SYS_PB_H_MFP_PB14_MFP_Pos)      /*!<PB14 Pin Function - SmartCard 2 card detect */
N#define SYS_PB_H_MFP_PB14_MFP_SPI2_SS1    (4UL<<SYS_PB_H_MFP_PB14_MFP_Pos)      /*!<PB14 Pin Function - SPI2 2nd chip selection */
N#define SYS_PB_H_MFP_PB14_MFP_LCD_S26     (7UL<<SYS_PB_H_MFP_PB14_MFP_Pos)      /*!<PB14 Pin Function - LCD SEG 26 */
N#define SYS_PB_H_MFP_PB14_MFP_LCD_S12     (7UL<<SYS_PB_H_MFP_PB14_MFP_Pos)      /*!<PB14 Pin Function - LCD SEG 12 */
N
N#define SYS_PB_H_MFP_PB13_MFP_GPB13       (0UL<<SYS_PB_H_MFP_PB13_MFP_Pos)      /*!<PB13 Pin Function - GPIOB[13] */
N#define SYS_PB_H_MFP_PB13_MFP_EBI_AD1     (2UL<<SYS_PB_H_MFP_PB13_MFP_Pos)      /*!<PB13 Pin Function - EBI AD[1] */
N#define SYS_PB_H_MFP_PB13_MFP_LCD_S25     (7UL<<SYS_PB_H_MFP_PB13_MFP_Pos)      /*!<PB13 Pin Function - LCD SEG 25 */
N#define SYS_PB_H_MFP_PB13_MFP_LCD_S11     (7UL<<SYS_PB_H_MFP_PB13_MFP_Pos)      /*!<PB13 Pin Function - LCD SEG 11 */
N
N#define SYS_PB_H_MFP_PB12_MFP_GPB12       (0UL<<SYS_PB_H_MFP_PB12_MFP_Pos)      /*!<PB12 Pin Function - GPIOB[12] */
N#define SYS_PB_H_MFP_PB12_MFP_EBI_AD0     (2UL<<SYS_PB_H_MFP_PB12_MFP_Pos)      /*!<PB12 Pin Function - EBI AD[0] */
N#define SYS_PB_H_MFP_PB12_MFP_CKO         (4UL<<SYS_PB_H_MFP_PB12_MFP_Pos)      /*!<PB12 Pin Function - CKO */
N#define SYS_PB_H_MFP_PB12_MFP_LCD_S24     (7UL<<SYS_PB_H_MFP_PB12_MFP_Pos)      /*!<PB12 Pin Function - LCD SEG 24 */
N#define SYS_PB_H_MFP_PB12_MFP_LCD_S10     (7UL<<SYS_PB_H_MFP_PB12_MFP_Pos)      /*!<PB12 Pin Function - LCD SEG 10 */
N
N#define SYS_PB_H_MFP_PB11_MFP_GPB11       (0UL<<SYS_PB_H_MFP_PB11_MFP_Pos)        /*!<PB11 Pin Function - GPIOB[11] */
N#define SYS_PB_H_MFP_PB11_MFP_PWM1_CH0    (1UL<<SYS_PB_H_MFP_PB11_MFP_Pos)        /*!<PB11 Pin Function - PWM1 Channel 0 */
N#define SYS_PB_H_MFP_PB11_MFP_TMR3_EXT    (2UL<<SYS_PB_H_MFP_PB11_MFP_Pos)        /*!<PB11 Pin Function - Timer3 external event input */
N#define SYS_PB_H_MFP_PB11_MFP_TMR3_TOGGLE_OUT (2UL<<SYS_PB_H_MFP_PB11_MFP_Pos)        /*!<PB11 Pin Function - Timer3 toggle output */
N#define SYS_PB_H_MFP_PB11_MFP_SC2_DAT     (4UL<<SYS_PB_H_MFP_PB11_MFP_Pos)        /*!<PB11 Pin Function - SmartCard2 DATA */
N#define SYS_PB_H_MFP_PB11_MFP_SPI0_MISO0  (5UL<<SYS_PB_H_MFP_PB11_MFP_Pos)        /*!<PB11 Pin Function - SPI 0 MISO[0] */
N#define SYS_PB_H_MFP_PB11_MFP_LCD_V1      (7UL<<SYS_PB_H_MFP_PB11_MFP_Pos)        /*!<PB11 Pin Function - LCD V1 */
N
N#define SYS_PB_H_MFP_PB10_MFP_GPB10       (0UL<<SYS_PB_H_MFP_PB10_MFP_Pos)      /*!<PB10 Pin Function - GPIOB[10] */
N#define SYS_PB_H_MFP_PB10_MFP_SPI0_SS1      (1UL<<SYS_PB_H_MFP_PB10_MFP_Pos)      /*!<PB10 Pin Function - SPI0 chip selection 1 */
N#define SYS_PB_H_MFP_PB10_MFP_TMR2_EXT      (2UL<<SYS_PB_H_MFP_PB10_MFP_Pos)      /*!<PB10 Pin Function - Timer2 external event input */
N#define SYS_PB_H_MFP_PB10_MFP_TMR2_TOGGLE_OUT (2UL<<SYS_PB_H_MFP_PB10_MFP_Pos)      /*!<PB10 Pin Function - Timer2 toggle output */
N#define SYS_PB_H_MFP_PB10_MFP_SC2_CLK     (4UL<<SYS_PB_H_MFP_PB10_MFP_Pos)      /*!<PB10 Pin Function - SmartCard2 clock */
N#define SYS_PB_H_MFP_PB10_MFP_SPI0_MOSI0    (5UL<<SYS_PB_H_MFP_PB10_MFP_Pos)      /*!<PB10 Pin Function - SPI0 MOSI[0] */
N#define SYS_PB_H_MFP_PB10_MFP_LCD_V2        (7UL<<SYS_PB_H_MFP_PB10_MFP_Pos)      /*!<PB10 Pin Function - LCD V2 */
N
N#define SYS_PB_H_MFP_PB9_MFP_GPB9         (0UL<<SYS_PB_H_MFP_PB9_MFP_Pos)     /*!<PB9 Pin Function - GPIOB[9] */
N#define SYS_PB_H_MFP_PB9_MFP_SPI1_SS1     (1UL<<SYS_PB_H_MFP_PB9_MFP_Pos)     /*!<PB9 Pin Function - SPI1 chip selection 1 */
N#define SYS_PB_H_MFP_PB9_MFP_TMR1_EXT     (2UL<<SYS_PB_H_MFP_PB9_MFP_Pos)     /*!<PB9 Pin Function - Timer1 external event input */
N#define SYS_PB_H_MFP_PB9_MFP_TMR1_TOGGLE_OUT    (2UL<<SYS_PB_H_MFP_PB9_MFP_Pos)     /*!<PB9 Pin Function - Timer1 toggle output */
N#define SYS_PB_H_MFP_PB9_MFP_SC2_RST      (4UL<<SYS_PB_H_MFP_PB9_MFP_Pos)     /*!<PB9 Pin Function - SmartCard2 RST */
N#define SYS_PB_H_MFP_PB9_MFP_EXT_INT0     (5UL<<SYS_PB_H_MFP_PB9_MFP_Pos)     /*!<PB9 Pin Function - External interrupt 0 */
N#define SYS_PB_H_MFP_PB9_MFP_LCD_V3       (7UL<<SYS_PB_H_MFP_PB9_MFP_Pos)     /*!<PB9 Pin Function - LCD V3 */
N
N#define SYS_PB_H_MFP_PB8_MFP_GPB8         (0UL<<SYS_PB_H_MFP_PB8_MFP_Pos)     /*!<PB8 Pin Function - GPIOB[8] */
N#define SYS_PB_H_MFP_PB8_MFP_ADC_EXT      (1UL<<SYS_PB_H_MFP_PB8_MFP_Pos)     /*!<PB8 Pin Function - ADC external trigger */
N#define SYS_PB_H_MFP_PB8_MFP_TMR0_EXT     (2UL<<SYS_PB_H_MFP_PB8_MFP_Pos)     /*!<PB8 Pin Function - Timer0 external event input */
N#define SYS_PB_H_MFP_PB8_MFP_TMR0_TOGGLE_OUT    (2UL<<SYS_PB_H_MFP_PB8_MFP_Pos)     /*!<PB8 Pin Function - Timer0 toggle output */
N#define SYS_PB_H_MFP_PB8_MFP_EXT_INT0     (3UL<<SYS_PB_H_MFP_PB8_MFP_Pos)     /*!<PB8 Pin Function - External interrupt 0 */
N#define SYS_PB_H_MFP_PB8_MFP_SC2_PWR      (4UL<<SYS_PB_H_MFP_PB8_MFP_Pos)     /*!<PB8 Pin Function - SmartCard 2 power */
N#define SYS_PB_H_MFP_PB8_MFP_LCD_S30      (7UL<<SYS_PB_H_MFP_PB8_MFP_Pos)     /*!<PB8 Pin Function - LCD SEG 30 */
N#define SYS_PB_H_MFP_PB8_MFP_LCD_S13      (7UL<<SYS_PB_H_MFP_PB8_MFP_Pos)     /*!<PB8 Pin Function - LCD SEG 13 */
N
N/********************* Bit definition of PC_L_MFP register **********************/
N#define SYS_PC_L_MFP_PC7_MFP_GPC7         (0UL<<SYS_PC_L_MFP_PC7_MFP_Pos)     /*!<PC7 Pin Function - GPIOC[7] */
N#define SYS_PC_L_MFP_PC7_MFP_DA_OUT1      (1UL<<SYS_PC_L_MFP_PC7_MFP_Pos)     /*!<PC7 Pin Function - DA out1 */
N#define SYS_PC_L_MFP_PC7_MFP_EBI_AD5      (2UL<<SYS_PC_L_MFP_PC7_MFP_Pos)     /*!<PC7 Pin Function - EBI AD[5] */
N#define SYS_PC_L_MFP_PC7_MFP_TMR1_CAP     (3UL<<SYS_PC_L_MFP_PC7_MFP_Pos)     /*!<PC7 Pin Function - Timer1 capture event */
N#define SYS_PC_L_MFP_PC7_MFP_PWM0_CH1     (5UL<<SYS_PC_L_MFP_PC7_MFP_Pos)     /*!<PC7 Pin Function - PWM0 Channel 1 */
N#define SYS_PC_L_MFP_PC7_MFP_LCD_S17      (7UL<<SYS_PC_L_MFP_PC7_MFP_Pos)     /*!<PC7 Pin Function - LCD SEG 17 */
N
N#define SYS_PC_L_MFP_PC6_MFP_GPC6         (0UL<<SYS_PC_L_MFP_PC6_MFP_Pos)     /*!<PC6 Pin Function - GPIOC[6] */
N#define SYS_PC_L_MFP_PC6_MFP_DA_OUT0      (1UL<<SYS_PC_L_MFP_PC6_MFP_Pos)     /*!<PC6 Pin Function - DA out0 */
N#define SYS_PC_L_MFP_PC6_MFP_EBI_AD4      (2UL<<SYS_PC_L_MFP_PC6_MFP_Pos)     /*!<PC6 Pin Function - EBI AD[4] */
N#define SYS_PC_L_MFP_PC6_MFP_TMR0_CAP     (3UL<<SYS_PC_L_MFP_PC6_MFP_Pos)     /*!<PC6 Pin Function - Timer0 Capture event */
N#define SYS_PC_L_MFP_PC6_MFP_SC1_CD       (4UL<<SYS_PC_L_MFP_PC6_MFP_Pos)     /*!<PC6 Pin Function - SmartCard1 card detection */
N#define SYS_PC_L_MFP_PC6_MFP_PWM0_CH0     (5UL<<SYS_PC_L_MFP_PC6_MFP_Pos)     /*!<PC6 Pin Function - PWM0 Channel 0 */
N
N#define SYS_PC_L_MFP_PC5_MFP_GPC5         (0UL<<SYS_PC_L_MFP_PC5_MFP_Pos)     /*!<PC5 Pin Function - GPIOC[5] */
N#define SYS_PC_L_MFP_PC5_MFP_SPI0_MOSI1   (1UL<<SYS_PC_L_MFP_PC5_MFP_Pos)     /*!<PC5 Pin Function - SPI0 MOSI[1] */
N#define SYS_PC_L_MFP_PC5_MFP_LCD_COM3     (7UL<<SYS_PC_L_MFP_PC5_MFP_Pos)     /*!<PC5 Pin Function - LCD COM 3 */
N
N#define SYS_PC_L_MFP_PC4_MFP_GPC4         (0UL<<SYS_PC_L_MFP_PC4_MFP_Pos)     /*!<PC4 Pin Function - GPIOC[4] */
N#define SYS_PC_L_MFP_PC4_MFP_SPI0_MISO1   (1UL<<SYS_PC_L_MFP_PC4_MFP_Pos)     /*!<PC4 Pin Function - SPI0 MISO[1] */
N#define SYS_PC_L_MFP_PC4_MFP_LCD_COM2     (7UL<<SYS_PC_L_MFP_PC4_MFP_Pos)     /*!<PC4 Pin Function - LCD COM 2 */
N
N#define SYS_PC_L_MFP_PC3_MFP_GPC3         (0UL<<SYS_PC_L_MFP_PC3_MFP_Pos)     /*!<PC3 Pin Function - GPIOC[3] */
N#define SYS_PC_L_MFP_PC3_MFP_SPI0_MOSI0   (1UL<<SYS_PC_L_MFP_PC3_MFP_Pos)     /*!<PC3 Pin Function - SPI0 MOSI[0] */
N#define SYS_PC_L_MFP_PC3_MFP_I2S_DOUT     (2UL<<SYS_PC_L_MFP_PC3_MFP_Pos)     /*!<PC3 Pin Function - I2S Dout */
N#define SYS_PC_L_MFP_PC3_MFP_SC1_RST      (4UL<<SYS_PC_L_MFP_PC3_MFP_Pos)     /*!<PC3 Pin Function - SmartCard1 RST */
N#define SYS_PC_L_MFP_PC3_MFP_LCD_COM1     (7UL<<SYS_PC_L_MFP_PC3_MFP_Pos)     /*!<PC3 Pin Function - LCD COM 1 */
N
N#define SYS_PC_L_MFP_PC2_MFP_GPC2         (0UL<<SYS_PC_L_MFP_PC2_MFP_Pos)     /*!<PC2 Pin Function - GPIOC[2] */
N#define SYS_PC_L_MFP_PC2_MFP_SPI0_MISO0   (1UL<<SYS_PC_L_MFP_PC2_MFP_Pos)     /*!<PC2 Pin Function - SPI0 MISO[0] */
N#define SYS_PC_L_MFP_PC2_MFP_I2S_DIN      (2UL<<SYS_PC_L_MFP_PC2_MFP_Pos)     /*!<PC2 Pin Function - I2S Din */
N#define SYS_PC_L_MFP_PC2_MFP_SC1_PWR      (4UL<<SYS_PC_L_MFP_PC2_MFP_Pos)     /*!<PC2 Pin Function - SmartCard1 Power */
N#define SYS_PC_L_MFP_PC2_MFP_LCD_COM0     (7UL<<SYS_PC_L_MFP_PC2_MFP_Pos)     /*!<PC2 Pin Function - LCD COM 0 */
N
N#define SYS_PC_L_MFP_PC1_MFP_GPC1         (0UL<<SYS_PC_L_MFP_PC1_MFP_Pos)     /*!<PC1 Pin Function - GPIOC[1] */
N#define SYS_PC_L_MFP_PC1_MFP_SPI0_SCLK    (1UL<<SYS_PC_L_MFP_PC1_MFP_Pos)     /*!<PC1 Pin Function - SPI0 SCLK */
N#define SYS_PC_L_MFP_PC1_MFP_I2S_BCLK     (2UL<<SYS_PC_L_MFP_PC1_MFP_Pos)     /*!<PC1 Pin Function - I2S BCLK */
N#define SYS_PC_L_MFP_PC1_MFP_SC1_DAT      (4UL<<SYS_PC_L_MFP_PC1_MFP_Pos)     /*!<PC1 Pin Function - SmartCard1 DATA */
N#define SYS_PC_L_MFP_PC1_MFP_LCD_DH2      (7UL<<SYS_PC_L_MFP_PC1_MFP_Pos)     /*!<PC1 Pin Function - LCD DH2 */
N
N#define SYS_PC_L_MFP_PC0_MFP_GPC0         (0UL<<SYS_PC_L_MFP_PC0_MFP_Pos)     /*!<PC0 Pin Function - GPIOC[0] */
N#define SYS_PC_L_MFP_PC0_MFP_SPI0_SS0     (1UL<<SYS_PC_L_MFP_PC0_MFP_Pos)     /*!<PC0 Pin Function - SPI0 chip selection 0 */
N#define SYS_PC_L_MFP_PC0_MFP_I2S_WS       (2UL<<SYS_PC_L_MFP_PC0_MFP_Pos)     /*!<PC0 Pin Function - I2S WS */
N#define SYS_PC_L_MFP_PC0_MFP_SC1_CLK      (4UL<<SYS_PC_L_MFP_PC0_MFP_Pos)     /*!<PC0 Pin Function - SmartCard1 clock */
N#define SYS_PC_L_MFP_PC0_MFP_LCD_DH1      (7UL<<SYS_PC_L_MFP_PC0_MFP_Pos)     /*!<PC0 Pin Function - LCD DH1 */
N
N/********************* Bit definition of PC_H_MFP register **********************/
N#define SYS_PC_H_MFP_PC15_MFP_GPC15       (0UL<<SYS_PC_H_MFP_PC15_MFP_Pos)      /*!<PC15 Pin Function - GPIOC[15] */
N#define SYS_PC_H_MFP_PC15_MFP_EBI_AD3     (2UL<<SYS_PC_H_MFP_PC15_MFP_Pos)      /*!<PC15 Pin Function - EBI AD[3] */
N#define SYS_PC_H_MFP_PC15_MFP_TMR0_CAP    (3UL<<SYS_PC_H_MFP_PC15_MFP_Pos)      /*!<PC15 Pin Function - Timer0 capture event */
N#define SYS_PC_H_MFP_PC15_MFP_PWM1_CH2    (4UL<<SYS_PC_H_MFP_PC15_MFP_Pos)      /*!<PC15 Pin Function - PWM1 Channel 2 */
N#define SYS_PC_H_MFP_PC15_MFP_LCD_S33     (7UL<<SYS_PC_H_MFP_PC15_MFP_Pos)      /*!<PC15 Pin Function - LCD SEG 33 */
N#define SYS_PC_H_MFP_PC15_MFP_LCD_S16     (7UL<<SYS_PC_H_MFP_PC15_MFP_Pos)      /*!<PC15 Pin Function - LCD SEG 16 */
N
N#define SYS_PC_H_MFP_PC14_MFP_GPC14       (0UL<<SYS_PC_H_MFP_PC14_MFP_Pos)      /*!<PC14 Pin Function - GPIOC[14] */
N#define SYS_PC_H_MFP_PC14_MFP_EBI_AD2     (2UL<<SYS_PC_H_MFP_PC14_MFP_Pos)      /*!<PC14 Pin Function - EBI AD[2] */
N#define SYS_PC_H_MFP_PC14_MFP_PWM1_CH3    (4UL<<SYS_PC_H_MFP_PC14_MFP_Pos)      /*!<PC14 Pin Function - PWM1 Channel 3 */
N#define SYS_PC_H_MFP_PC14_MFP_LCD_S32     (7UL<<SYS_PC_H_MFP_PC14_MFP_Pos)      /*!<PC14 Pin Function - LCD SEG 32 */
N#define SYS_PC_H_MFP_PC14_MFP_LCD_S15     (7UL<<SYS_PC_H_MFP_PC14_MFP_Pos)      /*!<PC14 Pin Function - LCD SEG 15 */
N
N#define SYS_PC_H_MFP_PC13_MFP_GPC13       (0UL<<SYS_PC_H_MFP_PC13_MFP_Pos)      /*!<PC13 Pin Function - GPIOC[13] */
N#define SYS_PC_H_MFP_PC13_MFP_SPI1_MOSI1  (1UL<<SYS_PC_H_MFP_PC13_MFP_Pos)      /*!<PC13 Pin Function - SPI1 MOSI[1] */
N#define SYS_PC_H_MFP_PC13_MFP_PWM1_CH1    (2UL<<SYS_PC_H_MFP_PC13_MFP_Pos)      /*!<PC13 Pin Function - PWM1 Channel 1 */
N#define SYS_PC_H_MFP_PC13_MFP_SNOOPER     (4UL<<SYS_PC_H_MFP_PC13_MFP_Pos)      /*!<PC13 Pin Function - Snooper pin */
N#define SYS_PC_H_MFP_PC13_MFP_EXT_INT1    (5UL<<SYS_PC_H_MFP_PC13_MFP_Pos)      /*!<PC13 Pin Function - External interrupt 1 */
N#define SYS_PC_H_MFP_PC13_MFP_I2C0_SCL    (6UL<<SYS_PC_H_MFP_PC13_MFP_Pos)      /*!<PC13 Pin Function - I2C0 clock */
N
N#define SYS_PC_H_MFP_PC12_MFP_GPC12       (0UL<<SYS_PC_H_MFP_PC12_MFP_Pos)      /*!<PC12 Pin Function - GPIOC[12] */
N#define SYS_PC_H_MFP_PC12_MFP_SPI1_MISO1  (1UL<<SYS_PC_H_MFP_PC12_MFP_Pos)      /*!<PC12 Pin Function - SPI1 MISO[1] */
N#define SYS_PC_H_MFP_PC12_MFP_PWM1_CH0    (2UL<<SYS_PC_H_MFP_PC12_MFP_Pos)      /*!<PC12 Pin Function - PWM1 Channel 0 */
N#define SYS_PC_H_MFP_PC12_MFP_EXT_INT0    (5UL<<SYS_PC_H_MFP_PC12_MFP_Pos)      /*!<PC12 Pin Function - External interrupt 0 */
N#define SYS_PC_H_MFP_PC12_MFP_I2C0_SDA    (6UL<<SYS_PC_H_MFP_PC12_MFP_Pos)      /*!<PC12 Pin Function - I2C0 DATA */
N
N#define SYS_PC_H_MFP_PC11_MFP_GPC11       (0UL<<SYS_PC_H_MFP_PC11_MFP_Pos)      /*!<PC11 Pin Function - GPIOC[11] */
N#define SYS_PC_H_MFP_PC11_MFP_SPI1_MOSI0  (1UL<<SYS_PC_H_MFP_PC11_MFP_Pos)      /*!<PC11 Pin Function - SPI1 MOSI[0] */
N#define SYS_PC_H_MFP_PC11_MFP_UART1_TX    (5UL<<SYS_PC_H_MFP_PC11_MFP_Pos)      /*!<PC11 Pin Function - UART1 TX */
N#define SYS_PC_H_MFP_PC11_MFP_LCD_S31     (7UL<<SYS_PC_H_MFP_PC11_MFP_Pos)      /*!<PC11 Pin Function - LCD SEG 31 */
N
N#define SYS_PC_H_MFP_PC10_MFP_GPC10       (0UL<<SYS_PC_H_MFP_PC10_MFP_Pos)      /*!<PC10 Pin Function - GPIOC[10] */
N#define SYS_PC_H_MFP_PC10_MFP_SPI1_MISO0  (1UL<<SYS_PC_H_MFP_PC10_MFP_Pos)      /*!<PC10 Pin Function - SPI1 MISO[0] */
N#define SYS_PC_H_MFP_PC10_MFP_UART1_RX    (5UL<<SYS_PC_H_MFP_PC10_MFP_Pos)      /*!<PC10 Pin Function - UART1 RX */
N#define SYS_PC_H_MFP_PC10_MFP_LCD_S30     (7UL<<SYS_PC_H_MFP_PC10_MFP_Pos)      /*!<PC10 Pin Function - LCD SEG 30 */
N
N#define SYS_PC_H_MFP_PC9_MFP_GPC9         (0UL<<SYS_PC_H_MFP_PC9_MFP_Pos)     /*!<PC9 Pin Function - GPIOC[9] */
N#define SYS_PC_H_MFP_PC9_MFP_SPI1_SCLK    (1UL<<SYS_PC_H_MFP_PC9_MFP_Pos)     /*!<PC9 Pin Function - SPI1 SCLK */
N#define SYS_PC_H_MFP_PC9_MFP_I2C1_SCL     (5UL<<SYS_PC_H_MFP_PC9_MFP_Pos)     /*!<PC9 Pin Function - I2C1 clock */
N#define SYS_PC_H_MFP_PC9_MFP_LCD_S29      (7UL<<SYS_PC_H_MFP_PC9_MFP_Pos)     /*!<PC9 Pin Function - LCD SEG 29 */
N
N#define SYS_PC_H_MFP_PC8_MFP_GPC8         (0UL<<SYS_PC_H_MFP_PC8_MFP_Pos)     /*!<PC8 Pin Function - GPIOC[8] */
N#define SYS_PC_H_MFP_PC8_MFP_SPI1_SS0     (1UL<<SYS_PC_H_MFP_PC8_MFP_Pos)     /*!<PC8 Pin Function - SPI1 SS[0] */
N#define SYS_PC_H_MFP_PC8_MFP_EBI_XCLK     (2UL<<SYS_PC_H_MFP_PC8_MFP_Pos)     /*!<PC8 Pin Function - EBI XCLK */
N#define SYS_PC_H_MFP_PC8_MFP_I2C1_SDA     (5UL<<SYS_PC_H_MFP_PC8_MFP_Pos)     /*!<PC8 Pin Function - I2C1 DATA */
N#define SYS_PC_H_MFP_PC8_MFP_LCD_S28      (7UL<<SYS_PC_H_MFP_PC8_MFP_Pos)     /*!<PC8 Pin Function - LCD SEG 28 */
N
N/********************* Bit definition of PD_L_MFP register **********************/
N#define SYS_PD_L_MFP_PD7_MFP_GPD7         (0UL<<SYS_PD_L_MFP_PD7_MFP_Pos)     /*!<PD7 Pin Function - GPIOD[7] */
N#define SYS_PD_L_MFP_PD7_MFP_LCD_S2       (7UL<<SYS_PD_L_MFP_PD7_MFP_Pos)     /*!<PD7 Pin Function - LCD SEG 2 */
N
N#define SYS_PD_L_MFP_PD6_MFP_GPD6         (0UL<<SYS_PD_L_MFP_PD6_MFP_Pos)     /*!<PD6 Pin Function - GPIOD[6] */
N#define SYS_PD_L_MFP_PD6_MFP_LCD_S3       (7UL<<SYS_PD_L_MFP_PD6_MFP_Pos)     /*!<PD6 Pin Function - LCD SEG 3 */
N
N#define SYS_PD_L_MFP_PD5_MFP_GPD5         (0UL<<SYS_PD_L_MFP_PD5_MFP_Pos)     /*!<PD5 Pin Function - GPIOD[5] */
N#define SYS_PD_L_MFP_PD5_MFP_I2S_DOUT     (2UL<<SYS_PD_L_MFP_PD5_MFP_Pos)     /*!<PD5 Pin Function - I2S Dout */
N#define SYS_PD_L_MFP_PD5_MFP_SPI2_MOSI1   (3UL<<SYS_PD_L_MFP_PD5_MFP_Pos)     /*!<PD5 Pin Function - SPI2 MOSI[1] */
N#define SYS_PD_L_MFP_PD5_MFP_LCD_S34      (7UL<<SYS_PD_L_MFP_PD5_MFP_Pos)     /*!<PD5 Pin Function - LCD SEG 34 */
N
N#define SYS_PD_L_MFP_PD4_MFP_GPD4         (0UL<<SYS_PD_L_MFP_PD4_MFP_Pos)     /*!<PD4 Pin Function - GPIOD[4] */
N#define SYS_PD_L_MFP_PD4_MFP_I2S_DIN      (2UL<<SYS_PD_L_MFP_PD4_MFP_Pos)     /*!<PD4 Pin Function - I2S Din */
N#define SYS_PD_L_MFP_PD4_MFP_SPI2_MISO1   (3UL<<SYS_PD_L_MFP_PD4_MFP_Pos)     /*!<PD4 Pin Function - SPI2 MISO[1] */
N#define SYS_PD_L_MFP_PD4_MFP_SC1_CD       (4UL<<SYS_PD_L_MFP_PD4_MFP_Pos)     /*!<PD4 Pin Function - SmartCard1 card detection */
N#define SYS_PD_L_MFP_PD4_MFP_LCD_S35      (7UL<<SYS_PD_L_MFP_PD4_MFP_Pos)     /*!<PD4 Pin Function - LCD SEG 35 */
N
N#define SYS_PD_L_MFP_PD3_MFP_GPD3         (0UL<<SYS_PD_L_MFP_PD3_MFP_Pos)     /*!<PD3 Pin Function - GPIOD[3] */
N#define SYS_PD_L_MFP_PD3_MFP_UART1_CTS    (1UL<<SYS_PD_L_MFP_PD3_MFP_Pos)     /*!<PD3 Pin Function - UART1 CTSn */
N#define SYS_PD_L_MFP_PD3_MFP_I2S_BCLK     (2UL<<SYS_PD_L_MFP_PD3_MFP_Pos)     /*!<PD3 Pin Function - I2S BCLK */
N#define SYS_PD_L_MFP_PD3_MFP_SPI2_MOSI0   (3UL<<SYS_PD_L_MFP_PD3_MFP_Pos)     /*!<PD3 Pin Function - SPI2 MOSI[0] */
N#define SYS_PD_L_MFP_PD3_MFP_SC1_RST      (4UL<<SYS_PD_L_MFP_PD3_MFP_Pos)     /*!<PD3 Pin Function - SmartCard1 reset */
N#define SYS_PD_L_MFP_PD3_MFP_ADC_CH11     (5UL<<SYS_PD_L_MFP_PD3_MFP_Pos)     /*!<PD3 Pin Function - ADC input channel 11 */
N
N#define SYS_PD_L_MFP_PD2_MFP_GPD2         (0UL<<SYS_PD_L_MFP_PD2_MFP_Pos)     /*!<PD2 Pin Function - GPIOD[2] */
N#define SYS_PD_L_MFP_PD2_MFP_UART1_RTS    (1UL<<SYS_PD_L_MFP_PD2_MFP_Pos)     /*!<PD2 Pin Function - UART1 RTSn */
N#define SYS_PD_L_MFP_PD2_MFP_I2S_WS       (2UL<<SYS_PD_L_MFP_PD2_MFP_Pos)     /*!<PD2 Pin Function - I2S WS */
N#define SYS_PD_L_MFP_PD2_MFP_SPI2_MISO0   (3UL<<SYS_PD_L_MFP_PD2_MFP_Pos)     /*!<PD2 Pin Function - SPI2 MISO[0] */
N#define SYS_PD_L_MFP_PD2_MFP_SC1_PWR      (4UL<<SYS_PD_L_MFP_PD2_MFP_Pos)     /*!<PD2 Pin Function - SmartCard1 power */
N#define SYS_PD_L_MFP_PD2_MFP_ADC_CH10     (5UL<<SYS_PD_L_MFP_PD2_MFP_Pos)     /*!<PD2 Pin Function - ADC input channel 10 */
N
N#define SYS_PD_L_MFP_PD1_MFP_GPD1         (0UL<<SYS_PD_L_MFP_PD1_MFP_Pos)     /*!<PD1 Pin Function - GPIOD[1] */
N#define SYS_PD_L_MFP_PD1_MFP_UART1_TX     (1UL<<SYS_PD_L_MFP_PD1_MFP_Pos)     /*!<PD1 Pin Function - UART1 TX */
N#define SYS_PD_L_MFP_PD1_MFP_SPI2_SCLK    (3UL<<SYS_PD_L_MFP_PD1_MFP_Pos)     /*!<PD1 Pin Function - SPI2 SCLK */
N#define SYS_PD_L_MFP_PD1_MFP_SC1_DAT      (4UL<<SYS_PD_L_MFP_PD1_MFP_Pos)     /*!<PD1 Pin Function - SmartCard1 DATA */
N#define SYS_PD_L_MFP_PD1_MFP_ADC_CH9      (5UL<<SYS_PD_L_MFP_PD1_MFP_Pos)     /*!<PD1 Pin Function - ADC input channel 9 */
N
N#define SYS_PD_L_MFP_PD0_MFP_GPD0         (0UL<<SYS_PD_L_MFP_PD0_MFP_Pos)     /*!<PD0 Pin Function - GPIOD[0] */
N#define SYS_PD_L_MFP_PD0_MFP_UART1_RX     (1UL<<SYS_PD_L_MFP_PD0_MFP_Pos)     /*!<PD0 Pin Function - UART1 RX */
N#define SYS_PD_L_MFP_PD0_MFP_SPI2_SS0     (3UL<<SYS_PD_L_MFP_PD0_MFP_Pos)     /*!<PD0 Pin Function - SPI2 chip selection 0 */
N#define SYS_PD_L_MFP_PD0_MFP_SC1_CLK      (4UL<<SYS_PD_L_MFP_PD0_MFP_Pos)     /*!<PD0 Pin Function - SmartCard1 clock */
N#define SYS_PD_L_MFP_PD0_MFP_ADC_CH8      (5UL<<SYS_PD_L_MFP_PD0_MFP_Pos)     /*!<PD0 Pin Function - ADC input channel 8 */
N
N/********************* Bit definition of PD_H_MFP register **********************/
N#define SYS_PD_H_MFP_PD15_MFP_GPD15       (0UL<<SYS_PD_H_MFP_PD15_MFP_Pos)      /*!<PD15 Pin Function - GPIOD[15] */
N#define SYS_PD_H_MFP_PD15_MFP_LCD_S0      (7UL<<SYS_PD_H_MFP_PD15_MFP_Pos)      /*!<PD15 Pin Function - LCD SEG 0 */
N
N#define SYS_PD_H_MFP_PD14_MFP_GPD14       (0UL<<SYS_PD_H_MFP_PD14_MFP_Pos)      /*!<PD14 Pin Function - GPIOD[14] */
N#define SYS_PD_H_MFP_PD14_MFP_LCD_S1      (7UL<<SYS_PD_H_MFP_PD14_MFP_Pos)      /*!<PD14 Pin Function - LCD SEG 1 */
N
N#define SYS_PD_H_MFP_PD13_MFP_GPD13       (0UL<<SYS_PD_H_MFP_PD13_MFP_Pos)      /*!<PD13 Pin Function - GPIOD[13] */
N#define SYS_PD_H_MFP_PD13_MFP_LCD_S14     (7UL<<SYS_PD_H_MFP_PD13_MFP_Pos)      /*!<PD13 Pin Function - LCD SEG 14 */
N
N#define SYS_PD_H_MFP_PD12_MFP_GPD12       (0UL<<SYS_PD_H_MFP_PD12_MFP_Pos)      /*!<PD12 Pin Function - GPIOD[12] */
N#define SYS_PD_H_MFP_PD12_MFP_LCD_S15     (7UL<<SYS_PD_H_MFP_PD12_MFP_Pos)      /*!<PD12 Pin Function - LCD SEG 15 */
N
N#define SYS_PD_H_MFP_PD11_MFP_GPD11       (0UL<<SYS_PD_H_MFP_PD11_MFP_Pos)      /*!<PD11 Pin Function - GPIOD[11] */
N#define SYS_PD_H_MFP_PD11_MFP_LCD_S16     (7uL<<SYS_PD_H_MFP_PD11_MFP_Pos)      /*!<PD11 Pin Function - LCD SEG 16 */
N
N#define SYS_PD_H_MFP_PD10_MFP_GPD10       (0UL<<SYS_PD_H_MFP_PD10_MFP_Pos)      /*!<PD10 Pin Function - GPIOD[10] */
N#define SYS_PD_H_MFP_PD10_MFP_LCD_S17     (7UL<<SYS_PD_H_MFP_PD10_MFP_Pos)      /*!<PD10 Pin Function - LCD SEG 17 */
N
N#define SYS_PD_H_MFP_PD9_MFP_GPD9         (0UL<<SYS_PD_H_MFP_PD9_MFP_Pos)     /*!<PD9 Pin Function - GPIOD[9] */
N#define SYS_PD_H_MFP_PD9_MFP_LCD_S18      (7UL<<SYS_PD_H_MFP_PD9_MFP_Pos)     /*!<PD9 Pin Function - LCD SEG 18 */
N
N#define SYS_PD_H_MFP_PD8_MFP_GPD8         (0UL<<SYS_PD_H_MFP_PD8_MFP_Pos)     /*!<PD8 Pin Function - GPIOD[8] */
N#define SYS_PD_H_MFP_PD8_MFP_LCD_S19      (7UL<<SYS_PD_H_MFP_PD8_MFP_Pos)     /*!<PD8 Pin Function - LCD SEG 19 */
N
N/********************* Bit definition of PE_L_MFP register **********************/
N#define SYS_PE_L_MFP_PE7_MFP_GPE7         (0UL<<SYS_PE_L_MFP_PE7_MFP_Pos)     /*!<PE7 Pin Function - GPIOE[7] */
N#define SYS_PE_L_MFP_PE7_MFP_LCD_S8       (7UL<<SYS_PE_L_MFP_PE7_MFP_Pos)     /*!<PE7 Pin Function - LCD SEG 8 */
N
N#define SYS_PE_L_MFP_PE6_MFP_GPE6         (0UL<<SYS_PE_L_MFP_PE6_MFP_Pos)     /*!<PE6 Pin Function - GPIOE[6] */
N
N#define SYS_PE_L_MFP_PE5_MFP_GPE5         (0UL<<SYS_PE_L_MFP_PE5_MFP_Pos)     /*!<PE5 Pin Function - GPIOE[5] */
N#define SYS_PE_L_MFP_PE5_MFP_PWM1_CH1     (1UL<<SYS_PE_L_MFP_PE5_MFP_Pos)     /*!<PE5 Pin Function - PWM1 Channel 1 */
N
N#define SYS_PE_L_MFP_PE4_MFP_GPE4         (0UL<<SYS_PE_L_MFP_PE4_MFP_Pos)     /*!<PE4 Pin Function - GPIOE[4] */
N#define SYS_PE_L_MFP_PE4_MFP_SPI0_MOSI0   (6UL<<SYS_PE_L_MFP_PE4_MFP_Pos)     /*!<PE4 Pin Function - SPI0 MOSI[0] */
N
N#define SYS_PE_L_MFP_PE3_MFP_GPE3         (0UL<<SYS_PE_L_MFP_PE3_MFP_Pos)     /*!<PE3 Pin Function - GPIOE[3] */
N#define SYS_PE_L_MFP_PE3_MFP_SPI0_MISO0   (6UL<<SYS_PE_L_MFP_PE3_MFP_Pos)     /*!<PE3 Pin Function - SPI0 MISO[0] */
N
N#define SYS_PE_L_MFP_PE2_MFP_GPE2         (0UL<<SYS_PE_L_MFP_PE2_MFP_Pos)     /*!<PE2 Pin Function - GPIOE[2] */
N#define SYS_PE_L_MFP_PE2_MFP_SPI0_SCLK    (6UL<<SYS_PE_L_MFP_PE2_MFP_Pos)     /*!<PE2 Pin Function - SPI0 SCLK */
N
N#define SYS_PE_L_MFP_PE1_MFP_GPE1         (0UL<<SYS_PE_L_MFP_PE1_MFP_Pos)     /*!<PE1 Pin Function - GPIOE[1] */
N#define SYS_PE_L_MFP_PE1_MFP_PWM1_CH3     (1UL<<SYS_PE_L_MFP_PE1_MFP_Pos)     /*!<PE1 Pin Function - PWM1 Channel 3 */
N#define SYS_PE_L_MFP_PE1_MFP_SPI0_SS0     (6UL<<SYS_PE_L_MFP_PE1_MFP_Pos)     /*!<PE1 Pin Function - SPI0 chip selection 0 */
N
N#define SYS_PE_L_MFP_PE0_MFP_GPE0         (0UL<<SYS_PE_L_MFP_PE0_MFP_Pos)     /*!<PE0 Pin Function - GPIOE[0] */
N#define SYS_PE_L_MFP_PE0_MFP_PWM1_CH2     (1UL<<SYS_PE_L_MFP_PE0_MFP_Pos)     /*!<PE0 Pin Function - PWM1 Channel 2 */
N#define SYS_PE_L_MFP_PE0_MFP_I2S_MCLK     (2UL<<SYS_PE_L_MFP_PE0_MFP_Pos)     /*!<PE0 Pin Function - I2S MCLK */
N
N/********************* Bit definition of PE_H_MFP register **********************/
N#define SYS_PE_H_MFP_PE15_MFP_GPE15       (0UL<<SYS_PE_H_MFP_PE15_MFP_Pos)      /*!<PE15 Pin Function - GPIOE[15] */
N#define SYS_PE_H_MFP_PE15_MFP_LCD_S29     (7UL<<SYS_PE_H_MFP_PE15_MFP_Pos)      /*!<PE15 Pin Function - LCD SEG 29 */
N
N#define SYS_PE_H_MFP_PE14_MFP_GPE14       (0UL<<SYS_PE_H_MFP_PE14_MFP_Pos)      /*!<PE14 Pin Function - GPIOE[14] */
N#define SYS_PE_H_MFP_PE14_MFP_LCD_S28     (7UL<<SYS_PE_H_MFP_PE14_MFP_Pos)      /*!<PE14 Pin Function - LCD SEG 28 */
N
N#define SYS_PE_H_MFP_PE13_MFP_GPE13       (0UL<<SYS_PE_H_MFP_PE13_MFP_Pos)      /*!<PE13 Pin Function - GPIOE[13] */
N#define SYS_PE_H_MFP_PE13_MFP_LCD_S27     (7UL<<SYS_PE_H_MFP_PE13_MFP_Pos)      /*!<PE13 Pin Function - LCD SEG 27 */
N
N#define SYS_PE_H_MFP_PE12_MFP_GPE12       (0UL<<SYS_PE_H_MFP_PE12_MFP_Pos)      /*!<PE12 Pin Function - GPIOE[12] */
N#define SYS_PE_H_MFP_PE12_MFP_UART1_CTS   (7UL<<SYS_PE_H_MFP_PE12_MFP_Pos)      /*!<PE12 Pin Function - UART1 CTSn */
N
N#define SYS_PE_H_MFP_PE11_MFP_GPE11       (0UL<<SYS_PE_H_MFP_PE11_MFP_Pos)      /*!<PE11 Pin Function - GPIOE[11] */
N#define SYS_PE_H_MFP_PE11_MFP_UART1_RTS   (7UL<<SYS_PE_H_MFP_PE11_MFP_Pos)      /*!<PE11 Pin Function - UART1 RTSn */
N
N#define SYS_PE_H_MFP_PE10_MFP_GPE10       (0UL<<SYS_PE_H_MFP_PE10_MFP_Pos)      /*!<PE10 Pin Function - GPIOE[10] */
N#define SYS_PE_H_MFP_PE10_MFP_UART1_TX    (7UL<<SYS_PE_H_MFP_PE10_MFP_Pos)        /*!<PE10 Pin Function - UART1 TX */
N
N#define SYS_PE_H_MFP_PE9_MFP_GPE9         (0UL<<SYS_PE_H_MFP_PE9_MFP_Pos)     /*!<PE9 Pin Function - GPIOE[9] */
N#define SYS_PE_H_MFP_PE9_MFP_UART1_RX     (7UL<<SYS_PE_H_MFP_PE9_MFP_Pos)     /*!<PE9 Pin Function - UART1 RX */
N
N#define SYS_PE_H_MFP_PE8_MFP_GPE8         (0UL<<SYS_PE_H_MFP_PE8_MFP_Pos)     /*!<PE8 Pin Function - GPIOA[8] */
N#define SYS_PE_H_MFP_PE8_MFP_LCD_S9       (7UL<<SYS_PE_H_MFP_PE8_MFP_Pos)     /*!<PE8 Pin Function - LCD SEG 9 */
N
N/********************* Bit definition of PF_L_MFP register **********************/
N#define SYS_PF_L_MFP_PF5_MFP_GPF5         (0UL<<SYS_PF_L_MFP_PF5_MFP_Pos)     /*!<PF5 Pin Function - GPIOF[5] */
N#define SYS_PF_L_MFP_PF5_MFP_I2C0_SCL     (1UL<<SYS_PF_L_MFP_PF5_MFP_Pos)     /*!<PF5 Pin Function - I2C0 clock */
N
N#define SYS_PF_L_MFP_PF4_MFP_GPF4         (0UL<<SYS_PF_L_MFP_PF4_MFP_Pos)     /*!<PF4 Pin Function - GPIOF[4] */
N#define SYS_PF_L_MFP_PF4_MFP_I2C0_SDA     (1UL<<SYS_PF_L_MFP_PF4_MFP_Pos)     /*!<PF4 Pin Function - I2C0 DATA */
N
N#define SYS_PF_L_MFP_PF3_MFP_GPF3         (0UL<<SYS_PF_L_MFP_PF3_MFP_Pos)     /*!<PF3 Pin Function - GPIOF[3] */
N#define SYS_PF_L_MFP_PF3_MFP_HXT_IN       (7UL<<SYS_PF_L_MFP_PF3_MFP_Pos)   /*!<PF3 Pin Function - HXT IN */
N
N#define SYS_PF_L_MFP_PF2_MFP_GPF2         (0UL<<SYS_PF_L_MFP_PF2_MFP_Pos)     /*!<PF2 Pin Function - GPIOF[2] */
N#define SYS_PF_L_MFP_PF2_MFP_HXT_OUT      (7UL<<SYS_PF_L_MFP_PF2_MFP_Pos)     /*!<PF2 Pin Function - HXT OUT */
N
N#define SYS_PF_L_MFP_PF1_MFP_GPF1         (0UL<<SYS_PF_L_MFP_PF1_MFP_Pos)     /*!<PF1 Pin Function - GPIOF[1] */
N#define SYS_PF_L_MFP_PF1_MFP_CKO          (4UL<<SYS_PF_L_MFP_PF1_MFP_Pos)     /*!<PF1 Pin Function - CKO */
N#define SYS_PF_L_MFP_PF1_MFP_EXT_INT1     (5UL<<SYS_PF_L_MFP_PF1_MFP_Pos)     /*!<PF1 Pin Function - External interrupt 1 */
N#define SYS_PF_L_MFP_PF1_MFP_ICE_CLK      (7UL<<SYS_PF_L_MFP_PF1_MFP_Pos)     /*!<PF1 Pin Function - ICE CLOCK */
N
N#define SYS_PF_L_MFP_PF0_MFP_GPF0         (0UL<<SYS_PF_L_MFP_PF0_MFP_Pos)     /*!<PF0 Pin Function - GPIOF[0] */
N#define SYS_PF_L_MFP_PF0_MFP_EXT_INT0     (5UL<<SYS_PF_L_MFP_PF0_MFP_Pos)     /*!<PF0 Pin Function - External interrupt 0 */
N#define SYS_PF_L_MFP_PF0_MFP_ICE_DAT      (7UL<<SYS_PF_L_MFP_PF0_MFP_Pos)     /*!<PF0 Pin Function - ICE DATA */
N
N/*@}*/ /* end of group NANO100_SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup NANO100_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear Brown-out detector interrupt flag
N  * @param      None
N  * @return     None
N  * @details    This macro clear Brown-out detector interrupt flag.
N  */
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODSTS |= SYS_BODSTS_BOD_INT_Msk)
N
N/**
N  * @brief      Disable Brown-out 2.5V detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out 2.5V detector function.
N  */
N#define SYS_DISABLE_BOD25()             (SYS->BODCTL &= ~SYS_BODCTL_BOD25_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out 2.5V detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out 2.5V detector function.
N  */
N#define SYS_ENABLE_BOD25()              (SYS->BODCTL |= SYS_BODCTL_BOD25_EN_Msk)
N
N/**
N  * @brief      Disable Brown-out 2.0V detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out 2.0V detector function.
N  */
N#define SYS_DISABLE_BOD20()             (SYS->BODCTL &= ~SYS_BODCTL_BOD20_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out 2.0V detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out 2.0V detector function.
N  */
N#define SYS_ENABLE_BOD20()              (SYS->BODCTL |= SYS_BODCTL_BOD20_EN_Msk)
N
N/**
N  * @brief      Disable Brown-out 1.7V detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out 1.7V detector function.
N  */
N#define SYS_DISABLE_BOD17()             (SYS->BODCTL &= ~SYS_BODCTL_BOD17_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out 1.7V detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out 1.7V detector function.
N  */
N#define SYS_ENABLE_BOD17()              (SYS->BODCTL |= SYS_BODCTL_BOD17_EN_Msk)
N
N/**
N  * @brief      Get Brown-out detector interrupt flag
N  * @param      None
N  * @retval     0   Brown-out detect interrupt flag is not set.
N  * @retval     >=1 Brown-out detect interrupt flag is set.
N  * @details    This macro get Brown-out detector interrupt flag.
N  */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODSTS & SYS_BODSTS_BOD_INT_Msk)
N
N/**
N  * @brief      Get Brown-out 2.5V detector status
N  * @param      None
N  * @retval     0   System voltage is higher than 2.5V setting or BOD_EN is 0.
N  * @retval     >=1 System voltage is lower than 2.5V setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD_EN is 0, this function always return 0.
N  */
N#define SYS_GET_BOD25_OUTPUT()          (SYS->BODSTS & SYS_BODSTS_BOD25_drop_Msk)
N
N/**
N  * @brief      Get Brown-out 2.0V detector status
N  * @param      None
N  * @retval     0   System voltage is higher than 2.0V setting or BOD_EN is 0.
N  * @retval     >=1 System voltage is lower than 2.0V setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD_EN is 0, this function always return 0.
N  */
N#define SYS_GET_BOD20_OUTPUT()          (SYS->BODSTS & SYS_BODSTS_BOD20_drop_Msk)
N
N/**
N  * @brief      Get Brown-out 1.7V detector status
N  * @param      None
N  * @retval     0   System voltage is higher than 1.7V setting or BOD_EN is 0.
N  * @retval     >=1 System voltage is lower than 1.7V setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD_EN is 0, this function always return 0.
N  */
N#define SYS_GET_BOD17_OUTPUT()          (SYS->BODSTS & SYS_BODSTS_BOD17_drop_Msk)
N
N/**
N  * @brief      Disable Brown-out 2.5V detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  */
N#define SYS_DISABLE_BOD25_RST()         (SYS->BODCTL &= ~SYS_BODCTL_BOD25_RST_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out 2.5V detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  */
N#define SYS_ENABLE_BOD25_RST()          (SYS->BODCTL |= SYS_BODCTL_BOD25_RST_EN_Msk)
N
N/**
N  * @brief      Disable Brown-out 2.0V detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  */
N#define SYS_DISABLE_BOD20_RST()         (SYS->BODCTL &= ~SYS_BODCTL_BOD20_RST_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out 2.0V detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  */
N#define SYS_ENABLE_BOD20_RST()          (SYS->BODCTL |= SYS_BODCTL_BOD20_RST_EN_Msk)
N
N/**
N  * @brief      Disable Brown-out 1.7V detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  */
N#define SYS_DISABLE_BOD17_RST()         (SYS->BODCTL &= ~SYS_BODCTL_BOD17_RST_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out 1.7V detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  */
N#define SYS_ENABLE_BOD17_RST()          (SYS->BODCTL |= SYS_BODCTL_BOD17_RST_EN_Msk)
N
N/**
N  * @brief      Get reset source is from Brown-out detector reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Brown-out detector reset
N  * @retval     >=1 Previous reset source is from Brown-out detector reset
N  * @details    This macro get previous reset source is from Brown-out detect reset or not.
N  */
N#define SYS_IS_BOD_RST()                (SYS->RST_SRC & SYS_RST_SRC_RSTS_BOD_Msk)
N
N
N/**
N  * @brief      Get reset source is from CPU reset
N  * @param      None
N  * @retval     0   Previous reset source is not from CPU reset
N  * @retval     >=1 Previous reset source is from CPU reset
N  * @details    This macro get previous reset source is from CPU reset.
N  */
N#define SYS_IS_CPU_RST()                (SYS->RST_SRC & SYS_RST_SRC_RSTS_CPU_Msk)
N
N/**
N  * @brief      Get reset source is from Power-on Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Power-on Reset
N  * @retval     >=1 Previous reset source is from Power-on Reset
N  * @details    This macro get previous reset source is from Power-on Reset.
N  */
N#define SYS_IS_POR_RST()                (SYS->RST_SRC & SYS_RST_SRC_RSTS_POR_Msk)
N
N/**
N  * @brief      Get reset source is from reset pin reset
N  * @param      None
N  * @retval     0   Previous reset source is not from reset pin reset
N  * @retval     >=1 Previous reset source is from reset pin reset
N  * @details    This macro get previous reset source is from reset pin reset.
N  */
N#define SYS_IS_RSTPIN_RST()             (SYS->RST_SRC & SYS_RST_SRC_RSTS_PAD_Msk)
N
N
N/**
N  * @brief      Get reset source is from system reset
N  * @param      None
N  * @retval     0   Previous reset source is not from system reset
N  * @retval     >=1 Previous reset source is from system reset
N  * @details    This macro get previous reset source is from system reset.
N  */
N#define SYS_IS_SYSTEM_RST()             (SYS->RST_SRC & SYS_RST_SRC_RSTS_SYS_Msk)
N
N
N/**
N  * @brief      Get reset source is from window watch dog reset
N  * @param      None
N  * @retval     0   Previous reset source is not from window watch dog reset
N  * @retval     >=1 Previous reset source is from window watch dog reset
N  * @details    This macro get previous reset source is from window watch dog reset.
N  */
N#define SYS_IS_WDT_RST()                (SYS->RST_SRC & SYS_RST_SRC_RSTS_WDT_Msk)
N
N/**
N  * @brief      Disable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Power-on Reset function.
N  */
N#define SYS_DISABLE_POR()               (SYS->PORCTL = 0x5AA5)
N
N/**
N  * @brief      Enable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Power-on Reset function.
N  */
N#define SYS_ENABLE_POR()                (SYS->PORCTL = 0)
N
N
N/**
N  * @brief      Clear reset source flag
N  * @param[in]  u32RstSrc is reset source. Including:
N  *             - \ref SYS_RST_SRC_RSTS_POR_Msk
N  *             - \ref SYS_RST_SRC_RSTS_PAD_Msk
N  *             - \ref SYS_RST_SRC_RSTS_WDT_Msk
N  *             - \ref SYS_RST_SRC_RSTS_BOD_Msk
N  *             - \ref SYS_RST_SRC_RSTS_SYS_Msk
N  *             - \ref SYS_RST_SRC_RSTS_CPU_Msk
N  * @return     None
N  * @details    This macro clear reset source flag.
N  */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) (SYS->RST_SRC = u32RstSrc )
N
N/**
N  * @brief      Get HIRC trim status
N  * @param      None
N  * @retval     BIT0 HIRC Frequency Lock
N  * @retval     BIT1 Trim Failure Interrupt
N  * @retval     BIT2 LXT Clock error
N  * @details    This macro get HIRC trim interrupt status register.
N  */
N#define SYS_GET_IRCTRIM_INT_FLAG()          (SYS->IRCTRIMINT)
N
N/**
N  * @brief      Clear HIRC trim flag
N  * @param[in]  u32IRCTrimFlg is HIRC trim flags. Including:
N  *             - \ref SYS_IRCTRIMINT_FAIL_INT
N  *             - \ref SYS_IRCTRIMINT_32KERR_INT
N  * @return     None
N  * @details    This macro clear HIRC trim flag.
N  */
N#define SYS_CLEAR_IRCTRIM_INT_FLAG(u32IRCTrimFlg)          (SYS->IRCTRIMINT = u32IRCTrimFlg )
N
N
N/**
N  * @brief      Disable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function disable register write-protection function.
N  *             To unlock the protected register to allow write access.
N  */
N__STATIC_INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{
N    while(SYS->RegLockAddr != SYS_RegLockAddr_RegUnLock_Msk)
X    while(((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->RegLockAddr != (0x1ul << (0)))
N    {
N        SYS->RegLockAddr = 0x59;
X        ((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->RegLockAddr = 0x59;
N        SYS->RegLockAddr = 0x16;
X        ((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->RegLockAddr = 0x16;
N        SYS->RegLockAddr = 0x88;
X        ((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->RegLockAddr = 0x88;
N    }
N}
N
N/**
N  * @brief      Enable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function is used to enable register write-protection function.
N  *             To lock the protected register to forbid write access.
N  */
N__STATIC_INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{
N    SYS->RegLockAddr = 0;
X    ((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->RegLockAddr = 0;
N}
N
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nuint32_t  SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);
Nvoid SYS_EnableIRCTrim(uint32_t u32TrimSel,uint32_t u32TrimEnInt);
Nvoid SYS_DisableIRCTrim(void);
N/*@}*/ /* end of group NANO100_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_SYS_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
N
L 11927 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "clk.h"
L 1 "..\..\..\..\Library\StdDriver\inc\clk.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V1.00
N * $Revision: 20 $
N * $Date: 15/07/08 10:00a $
N * @brief    Nano100 series CLK driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __CLK_H__
N#define __CLK_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_CLK_Driver CLK Driver
N  @{
N*/
N
N/** @addtogroup NANO100_CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N
N#define FREQ_128MHZ       128000000
N#define FREQ_120MHZ       120000000
N#define FREQ_48MHZ         48000000
N#define FREQ_42MHZ         42000000
N#define FREQ_32MHZ         32000000
N#define FREQ_24MHZ         24000000
N#define FREQ_12MHZ         12000000
N
N/********************* Bit definition of PWRCTL register **********************/
N#define CLK_PWRCTL_HXT_EN         (0x1UL<<CLK_PWRCTL_HXT_EN_Pos)      /*!<Enable high speed crystal */
N#define CLK_PWRCTL_LXT_EN         (0x1UL<<CLK_PWRCTL_LXT_EN_Pos)      /*!<Enable low speed crystal */
N#define CLK_PWRCTL_HIRC_EN        (0x1UL<<CLK_PWRCTL_HIRC_EN_Pos)     /*!<Enable internal high speed oscillator */
N#define CLK_PWRCTL_LIRC_EN        (0x1UL<<CLK_PWRCTL_LIRC_EN_Pos)     /*!<Enable internal low speed oscillator */
N#define CLK_PWRCTL_DELY_EN        (0x1UL<<CLK_PWRCTL_WK_DLY_Pos)      /*!<Enable the wake-up delay counter */
N#define CLK_PWRCTL_WAKEINT_EN     (0x1UL<<CLK_PWRCTL_PD_WK_IE_Pos)    /*!<Enable the wake-up interrupt */
N#define CLK_PWRCTL_PWRDOWN_EN     (0x1UL<<CLK_PWRCTL_PD_EN_Pos)       /*!<Power down enable bit */
N#define CLK_PWRCTL_HXT_SELXT      (0x1UL<<CLK_PWRCTL_HXT_SELXT_Pos)   /*!<High frequency crystal loop back path Enabled */
N#define CLK_PWRCTL_HXT_GAIN       (0x1UL<<CLK_PWRCTL_HXT_GAIN_Pos)    /*!<High frequency crystal Gain control Enabled */
N#define CLK_PWRCTL_LXT_SCNT       (0x1UL<<CLK_PWRCTL_LXT_SCNT_Pos)    /*!<Delay 8192 LXT before LXT output */
N
N
N/********************* Bit definition of AHBCLK register **********************/
N#define CLK_AHBCLK_GPIO_EN        (0x1UL<<CLK_AHBCLK_GPIO_EN_Pos)      /*!<GPIO clock enable */
N#define CLK_AHBCLK_DMA_EN         (0x1UL<<CLK_AHBCLK_DMA_EN_Pos)       /*!<DMA clock enable */
N#define CLK_AHBCLK_ISP_EN         (0x1UL<<CLK_AHBCLK_ISP_EN_Pos)       /*!<Flash ISP controller clock enable */
N#define CLK_AHBCLK_EBI_EN         (0x1UL<<CLK_AHBCLK_EBI_EN_Pos)       /*!<EBI clock enable */
N#define CLK_AHBCLK_SRAM_EN        (0x1UL<<CLK_AHBCLK_SRAM_EN_Pos)      /*!<SRAM Controller Clock Enable */
N#define CLK_AHBCLK_TICK_EN        (0x1UL<<CLK_AHBCLK_TICK_EN_Pos)      /*!<System Tick Clock Enable */
N
N/********************* Bit definition of APBCLK register **********************/
N#define CLK_APBCLK_WDT_EN         (0x1UL<<CLK_APBCLK_WDT_EN_Pos)       /*!<Watchdog clock enable */
N#define CLK_APBCLK_RTC_EN         (0x1UL<<CLK_APBCLK_RTC_EN_Pos)       /*!<RTC clock enable */
N#define CLK_APBCLK_TMR0_EN        (0x1UL<<CLK_APBCLK_TMR0_EN_Pos)      /*!<Timer 0 clock enable */
N#define CLK_APBCLK_TMR1_EN        (0x1UL<<CLK_APBCLK_TMR1_EN_Pos)      /*!<Timer 1 clock enable */
N#define CLK_APBCLK_TMR2_EN        (0x1UL<<CLK_APBCLK_TMR2_EN_Pos)      /*!<Timer 2 clock enable */
N#define CLK_APBCLK_TMR3_EN        (0x1UL<<CLK_APBCLK_TMR3_EN_Pos)      /*!<Timer 3 clock enable */
N#define CLK_APBCLK_FDIV_EN        (0x1UL<<CLK_APBCLK_FDIV_EN_Pos)      /*!<Frequency Divider Output clock enable */
N#define CLK_APBCLK_SC2_EN         (0x1UL<<CLK_APBCLK_SC2_EN_Pos)       /*!<SmartCard 2 Clock Enable Control */
N#define CLK_APBCLK_I2C0_EN        (0x1UL<<CLK_APBCLK_I2C0_EN_Pos)      /*!<I2C 0 clock enable */
N#define CLK_APBCLK_I2C1_EN        (0x1UL<<CLK_APBCLK_I2C1_EN_Pos)      /*!<I2C 1 clock enable */
N#define CLK_APBCLK_SPI0_EN        (0x1UL<<CLK_APBCLK_SPI0_EN_Pos)      /*!<SPI 0 clock enable */
N#define CLK_APBCLK_SPI1_EN        (0x1UL<<CLK_APBCLK_SPI1_EN_Pos)      /*!<SPI 1 clock enable */
N#define CLK_APBCLK_SPI2_EN        (0x1UL<<CLK_APBCLK_SPI2_EN_Pos)      /*!<SPI 2 clock enable */
N#define CLK_APBCLK_UART0_EN       (0x1UL<<CLK_APBCLK_UART0_EN_Pos)     /*!<UART 0 clock enable */
N#define CLK_APBCLK_UART1_EN       (0x1UL<<CLK_APBCLK_UART1_EN_Pos)     /*!<UART 1 clock enable */
N#define CLK_APBCLK_PWM0_CH01_EN   (0x1UL<<CLK_APBCLK_PWM0_CH01_EN_Pos) /*!<PWM0 Channel 0 and Channel 1 Clock Enable Control */
N#define CLK_APBCLK_PWM0_CH23_EN   (0x1UL<<CLK_APBCLK_PWM0_CH23_EN_Pos) /*!<PWM0 Channel 2 and Channel 3 Clock Enable Control */
N#define CLK_APBCLK_PWM1_CH01_EN   (0x1UL<<CLK_APBCLK_PWM1_CH01_EN_Pos) /*!<PWM1 Channel 0 and Channel 1 Clock Enable Control */
N#define CLK_APBCLK_PWM1_CH23_EN   (0x1UL<<CLK_APBCLK_PWM1_CH23_EN_Pos) /*!<PWM1 Channel 2 and Channel 3 Clock Enable Control */
N#define CLK_APBCLK_DAC_EN         (0x1UL<<CLK_APBCLK_DAC_EN_Pos)       /*!<DAC Clock Enable Control */
N#define CLK_APBCLK_LCD_EN         (0x1UL<<CLK_APBCLK_LCD_EN_Pos)       /*!<LCD Clock Enable Control */
N#define CLK_APBCLK_USBD_EN        (0x1UL<<CLK_APBCLK_USBD_EN_Pos)      /*!<USB device clock enable */
N#define CLK_APBCLK_ADC_EN         (0x1UL<<CLK_APBCLK_ADC_EN_Pos)       /*!<ADC clock enable */
N#define CLK_APBCLK_I2S_EN         (0x1UL<<CLK_APBCLK_I2S_EN_Pos)       /*!<I2S clock enable */
N#define CLK_APBCLK_SC0_EN         (0x1UL<<CLK_APBCLK_SC0_EN_Pos)       /*!<SmartCard 0 Clock Enable Control */
N#define CLK_APBCLK_SC1_EN         (0x1UL<<CLK_APBCLK_SC1_EN_Pos)       /*!<SmartCard 1 Clock Enable Control */
N
N/********************* Bit definition of CLKSTATUS register **********************/
N#define CLK_CLKSTATUS_HXT_STB     (0x1UL<<CLK_CLKSTATUS_HXT_STB_Pos)       /*!<External high speed crystal clock source stable flag */
N#define CLK_CLKSTATUS_LXT_STB     (0x1UL<<CLK_CLKSTATUS_LXT_STB_Pos)       /*!<External low speed crystal clock source stable flag */
N#define CLK_CLKSTATUS_PLL_STB     (0x1UL<<CLK_CLKSTATUS_PLL_STB_Pos)       /*!<Internal PLL clock source stable flag */
N#define CLK_CLKSTATUS_LIRC_STB    (0x1UL<<CLK_CLKSTATUS_LIRC_STB_Pos)      /*!<Internal low speed oscillator clock source stable flag */
N#define CLK_CLKSTATUS_HIRC_STB    (0x1UL<<CLK_CLKSTATUS_HIRC_STB_Pos)      /*!<Internal high speed oscillator clock source stable flag */
N#define CLK_CLKSTATUS_CLK_SW_FAIL (0x1UL<<CLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!<Clock switch fail flag */
N
N
N/********************* Bit definition of CLKSEL0 register **********************/
N#define CLK_CLKSEL0_HCLK_S_HXT    (0UL<<CLK_CLKSEL0_HCLK_S_Pos)     /*!<Select HCLK clock source from high speed crystal */
N#define CLK_CLKSEL0_HCLK_S_LXT    (1UL<<CLK_CLKSEL0_HCLK_S_Pos)     /*!<Select HCLK clock source from low speed crystal */
N#define CLK_CLKSEL0_HCLK_S_PLL    (2UL<<CLK_CLKSEL0_HCLK_S_Pos)     /*!<Select HCLK clock source from PLL */
N#define CLK_CLKSEL0_HCLK_S_LIRC   (3UL<<CLK_CLKSEL0_HCLK_S_Pos)     /*!<Select HCLK clock source from low speed oscillator */
N#define CLK_CLKSEL0_HCLK_S_HIRC   (7UL<<CLK_CLKSEL0_HCLK_S_Pos)     /*!<Select HCLK clock source from high speed oscillator */
N
N/********************* Bit definition of CLKSEL1 register **********************/
N#define CLK_CLKSEL1_LCD_S_LXT     (0x0UL<<CLK_CLKSEL1_LCD_S_Pos)      /*!<Select LCD clock source from low speed crystal */
N
N#define CLK_CLKSEL1_TMR1_S_HXT    (0x0UL<<CLK_CLKSEL1_TMR1_S_Pos)     /*!<Select TMR1 clock source from high speed crystal */
N#define CLK_CLKSEL1_TMR1_S_LXT    (0x1UL<<CLK_CLKSEL1_TMR1_S_Pos)     /*!<Select TMR1 clock source from low speed crystal */
N#define CLK_CLKSEL1_TMR1_S_LIRC   (0x2UL<<CLK_CLKSEL1_TMR1_S_Pos)     /*!<Select TMR1 clock source from low speed oscillator  */
N#define CLK_CLKSEL1_TMR1_S_EXT    (0x3UL<<CLK_CLKSEL1_TMR1_S_Pos)     /*!<Select TMR1 clock source from external trigger */
N#define CLK_CLKSEL1_TMR1_S_HIRC   (0x4UL<<CLK_CLKSEL1_TMR1_S_Pos)     /*!<Select TMR1 clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_TMR0_S_HXT    (0x0UL<<CLK_CLKSEL1_TMR0_S_Pos)     /*!<Select TMR0 clock source from high speed crystal */
N#define CLK_CLKSEL1_TMR0_S_LXT    (0x1UL<<CLK_CLKSEL1_TMR0_S_Pos)     /*!<Select TMR0 clock source from low speed crystal */
N#define CLK_CLKSEL1_TMR0_S_LIRC   (0x2UL<<CLK_CLKSEL1_TMR0_S_Pos)     /*!<Select TMR0 clock source from low speed oscillator */
N#define CLK_CLKSEL1_TMR0_S_EXT    (0x3UL<<CLK_CLKSEL1_TMR0_S_Pos)     /*!<Select TMR0 clock source from external trigger */
N#define CLK_CLKSEL1_TMR0_S_HIRC   (0x4UL<<CLK_CLKSEL1_TMR0_S_Pos)     /*!<Select TMR0 clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_PWM0_CH01_S_HXT   (0x0UL<<CLK_CLKSEL1_PWM0_CH01_S_Pos)  /*!<Select PWM0_CH01 clock source from high speed crystal */
N#define CLK_CLKSEL1_PWM0_CH01_S_LXT   (0x1UL<<CLK_CLKSEL1_PWM0_CH01_S_Pos)  /*!<Select PWM0_CH01 clock source from low speed crystal */
N#define CLK_CLKSEL1_PWM0_CH01_S_HCLK  (0x2UL<<CLK_CLKSEL1_PWM0_CH01_S_Pos)  /*!<Select PWM0_CH01 clock source from HCLK */
N#define CLK_CLKSEL1_PWM0_CH01_S_HIRC  (0x3UL<<CLK_CLKSEL1_PWM0_CH01_S_Pos)  /*!<Select PWM0_CH01 clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_PWM0_CH23_S_HXT   (0x0UL<<CLK_CLKSEL1_PWM0_CH23_S_Pos)  /*!<Select PWM0_CH23 clock source from high speed crystal */
N#define CLK_CLKSEL1_PWM0_CH23_S_LXT   (0x1UL<<CLK_CLKSEL1_PWM0_CH23_S_Pos)  /*!<Select PWM0_CH23 clock source from low speed crystal */
N#define CLK_CLKSEL1_PWM0_CH23_S_HCLK  (0x2UL<<CLK_CLKSEL1_PWM0_CH23_S_Pos)  /*!<Select PWM0_CH23 clock source from HCLK */
N#define CLK_CLKSEL1_PWM0_CH23_S_HIRC  (0x3UL<<CLK_CLKSEL1_PWM0_CH23_S_Pos)  /*!<Select PWM0_CH23 clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_ADC_S_HXT     (0x0UL<<CLK_CLKSEL1_ADC_S_Pos)      /*!<Select ADC clock source from high speed crystal */
N#define CLK_CLKSEL1_ADC_S_LXT     (0x1UL<<CLK_CLKSEL1_ADC_S_Pos)      /*!<Select ADC clock source from low speed crystal */
N#define CLK_CLKSEL1_ADC_S_PLL     (0x2UL<<CLK_CLKSEL1_ADC_S_Pos)      /*!<Select ADC clock source from PLL */
N#define CLK_CLKSEL1_ADC_S_HIRC    (0x3UL<<CLK_CLKSEL1_ADC_S_Pos)      /*!<Select ADC clock source from high speed oscillator */
N
N#define CLK_CLKSEL1_UART_S_HXT    (0x0UL<<CLK_CLKSEL1_UART_S_Pos)     /*!<Select UART clock source from high speed crystal */
N#define CLK_CLKSEL1_UART_S_LXT    (0x1UL<<CLK_CLKSEL1_UART_S_Pos)     /*!<Select UART clock source from low speed crystal */
N#define CLK_CLKSEL1_UART_S_PLL    (0x2UL<<CLK_CLKSEL1_UART_S_Pos)     /*!<Select UART clock source from PLL */
N#define CLK_CLKSEL1_UART_S_HIRC   (0x3UL<<CLK_CLKSEL1_UART_S_Pos)     /*!<Select UART clock source from high speed oscillator */
N
N/********************* Bit definition of CLKSEL2 register **********************/
N#define CLK_CLKSEL2_SPI2_S_PLL    (0x0UL<<CLK_CLKSEL2_SPI2_S_Pos)     /*!<Select SPI2 clock source from PLL */
N#define CLK_CLKSEL2_SPI2_S_HCLK   (0x1UL<<CLK_CLKSEL2_SPI2_S_Pos)     /*!<Select SPI2 clock source from HCLK */
N
N#define CLK_CLKSEL2_SPI1_S_PLL    (0x0UL<<CLK_CLKSEL2_SPI1_S_Pos)     /*!<Select SPI1 clock source from PLL */
N#define CLK_CLKSEL2_SPI1_S_HCLK   (0x1UL<<CLK_CLKSEL2_SPI1_S_Pos)     /*!<Select SPI1 clock source from HCLK */
N
N#define CLK_CLKSEL2_SPI0_S_PLL    (0x0UL<<CLK_CLKSEL2_SPI0_S_Pos)     /*!<Select SPI0 clock source from PLL */
N#define CLK_CLKSEL2_SPI0_S_HCLK   (0x1UL<<CLK_CLKSEL2_SPI0_S_Pos)     /*!<Select SPI0 clock source from HCLK */
N
N#define CLK_CLKSEL2_SC_S_HXT      (0x0UL<<CLK_CLKSEL2_SC_S_Pos)       /*!<Select SmartCard clock source from HXT */
N#define CLK_CLKSEL2_SC_S_PLL      (0x1UL<<CLK_CLKSEL2_SC_S_Pos)       /*!<Select smartCard clock source from PLL */
N#define CLK_CLKSEL2_SC_S_HIRC     (0x2UL<<CLK_CLKSEL2_SC_S_Pos)       /*!<Select SmartCard clock source from HIRC */
N
N#define CLK_CLKSEL2_I2S_S_HXT      (0x0UL<<CLK_CLKSEL2_I2S_S_Pos)       /*!<Select I2S clock source from HXT */
N#define CLK_CLKSEL2_I2S_S_PLL      (0x1UL<<CLK_CLKSEL2_I2S_S_Pos)       /*!<Select I2S clock source from PLL */
N#define CLK_CLKSEL2_I2S_S_HIRC     (0x2UL<<CLK_CLKSEL2_I2S_S_Pos)       /*!<Select I2S clock source from HIRC */
N
N#define CLK_CLKSEL2_TMR3_S_HXT    (0x0UL<<CLK_CLKSEL2_TMR3_S_Pos)     /*!<Select TMR3 clock source from high speed crystal */
N#define CLK_CLKSEL2_TMR3_S_LXT    (0x1UL<<CLK_CLKSEL2_TMR3_S_Pos)     /*!<Select TMR3 clock source from low speed crystal */
N#define CLK_CLKSEL2_TMR3_S_LIRC   (0x2UL<<CLK_CLKSEL2_TMR3_S_Pos)     /*!<Select TMR3 clock source from low speed oscillator  */
N#define CLK_CLKSEL2_TMR3_S_EXT    (0x3UL<<CLK_CLKSEL2_TMR3_S_Pos)     /*!<Select TMR3 clock source from external trigger */
N#define CLK_CLKSEL2_TMR3_S_HIRC   (0x4UL<<CLK_CLKSEL2_TMR3_S_Pos)     /*!<Select TMR3 clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_TMR2_S_HXT    (0x0UL<<CLK_CLKSEL2_TMR2_S_Pos)     /*!<Select TMR2 clock source from high speed crystal */
N#define CLK_CLKSEL2_TMR2_S_LXT    (0x1UL<<CLK_CLKSEL2_TMR2_S_Pos)     /*!<Select TMR2 clock source from low speed crystal */
N#define CLK_CLKSEL2_TMR2_S_LIRC   (0x2UL<<CLK_CLKSEL2_TMR2_S_Pos)     /*!<Select TMR2 clock source from low speed oscillator */
N#define CLK_CLKSEL2_TMR2_S_EXT    (0x3UL<<CLK_CLKSEL2_TMR2_S_Pos)     /*!<Select TMR2 clock source from external trigger */
N#define CLK_CLKSEL2_TMR2_S_HIRC   (0x4UL<<CLK_CLKSEL2_TMR2_S_Pos)     /*!<Select TMR2 clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_PWM1_CH01_S_HXT   (0x0UL<<CLK_CLKSEL2_PWM1_CH01_S_Pos)  /*!<Select PWM1_CH01 clock source from high speed crystal */
N#define CLK_CLKSEL2_PWM1_CH01_S_LXT   (0x1UL<<CLK_CLKSEL2_PWM1_CH01_S_Pos)  /*!<Select PWM1_CH01 clock source from low speed crystal */
N#define CLK_CLKSEL2_PWM1_CH01_S_HCLK  (0x2UL<<CLK_CLKSEL2_PWM1_CH01_S_Pos)  /*!<Select PWM1_CH01 clock source from HCLK */
N#define CLK_CLKSEL2_PWM1_CH01_S_HIRC  (0x3UL<<CLK_CLKSEL2_PWM1_CH01_S_Pos)  /*!<Select PWM1_CH01 clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_PWM1_CH23_S_HXT   (0x0UL<<CLK_CLKSEL2_PWM1_CH23_S_Pos)  /*!<Select PWM1_CH23 clock source from high speed crystal */
N#define CLK_CLKSEL2_PWM1_CH23_S_LXT   (0x1UL<<CLK_CLKSEL2_PWM1_CH23_S_Pos)  /*!<Select PWM1_CH23 clock source from low speed crystal */
N#define CLK_CLKSEL2_PWM1_CH23_S_HCLK  (0x2UL<<CLK_CLKSEL2_PWM1_CH23_S_Pos)  /*!<Select PWM1_CH23 clock source from HCLK */
N#define CLK_CLKSEL2_PWM1_CH23_S_HIRC  (0x3UL<<CLK_CLKSEL2_PWM1_CH23_S_Pos)  /*!<Select PWM1_CH23 clock source from high speed oscillator */
N
N#define CLK_CLKSEL2_FRQDIV_S_HXT      (0x0UL<<CLK_CLKSEL2_FRQDIV_S_Pos)     /*!<Select FRQDIV clock source from HXT */
N#define CLK_CLKSEL2_FRQDIV_S_LXT      (0x1UL<<CLK_CLKSEL2_FRQDIV_S_Pos)     /*!<Select FRQDIV clock source from LXT */
N#define CLK_CLKSEL2_FRQDIV_S_HCLK     (0x2UL<<CLK_CLKSEL2_FRQDIV_S_Pos)     /*!<Select FRQDIV clock source from HCLK */
N#define CLK_CLKSEL2_FRQDIV_S_HIRC     (0x3UL<<CLK_CLKSEL2_FRQDIV_S_Pos)     /*!<Select FRQDIV clock source from HIRC */
N
N/********************* Bit definition of CLKDIV0 register **********************/
N#define CLK_HCLK_CLK_DIVIDER(x)     (((x-1)<< CLK_CLKDIV0_HCLK_N_Pos) & CLK_CLKDIV0_HCLK_N_Msk)  /*!< CLKDIV0 Setting for HCLK clock divider. It could be 1~16 */
N#define CLK_USB_CLK_DIVIDER(x)      (((x-1)<< CLK_CLKDIV0_USB_N_Pos) & CLK_CLKDIV0_USB_N_Msk)    /*!< CLKDIV0 Setting for HCLK clock divider. It could be 1~16 */
N#define CLK_UART_CLK_DIVIDER(x)     (((x-1)<< CLK_CLKDIV0_UART_N_Pos) & CLK_CLKDIV0_UART_N_Msk)  /*!< CLKDIV0 Setting for UART clock divider. It could be 1~16 */
N#define CLK_ADC_CLK_DIVIDER(x)      (((x-1)<< CLK_CLKDIV0_ADC_N_Pos)  & CLK_CLKDIV0_ADC_N_Msk)   /*!< CLKDIV0 Setting for ADC clock divider. It could be 1~256 */
N#define CLK_SC0_CLK_DIVIDER(x)      (((x-1)<< CLK_CLKDIV0_SC0_N_Pos)  & CLK_CLKDIV0_SC0_N_Msk)   /*!< CLKDIV0 Setting for SmartCard0 clock divider. It could be 1~16 */
N#define CLK_I2S_CLK_DIVIDER(x)      (((x-1)<< CLK_CLKDIV0_I2S_N_Pos)  & CLK_CLKDIV0_I2S_N_Msk)   /*!< CLKDIV0 Setting for I2S clock divider. It could be 1~16 */
N
N/********************* Bit definition of CLKDIV1 register **********************/
N#define CLK_SC2_CLK_DIVIDER(x)      (((x-1)<< CLK_CLKDIV1_SC2_N_Pos ) & CLK_CLKDIV1_SC2_N_Msk)   /*!< CLKDIV1 Setting for SmartCard2 clock divider. It could be 1~16 */
N#define CLK_SC1_CLK_DIVIDER(x)      (((x-1)<< CLK_CLKDIV1_SC1_N_Pos ) & CLK_CLKDIV1_SC1_N_Msk)   /*!< CLKDIV1 Setting for SmartCard1 clock divider. It could be 1~16 */
N
N/********************* Bit definition of SysTick register **********************/
N#define CLK_CLKSEL0_STCLKSEL_HCLK         (1)     /*!< Setting systick clock source as external HCLK */
N#define CLK_CLKSEL0_STCLKSEL_HCLK_DIV8    (2)     /*!< Setting systick clock source as external HCLK/8 */
N
N/********************* Bit definition of PLLCTL register **********************/
N#define CLK_PLLCTL_OUT_DV         (0x1UL<<CLK_PLLCTL_OUT_DV_Pos)     /*!<PLL Output Divider Control */
N#define CLK_PLLCTL_PD             (0x1UL<<CLK_PLLCTL_PD_Pos)         /*!<PLL Power down mode */
N#define CLK_PLLCTL_PLL_SRC_HIRC   (0x1UL<<CLK_PLLCTL_PLL_SRC_Pos)    /*!<PLL clock source from high speed oscillator */
N#define CLK_PLLCTL_PLL_SRC_HXT    (0x0UL<<CLK_PLLCTL_PLL_SRC_Pos)    /*!<PLL clock source from high speed crystal */
N
N#define CLK_PLLCTL_NR_2        0x000         /*!< For PLL input divider is  2 */
N#define CLK_PLLCTL_NR_4        0x100         /*!< For PLL input divider is  4 */
N#define CLK_PLLCTL_NR_8        0x200         /*!< For PLL input divider is  8 */
N#define CLK_PLLCTL_NR_16       0x300         /*!< For PLL input divider is 16 */
N#define CLK_PLLCON_NF(x)      ((x)-32)       /*!< x must be constant and 32 <= x <= 95.) */
N
N#define CLK_PLLCON_NO_1        0x0000UL      /*!< For PLL output divider is 1 */
N#define CLK_PLLCON_NO_2        0x1000UL      /*!< For PLL output divider is 2 */
N
N#if (__HXT == 12000000)
X#if ((12000000UL) == 12000000)
N#define CLK_PLLCTL_120MHz_HXT  (CLK_PLLCTL_PLL_SRC_HXT  | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_4 | CLK_PLLCON_NF(40) ) /*!< Predefined PLLCTL setting for 120MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCTL_96MHz_HXT   (CLK_PLLCTL_PLL_SRC_HXT  | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_8 | CLK_PLLCON_NF(64) ) /*!< Predefined PLLCTL setting for  96MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCTL_48MHz_HXT   (CLK_PLLCTL_PLL_SRC_HXT  | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_16| CLK_PLLCON_NF(64) ) /*!< Predefined PLLCTL setting for  48MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCTL_84MHz_HXT   (CLK_PLLCTL_PLL_SRC_HXT  | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_8 | CLK_PLLCON_NF(56) ) /*!< Predefined PLLCTL setting for  84MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCTL_42MHz_HXT   (CLK_PLLCTL_PLL_SRC_HXT  | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_16| CLK_PLLCON_NF(56) ) /*!< Predefined PLLCTL setting for  42MHz PLL output with 12MHz X'tal */
N#else
S# error "The PLL pre-definitions are only valid when external crystal is 12MHz"
N#endif
N#define CLK_PLLCTL_120MHz_HIRC (CLK_PLLCTL_PLL_SRC_HIRC | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_4 | CLK_PLLCON_NF(40) ) /*!< Predefined PLLCTL setting for 120MHz PLL output with 12MHz IRC */
N#define CLK_PLLCTL_96MHz_HIRC  (CLK_PLLCTL_PLL_SRC_HIRC | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_8 | CLK_PLLCON_NF(64) ) /*!< Predefined PLLCTL setting for  96MHz PLL output with 12MHz IRC */
N#define CLK_PLLCTL_48MHz_HIRC  (CLK_PLLCTL_PLL_SRC_HIRC | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_16| CLK_PLLCON_NF(64) ) /*!< Predefined PLLCTL setting for  48MHz PLL output with 12MHz IRC */
N#define CLK_PLLCTL_84MHz_HIRC  (CLK_PLLCTL_PLL_SRC_HIRC | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_8 | CLK_PLLCON_NF(56) ) /*!< Predefined PLLCTL setting for  84MHz PLL output with 12MHz IRC */
N#define CLK_PLLCTL_42MHz_HIRC  (CLK_PLLCTL_PLL_SRC_HIRC | CLK_PLLCON_NO_1 | CLK_PLLCTL_NR_16| CLK_PLLCON_NF(56) ) /*!< Predefined PLLCTL setting for  42MHz PLL output with 12MHz IRC */
N
N/********************* Bit definition of FRQDIV register **********************/
N#define CLK_FRQDIV_EN         (0x1UL<<CLK_FRQDIV_FDIV_EN_Pos)        /*!<Frequency divider enable bit */
N
N/********************* Bit definition of WK_INTSTS register **********************/
N#define CLK_WK_INTSTS_IS      (0x1UL<<CLK_WK_INTSTS_PD_WK_IS_Pos)     /*!<Wake-up Interrupt Status in chip Power-down Mode */
N
N/********************* Bit definition of MCLKO register **********************/
N#define CLK_MCLKO_MCLK_SEL_ISP_CLK  (0x00<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output ISP_CLK */
N#define CLK_MCLKO_MCLK_SEL_HIRC         (0x01<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output HIRC clock */
N#define CLK_MCLKO_MCLK_SEL_HXT          (0x02<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output HXT clock */
N#define CLK_MCLKO_MCLK_SEL_LXT          (0x03<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output LXT clock */
N#define CLK_MCLKO_MCLK_SEL_LIRC         (0x04<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output LIRC clock */
N#define CLK_MCLKO_MCLK_SEL_PLLO         (0x05<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output PLL input */
N#define CLK_MCLKO_MCLK_SEL_PLLI         (0x06<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output PLL input */
N#define CLK_MCLKO_MCLK_SEL_SYSTICK  (0x07<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output system tick */
N#define CLK_MCLKO_MCLK_SEL_HCLK         (0x08<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output HCLK clock */
N#define CLK_MCLKO_MCLK_SEL_PCLK         (0x0A<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output PCLK clock */
N#define CLK_MCLKO_MCLK_SEL_TMR0         (0x20<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output TMR0 clock */
N#define CLK_MCLKO_MCLK_SEL_TMR1         (0x21<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output TMR1 clock */
N#define CLK_MCLKO_MCLK_SEL_UART0        (0x22<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output UART0 clock */
N#define CLK_MCLKO_MCLK_SEL_USB          (0x23<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output USB clock */
N#define CLK_MCLKO_MCLK_SEL_ADC          (0x24<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output ADC clock */
N#define CLK_MCLKO_MCLK_SEL_WDT          (0x25<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output WDT clock */
N#define CLK_MCLKO_MCLK_SEL_PWM0CH01 (0x26<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output PWM0CH01 clock */
N#define CLK_MCLKO_MCLK_SEL_PWM0CH23 (0x27<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output PWM0CH23 clock */
N#define CLK_MCLKO_MCLK_SEL_LCD          (0x29<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output LCD clock */
N#define CLK_MCLKO_MCLK_SEL_TMR2         (0x38<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output TMR2 clock */
N#define CLK_MCLKO_MCLK_SEL_TMR3         (0x39<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output TMR3 clock */
N#define CLK_MCLKO_MCLK_SEL_UART1        (0x3A<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output UART1 clock */
N#define CLK_MCLKO_MCLK_SEL_PWM1CH01 (0x3B<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output PWM1CH01 clock */
N#define CLK_MCLKO_MCLK_SEL_PWM1CH23 (0x3C<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output PWM1CH23 clock */
N#define CLK_MCLKO_MCLK_SEL_I2S          (0x3D<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output I2S clock */
N#define CLK_MCLKO_MCLK_SEL_SC0          (0x3E<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output SC0 clock */
N#define CLK_MCLKO_MCLK_SEL_SC1          (0x3F<<CLK_MCLKO_MCLK_SEL_Pos) /*!<Select MCLK clock output SC1 clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define MODULE_APBCLK(x)                   ((x >>31) & 0x1)    /*!< Calculate APBCLK offset on MODULE index */
N#define MODULE_CLKSEL(x)                   ((x >>29) & 0x3)    /*!< Calculate CLKSEL offset on MODULE index */
N#define MODULE_CLKSEL_Msk(x)               ((x >>25) & 0xf)    /*!< Calculate CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos(x)               ((x >>20) & 0x1f)   /*!< Calculate CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV(x)                   ((x >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index */
N#define MODULE_CLKDIV_Msk(x)               ((x >>10) & 0xff)   /*!< Calculate CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos(x)               ((x >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos(x)                ((x >>0 ) & 0x1f)   /*!< Calculate APBCLK offset on MODULE index */
N#define MODULE_NoMsk                       0x0                 /*!< Not mask on MODULE index */
N#define NA                                 MODULE_NoMsk        /*!< Not Available */
N
N#define MODULE_APBCLK_ENC(x)        (((x) & 0x01) << 31)   /*!< MODULE index, 0x0:AHBCLK, 0x1:APBCLK */
N#define MODULE_CLKSEL_ENC(x)        (((x) & 0x03) << 29)   /*!< CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1 0x3 CLKSEL2*/
N#define MODULE_CLKSEL_Msk_ENC(x)    (((x) & 0x0f) << 25)   /*!< CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos_ENC(x)    (((x) & 0x1f) << 20)   /*!< CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV_ENC(x)        (((x) & 0x03) << 18)   /*!< APBCLK CLKDIV on MODULE index, 0x0:CLKDIV */
N#define MODULE_CLKDIV_Msk_ENC(x)    (((x) & 0xff) << 10)   /*!< CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos_ENC(x)    (((x) & 0x1f) <<  5)   /*!< CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos_ENC(x)     (((x) & 0x1f) <<  0)   /*!< APBCLK offset on MODULE index */
N/*-------------------------------------------------------------------------------------------------------------------------------*/
N/*   APBCLK(1) | CLKSEL(2) | CLKSEL_Msk(4) |  CLKSEL_Pos(5) | CLKDIV(2) | CLKDIV_Msk(8) |  CLKDIV_Pos(5)  |  IP_EN_Pos(5)        */
N/*-------------------------------------------------------------------------------------------------------------------------------*/
N#define TICK_MODULE      ((0UL<<31)|(3<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(1<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_AHBCLK_TICK_EN_Pos     ) /*!< TICK Module */
N#define SRAM_MODULE      ((0UL<<31)|(3<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(1<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_AHBCLK_SRAM_EN_Pos     ) /*!< SRAM Module */
N#define EBI_MODULE       ((0UL<<31)|(3<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(1<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_AHBCLK_EBI_EN_Pos      ) /*!< EBI Module */
N#define ISP_MODULE       ((0UL<<31)|(3<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(1<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_AHBCLK_ISP_EN_Pos      ) /*!< ISP Module */
N#define DMA_MODULE       ((0UL<<31)|(3<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_AHBCLK_DMA_EN_Pos      ) /*!< DMA Module */
N#define GPIO_MODULE      ((0UL<<31)|(3<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_AHBCLK_GPIO_EN_Pos     ) /*!< GPIO Module */
N
N#define SC2_MODULE       ((1UL<<31)|(2<<29)|(3<<25)           |(18<<20)|(1<<18)|(0xF<<10)         |( 4<<5)|CLK_APBCLK_SC2_EN_Pos      ) /*!< SmartCard2 Module */
N#define SC1_MODULE       ((1UL<<31)|(2<<29)|(3<<25)           |(18<<20)|(1<<18)|(0xF<<10)         |( 0<<5)|CLK_APBCLK_SC1_EN_Pos      ) /*!< SmartCard1 Module */
N#define SC0_MODULE       ((1UL<<31)|(2<<29)|(3<<25)           |(18<<20)|(0<<18)|(0xF<<10)         |(28<<5)|CLK_APBCLK_SC0_EN_Pos      ) /*!< SmartCard0 Module */
N#define I2S_MODULE       ((1UL<<31)|(2<<29)|(3<<25)           |(16<<20)|(0<<18)|(0xF<<10)         |(12<<5)|CLK_APBCLK_I2S_EN_Pos      ) /*!< I2S Module */
N#define ADC_MODULE       ((1UL<<31)|(1<<29)|(3<<25)           |( 2<<20)|(0<<18)|(0xFF<<10)        |(16<<5)|CLK_APBCLK_ADC_EN_Pos      ) /*!< ADC Module */
N#define USBD_MODULE      ((1UL<<31)|(1<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(0xF<<10)         |( 4<<5)|CLK_APBCLK_USBD_EN_Pos     ) /*!< USBD Module */
N#define PWM1_CH23_MODULE ((1UL<<31)|(2<<29)|(3<<25)           |( 6<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_PWM1_CH23_EN_Pos) /*!< PWM1 Channel2 and Channel3 Module */
N#define PWM1_CH01_MODULE ((1UL<<31)|(2<<29)|(3<<25)           |( 4<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_PWM1_CH01_EN_Pos) /*!< PWM1 Channel0 and Channel1 Module */
N#define PWM0_CH23_MODULE ((1UL<<31)|(1<<29)|(3<<25)           |( 6<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_PWM0_CH23_EN_Pos) /*!< PWM0 Channel2 and Channel3 Module */
N#define PWM0_CH01_MODULE ((1UL<<31)|(1<<29)|(3<<25)           |( 4<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_PWM0_CH01_EN_Pos) /*!< PWM0 Channel0 and Channel1 Module */
N#define UART1_MODULE     ((1UL<<31)|(1<<29)|(3<<25)           |( 0<<20)|(0<<18)|(0xF<<10)         |( 8<<5)|CLK_APBCLK_UART1_EN_Pos    ) /*!< UART1 Module */
N#define UART0_MODULE     ((1UL<<31)|(1<<29)|(3<<25)           |( 0<<20)|(0<<18)|(0xF<<10)         |( 8<<5)|CLK_APBCLK_UART0_EN_Pos    ) /*!< UART0 Module */
N#define SPI2_MODULE      ((1UL<<31)|(2<<29)|(1<<25)           |(22<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_SPI2_EN_Pos     ) /*!< SPI0 Module */
N#define SPI1_MODULE      ((1UL<<31)|(2<<29)|(1<<25)           |(21<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_SPI1_EN_Pos     ) /*!< SPI1 Module */
N#define SPI0_MODULE      ((1UL<<31)|(2<<29)|(1<<25)           |(20<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_SPI0_EN_Pos     ) /*!< SPI0 Module */
N#define I2C1_MODULE      ((1UL<<31)|(0<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_I2C1_EN_Pos     ) /*!< I2C1 Module */
N#define I2C0_MODULE      ((1UL<<31)|(0<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_I2C0_EN_Pos     ) /*!< I2C0 Module */
N#define FDIV_MODULE      ((1UL<<31)|(2<<29)|(3<<25)           |( 2<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_FDIV_EN_Pos     ) /*!< Frequency Divider0 Output Module */
N#define TMR3_MODULE      ((1UL<<31)|(2<<29)|(7<<25)           |(12<<20)|(1<<18)|(0xF<<10)         |(20<<5)|CLK_APBCLK_TMR3_EN_Pos     ) /*!< Timer3 Module */
N#define TMR2_MODULE      ((1UL<<31)|(2<<29)|(7<<25)           |( 8<<20)|(1<<18)|(0xF<<10)         |(16<<5)|CLK_APBCLK_TMR2_EN_Pos     ) /*!< Timer2 Module */
N#define TMR1_MODULE      ((1UL<<31)|(1<<29)|(7<<25)           |(12<<20)|(1<<18)|(0xF<<10)         |(12<<5)|CLK_APBCLK_TMR1_EN_Pos     ) /*!< Timer1 Module */
N#define TMR0_MODULE      ((1UL<<31)|(1<<29)|(7<<25)           |( 8<<20)|(1<<18)|(0xF<<10)         |( 8<<5)|CLK_APBCLK_TMR0_EN_Pos     ) /*!< Timer0 Module */
N#define RTC_MODULE       ((1UL<<31)|(3<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_RTC_EN_Pos      ) /*!< Real-Time-Clock Module */
N#define WDT_MODULE       ((1UL<<31)|(3<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_WDT_EN_Pos      ) /*!< Watchdog Timer Module */
N#define LCD_MODULE       ((1UL<<31)|(1<<29)|(1<<25)           |(18<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_LCD_EN_Pos      ) /*!< LCD Module */
N#define DAC_MODULE       ((1UL<<31)|(3<<29)|(MODULE_NoMsk<<25)|( 0<<20)|(0<<18)|(MODULE_NoMsk<<10)|( 0<<5)|CLK_APBCLK_DAC_EN_Pos      ) /*!< DAC Module */
N/*@}*/ /* end of group NANO100_CLK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetLXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nuint32_t CLK_GetPLLClockFreq(void);
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
Nvoid CLK_DisablePLL(void);
Nvoid CLK_SysTickDelay(uint32_t us);
Nvoid CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count);
Nvoid CLK_DisableSysTick(void);
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
N
N/*@}*/ /* end of group NANO100_CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_CLK_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CLK_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11928 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "adc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\adc.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @version  V1.00
N * $Revision: 10 $
N * $Date: 15/06/30 2:50p $
N * @brief    NANO100 series ADC driver header file
N *
N * @note
N * Copyright (C) 2013-2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __ADC_H__
N#define __ADC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup NANO100_ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/
N
N#define ADC_CH_0_MASK                    (1UL << 0)                  /*!< ADC channel 0 mask */
N#define ADC_CH_1_MASK                    (1UL << 1)                  /*!< ADC channel 1 mask */
N#define ADC_CH_2_MASK                    (1UL << 2)                  /*!< ADC channel 2 mask */
N#define ADC_CH_3_MASK                    (1UL << 3)                  /*!< ADC channel 3 mask */
N#define ADC_CH_4_MASK                    (1UL << 4)                  /*!< ADC channel 4 mask */
N#define ADC_CH_5_MASK                    (1UL << 5)                  /*!< ADC channel 5 mask */
N#define ADC_CH_6_MASK                    (1UL << 6)                  /*!< ADC channel 6 mask */
N#define ADC_CH_7_MASK                    (1UL << 7)                  /*!< ADC channel 7 mask */
N#define ADC_CH_8_MASK                    (1UL << 8)                  /*!< ADC channel 8 mask */
N#define ADC_CH_9_MASK                    (1UL << 9)                  /*!< ADC channel 9 mask */
N#define ADC_CH_10_MASK                   (1UL << 10)                 /*!< ADC channel 10 mask */
N#define ADC_CH_11_MASK                   (1UL << 11)                 /*!< ADC channel 11 mask */
N#define ADC_CH_12_MASK                   (1UL << 12)                 /*!< ADC channel 12 mask */
N#define ADC_CH_13_MASK                   (1UL << 13)                 /*!< ADC channel 13 mask */
N#define ADC_CH_14_MASK                   (1UL << 14)                 /*!< ADC channel 14 mask */
N#define ADC_CH_15_MASK                   (1UL << 15)                 /*!< ADC channel 15 mask */
N#define ADC_CH_16_MASK                   (1UL << 16)                 /*!< ADC channel 16 mask */
N#define ADC_CH_17_MASK                   (1UL << 17)                 /*!< ADC channel 17 mask */
N#define ADC_CHEN_Msk                     (0x3FFFF)                   /*!< ADC channel 0 ~ 17 mask */
N#define ADC_PDMADATA_AD_PDMA_Msk         (0xFFF)                     /*!< ADC PDMA current transfer data */
N#define ADC_CMP_LESS_THAN                (0UL)                       /*!< ADC compare condition less than */
N#define ADC_CMP_GREATER_OR_EQUAL_TO      (ADC_CMPR_CMPCOND_Msk)      /*!< ADC compare condition greater or equal to */
N#define ADC_TRIGGER_BY_EXT_PIN           (0UL)                       /*!< ADC trigger by STADC (P3.2) pin */
N#define ADC_LOW_LEVEL_TRIGGER            (0UL << ADC_CR_TRGCOND_Pos) /*!< External pin low level trigger ADC */
N#define ADC_HIGH_LEVEL_TRIGGER           (1UL << ADC_CR_TRGCOND_Pos) /*!< External pin high level trigger ADC */
N#define ADC_FALLING_EDGE_TRIGGER         (2UL << ADC_CR_TRGCOND_Pos) /*!< External pin falling edge trigger ADC */
N#define ADC_RISING_EDGE_TRIGGER          (3UL << ADC_CR_TRGCOND_Pos) /*!< External pin rising edge trigger ADC */
N#define ADC_ADF_INT                      (ADC_SR_ADF_Msk)            /*!< ADC convert complete interrupt */
N#define ADC_CMP0_INT                     (ADC_SR_CMPF0_Msk)          /*!< ADC comparator 0 interrupt */
N#define ADC_CMP1_INT                     (ADC_SR_CMPF1_Msk)          /*!< ADC comparator 1 interrupt */
N#define ADC_INPUT_MODE_SINGLE_END        (0UL << ADC_CR_DIFF_Pos)    /*!< ADC input mode set to single end */
N#define ADC_INPUT_MODE_DIFFERENTIAL      (1UL << ADC_CR_DIFF_Pos)    /*!< ADC input mode set to differential */
N#define ADC_OPERATION_MODE_SINGLE        (0UL << ADC_CR_ADMD_Pos)    /*!< ADC operation mode set to single conversion */
N#define ADC_OPERATION_MODE_SINGLE_CYCLE  (2UL << ADC_CR_ADMD_Pos)    /*!< ADC operation mode set to single cycle scan */
N#define ADC_OPERATION_MODE_CONTINUOUS    (3UL << ADC_CR_ADMD_Pos)    /*!< ADC operation mode set to continuous scan */
N#define ADC_DMODE_OUT_FORMAT_UNSIGNED    (0UL << ADC_CR_DIFF_Pos)    /*!< ADC differential mode output format with unsigned */
N#define ADC_DMODE_OUT_FORMAT_2COMPLEMENT (1UL << ADC_CR_DIFF_Pos)    /*!< ADC differential mode output format with 2's complement */
N#define ADC_RESSEL_6_BIT                 (0UL << ADC_CR_RESSEL_Pos)  /*!< ADC resolution selection set to 6 bit */
N#define ADC_RESSEL_8_BIT                 (1UL << ADC_CR_RESSEL_Pos)  /*!< ADC resolution selection set to 8 bit */
N#define ADC_RESSEL_10_BIT                (2UL << ADC_CR_RESSEL_Pos)  /*!< ADC resolution selection set to 10 bit */
N#define ADC_RESSEL_12_BIT                (3UL << ADC_CR_RESSEL_Pos)  /*!< ADC resolution selection set to 12 bit */
N#define ADC_REFSEL_POWER                 (0UL << ADC_CR_REFSEL_Pos)  /*!< ADC reference voltage source selection set to power */
N#define ADC_REFSEL_INT_VREF              (1UL << ADC_CR_REFSEL_Pos)  /*!< ADC reference voltage source selection set to Int_VREF */
N#define ADC_REFSEL_VREF                  (2UL << ADC_CR_REFSEL_Pos)  /*!< ADC reference voltage source selection set to VREF */
N
N/*@}*/ /* end of group NANO100_ADC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N/**
N  * @brief Get the latest ADC conversion data
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Channel number
N  * @return  Latest ADC conversion data
N  * \hideinitializer
N  */
N#define ADC_GET_CONVERSION_DATA(adc, u32ChNum) (ADC->RESULT[u32ChNum] & ADC_RESULT_RSLT_Msk)
N
N/**
N  * @brief Return the user-specified interrupt flags
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                     - \ref ADC_ADF_INT
N  *                     - \ref ADC_CMP0_INT
N  *                     - \ref ADC_CMP1_INT
N  * @return  User specified interrupt flags
N  * \hideinitializer
N  */
N#define ADC_GET_INT_FLAG(adc, u32Mask) (ADC->SR & (u32Mask))
N
N/**
N  * @brief This macro clear the selected interrupt status bits
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                     - \ref ADC_ADF_INT
N  *                     - \ref ADC_CMP0_INT
N  *                     - \ref ADC_CMP1_INT
N  * @return  None
N  * \hideinitializer
N  */
N#define ADC_CLR_INT_FLAG(adc, u32Mask) (ADC->SR = (ADC->SR & ~(ADC_SR_ADF_Msk | \
N                                                                       ADC_SR_CMPF0_Msk | \
N                                                                       ADC_SR_CMPF1_Msk)) | (u32Mask))
X#define ADC_CLR_INT_FLAG(adc, u32Mask) (ADC->SR = (ADC->SR & ~(ADC_SR_ADF_Msk |                                                                        ADC_SR_CMPF0_Msk |                                                                        ADC_SR_CMPF1_Msk)) | (u32Mask))
N
N/**
N  * @brief Get the busy state of ADC
N  * @param[in] adc Base address of ADC module
N  * @return busy state of ADC
N  * @retval 0 ADC is not busy
N  * @retval 1 ADC is busy
N  * \hideinitializer
N  */
N#define ADC_IS_BUSY(adc) (ADC->SR & ADC_SR_BUSY_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is over written or not
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return Over run state of ADC data
N  * @retval 0 ADC data is not overrun
N  * @retval 1 ADC data us overrun
N  * \hideinitializer
N  */
N#define ADC_IS_DATA_OVERRUN(adc, u32ChNum) (ADC->RESULT[u32ChNum] & ADC_RESULT_OVERRUN_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is valid or not
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return Valid state of ADC data
N  * @retval 0 ADC data is not valid
N  * @retval 1 ADC data us valid
N  * \hideinitializer
N  */
N#define ADC_IS_DATA_VALID(adc, u32ChNum) (ADC->RESULT[u32ChNum] & ADC_RESULT_VALID_Msk ? 1 : 0)
N
N/**
N  * @brief Power down ADC module
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_POWER_DOWN(adc) (ADC->CR &= ~ADC_CR_ADEN_Msk)
N
N/**
N  * @brief Power on ADC module
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_POWER_ON(adc) \
Ndo { \
N  ADC->CR |= ADC_CR_ADEN_Msk; \
N  while ((!(ADC->SR & ADC_SR_INITRDY_Msk)) || (!(ADC->PWRCTL & ADC_PWRCTL_PWUPRDY_Msk))); \
N} while(0)
X#define ADC_POWER_ON(adc) do {   ADC->CR |= ADC_CR_ADEN_Msk;   while ((!(ADC->SR & ADC_SR_INITRDY_Msk)) || (!(ADC->PWRCTL & ADC_PWRCTL_PWUPRDY_Msk))); } while(0)
N
N/**
N  * @brief Configure the comparator 0 and enable it
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7
N  * @param[in] u32Condition Specifies the compare condition
N  *                     - \ref ADC_CMP_LESS_THAN
N  *                     - \ref ADC_CMP_GREATER_OR_EQUAL_TO
N  * @param[in] u32Data Specifies the compare value. Valid value are between 0 ~ 0x3FF
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(ADC, 5, ADC_CMP_GREATER_OR_EQUAL_TO, 0x800, 10);
N  *          Means ADC will assert comparator 0 flag if channel 5 conversion result is
N  *          greater or equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */
N#define ADC_ENABLE_CMP0(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (ADC->CMPR0 = ((u32ChNum) << ADC_CMPR_CMPCH_Pos) | \
N                                                                   (u32Condition) | \
N                                                                   ((u32Data) << ADC_CMPR_CMPD_Pos) | \
N                                                                   (((u32MatchCount) - 1) << ADC_CMPR_CMPMATCNT_Pos) |\
N                                                                   ADC_CMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP0(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) (ADC->CMPR0 = ((u32ChNum) << ADC_CMPR_CMPCH_Pos) |                                                                    (u32Condition) |                                                                    ((u32Data) << ADC_CMPR_CMPD_Pos) |                                                                    (((u32MatchCount) - 1) << ADC_CMPR_CMPMATCNT_Pos) |                                                                   ADC_CMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 0
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_DISABLE_CMP0(adc) (ADC->CMPR0 = 0)
N
N/**
N  * @brief Configure the comparator 1 and enable it
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7
N  * @param[in] u32Condition Specifies the compare condition
N  *                     - \ref ADC_CMP_LESS_THAN
N  *                     - \ref ADC_CMP_GREATER_OR_EQUAL_TO
N  * @param[in] u32Data Specifies the compare value. Valid value are between 0 ~ 0x3FF
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(ADC, 5, ADC_CMP_GREATER_OR_EQUAL_TO, 0x800, 10);
N  *          Means ADC will assert comparator 1 flag if channel 5 conversion result is
N  *          greater or equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */
N#define ADC_ENABLE_CMP1(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (ADC->CMPR1 = ((u32ChNum) << ADC_CMPR_CMPCH_Pos) | \
N                                                                   (u32Condition) | \
N                                                                   ((u32Data) << ADC_CMPR_CMPD_Pos) | \
N                                                                   ((u32MatchCount - 1) << ADC_CMPR_CMPMATCNT_Pos) |\
N                                                                   ADC_CMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP1(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) (ADC->CMPR1 = ((u32ChNum) << ADC_CMPR_CMPCH_Pos) |                                                                    (u32Condition) |                                                                    ((u32Data) << ADC_CMPR_CMPD_Pos) |                                                                    ((u32MatchCount - 1) << ADC_CMPR_CMPMATCNT_Pos) |                                                                   ADC_CMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 1
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_DISABLE_CMP1(adc) (ADC->CMPR1 = 0)
N
N/**
N  * @brief Set ADC input channel. Enabled channel will be converted while ADC starts.
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask  Channel enable bit. Each bit corresponds to a input channel. Bit 0 is channel 0, bit 1 is channel 1...
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_SET_INPUT_CHANNEL(adc, u32Mask) (ADC->CHEN = (ADC->CHEN & ~ADC_CHEN_Msk) | (u32Mask))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_START_CONV(adc) (ADC->CR |= ADC_CR_ADST_Msk)
N
N/**
N  * @brief Stop the A/D conversion.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_STOP_CONV(adc) (ADC->CR &= ~ADC_CR_ADST_Msk)
N
N/**
N  * @brief Set the output format in differential input mode.
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Format Differential input mode output format. Valid values are:
N  *                 - \ref ADC_DMODE_OUT_FORMAT_UNSIGNED
N  *                 - \ref ADC_DMODE_OUT_FORMAT_2COMPLEMENT
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_SET_DMOF(adc, u32Format) (ADC->CR = (ADC->CR & ~ADC_CR_DIFF_Msk) | u32Format)
N
N/**
N  * @brief Set the resolution of conversion result.
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Resolution The resolution of conversion result. Valid values are:
N  *                 - \ref ADC_RESSEL_6_BIT
N  *                 - \ref ADC_RESSEL_8_BIT
N  *                 - \ref ADC_RESSEL_10_BIT
N  *                 - \ref ADC_RESSEL_12_BIT
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_SET_RESOLUTION(adc, u32Resolution) (ADC->CR = (ADC->CR & ~ADC_CR_RESSEL_Msk) | u32Resolution)
N
N/**
N  * @brief Set the reference voltage selection.
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Ref The reference voltage selection. Valid values are:
N  *                 - \ref ADC_REFSEL_POWER
N  *                 - \ref ADC_REFSEL_INT_VREF
N  *                 - \ref ADC_REFSEL_VREF
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_SET_REF_VOLTAGE(adc, u32Ref) (ADC->CR = (ADC->CR & ~ADC_CR_REFSEL_Msk) | u32Ref)
N
N/**
N  * @brief Set power down mode.
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mode The power down mode. 0: power down mode, 2: standby mode
N  * @param[in] u32CalEn Do calibration when power up.
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_SET_POWERDOWN_MODE(adc, u32Mode, u32CalEn) \
N    ADC->PWRCTL = (ADC->PWRCTL & ~(ADC_PWRCTL_PWDMOD_Msk | ADC_PWRCTL_PWDCALEN_Msk)) \
N    | (u32Mode << ADC_PWRCTL_PWDMOD_Pos) | (u32CalEn << ADC_PWRCTL_PWDCALEN_Pos)
X#define ADC_SET_POWERDOWN_MODE(adc, u32Mode, u32CalEn)     ADC->PWRCTL = (ADC->PWRCTL & ~(ADC_PWRCTL_PWDMOD_Msk | ADC_PWRCTL_PWDCALEN_Msk))     | (u32Mode << ADC_PWRCTL_PWDMOD_Pos) | (u32CalEn << ADC_PWRCTL_PWDCALEN_Pos)
N
N/**
N  * @brief Enable PDMA transfer.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_ENABLE_PDMA(adc) (ADC->CR |= ADC_CR_PTEN_Msk)
N
N/**
N  * @brief Disable PDMA transfer.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_DISABLE_PDMA(adc) (ADC->CR &= ~ADC_CR_PTEN_Msk)
N
N/**
N  * @brief Get PDMA current transfer data
N  * @param[in] adc Base address of ADC module
N  * @return  PDMA current transfer data
N  * \hideinitializer
N  */
N#define ADC_GET_PDMA_DATA(adc) (ADC->PDMA & ADC_PDMADATA_AD_PDMA_Msk)
N
Nvoid ADC_Open(ADC_T *adc,
N              uint32_t u32InputMode,
N              uint32_t u32OpMode,
N              uint32_t u32ChMask);
Nvoid ADC_Close(ADC_T *adc);
Nvoid ADC_EnableHWTrigger(ADC_T *adc,
N                         uint32_t u32Source,
N                         uint32_t u32Param);
Nvoid ADC_DisableHWTrigger(ADC_T *adc);
Nvoid ADC_EnableTimerTrigger(ADC_T *adc,
N                            uint32_t u32Source,
N                            uint32_t u32PDMACnt);
Nvoid ADC_DisableTimerTrigger(ADC_T *adc);
Nvoid ADC_SetExtraSampleTime(ADC_T *adc,
N                            uint32_t u32ChNum,
N                            uint32_t u32SampleTime);
Nvoid ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
Nvoid ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);
N
N
N
N/*@}*/ /* end of group NANO100_ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_ADC_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2013-2014 Nuvoton Technology Corp. ***/
L 11929 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "dac.h"
L 1 "..\..\..\..\Library\StdDriver\inc\dac.h" 1
N/**************************************************************************//**
N * @file     dac.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 14/09/08 12:31p $
N * @brief    NANO100 series DAC driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __DAC_H__
N#define __DAC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_DAC_Driver DAC Driver
N  @{
N*/
N
N
N/** @addtogroup NANO100_DAC_EXPORTED_CONSTANTS DAC Exported Constants
N  @{
N*/
N#define DAC_WRITE_DAT_TRIGGER  (0UL << DAC_CTL_DACLSEL_Pos)   ///< Write DACx_DAT trigger  \hideinitializer
N#define DAC_PDMA_TRIGGER       (1UL << DAC_CTL_DACLSEL_Pos)   ///< PDMA trigger \hideinitializer
N#define DAC_TIMER0_TRIGGER     (2UL << DAC_CTL_DACLSEL_Pos)   ///< Timer 0 trigger \hideinitializer
N#define DAC_TIMER1_TRIGGER     (3UL << DAC_CTL_DACLSEL_Pos)   ///< Timer 1 trigger \hideinitializer
N#define DAC_TIMER2_TRIGGER     (4UL << DAC_CTL_DACLSEL_Pos)   ///< Timer 2 trigger \hideinitializer
N#define DAC_TIMER3_TRIGGER     (5UL << DAC_CTL_DACLSEL_Pos)   ///< Timer 3 trigger \hideinitializer
N
N#define DAC_REFSEL_POWER       (0UL << DAC_COMCTL_REFSEL_Pos)  ///< DAC reference voltage source selection set to power  \hideinitializer
N#define DAC_REFSEL_INT_VREF    (1UL << DAC_COMCTL_REFSEL_Pos)  ///< DAC reference voltage source selection set to Int_VREF  \hideinitializer
N#define DAC_REFSEL_VREF        (2UL << DAC_COMCTL_REFSEL_Pos)  ///< DAC reference voltage source selection set to VREF  \hideinitializer
N
N/*@}*/ /* end of group NANO100_DAC_EXPORTED_CONSTANTS */
N
N
N
N/** @addtogroup NANO100_DAC_EXPORTED_FUNCTIONS DAC Exported Functions
N  @{
N*/
N
N/**
N  * @brief Write data for conversion.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch DAC channel number, could be 0 or 1
N  * @param[in] u32Data Decides the data for conversion, valid range are between 0~0xFFF.
N  * @return None
N  * \hideinitializer
N  */
N#define DAC_WRITE_DATA(dac, u32Ch, u32Data) do {\
N                                                if(u32Ch) {\
N                                                    DAC->DATA1 = u32Data;\
N                                                } else {\
N                                                    DAC->DATA0 = u32Data;\
N                                                }\
N                                            }while(0)
X#define DAC_WRITE_DATA(dac, u32Ch, u32Data) do {                                                if(u32Ch) {                                                    DAC->DATA1 = u32Data;                                                } else {                                                    DAC->DATA0 = u32Data;                                                }                                            }while(0)
N
N
N/**
N  * @brief Enable DAC group mode
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * \hideinitializer
N  */
N#define DAC_ENABLE_GROUP_MODE(dac) (DAC->COMCTL |= DAC_COMCTL_DAC01GRP_Msk)
N
N/**
N  * @brief Disable DAC group mode
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * \hideinitializer
N  */
N#define DAC_DISABLE_GROUP_MODE(dac) (DAC->COMCTL &= ~DAC_COMCTL_DAC01GRP_Msk)
N
N/**
N  * @brief Get the busy state of DAC.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch DAC channel number, could be 0 or 1
N  * @return If DAC is able to convert or not.
N  * @retval 0 DAC is in idle state.
N  * @retval 1 DAC is in busy state, or DAC is not in ready state.
N  * @details If this macro returns 1, DAC is \b not in ready state. Ether DAC is busy or not in ready state.
N  * \hideinitializer
N  */
N#define DAC_IS_BUSY(dac, u32Ch) (inp32(DAC_BASE + 0x8 + 0x10 * (u32Ch)) & DAC_STS_BUSY_Msk ? 1 : 0)
N
N
N/**
N  * @brief Get the interrupt flag of specified channel.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch DAC channel number, could be 0 or 1
N  * @return Returns the interrupt flag of selected channel.
N  * @retval 0 DAC interrupt flag is not set.
N  * @retval 1 DAC interrupt flag is set.
N  * \hideinitializer
N  */
N#define DAC_GET_INT_FLAG(dac, u32Ch) (inp32(DAC_BASE + 0x8 + 0x10 * (u32Ch)) & DAC_STS_DACIFG_Msk ? 1 : 0)
N
N/**
N  * @brief This macro clear the interrupt status bit of specified channel.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch DAC channel number, could be 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define DAC_CLR_INT_FLAG(dac, u32Ch) do {\
N                                         if(u32Ch)\
N                                             DAC->STS1 = DAC_STS_DACIFG_Msk;\
N                                         else\
N                                             DAC->STS0 = DAC_STS_DACIFG_Msk;\
N                                     }while(0)
X#define DAC_CLR_INT_FLAG(dac, u32Ch) do {                                         if(u32Ch)                                             DAC->STS1 = DAC_STS_DACIFG_Msk;                                         else                                             DAC->STS0 = DAC_STS_DACIFG_Msk;                                     }while(0)
N
N
N/**
N  * @brief Set the DAC reference voltage. This setting affects both DAC channel
N  * @param[in] dac Base address of DAC module
N  * @param[in] u32Ref The reference voltage selection. Valid values are:
N  *                 - \ref DAC_REFSEL_POWER
N  *                 - \ref DAC_REFSEL_INT_VREF
N  *                 - \ref DAC_REFSEL_VREF
N  * @return None
N  * \hideinitializer
N  */
N#define DAC_SET_REF_VOLTAGE(dac, u32Ref) (DAC->COMCTL = ((DAC->COMCTL) & ~DAC_COMCTL_REFSEL_Msk) | u32Ref)
N
N/**
N  * @brief This macro enable the interrupt of specified channel.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch DAC channel number, could be 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define DAC_ENABLE_INT(dac, u32Ch) do {\
N                                       if(u32Ch)\
N                                           DAC->CTL1 |= DAC_CTL_DACIE_Msk;\
N                                       else\
N                                           DAC->CTL0 |= DAC_CTL_DACIE_Msk;\
N                                   }while(0)
X#define DAC_ENABLE_INT(dac, u32Ch) do {                                       if(u32Ch)                                           DAC->CTL1 |= DAC_CTL_DACIE_Msk;                                       else                                           DAC->CTL0 |= DAC_CTL_DACIE_Msk;                                   }while(0)
N
N/**
N  * @brief This macro disable the interrupt of specified channel.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch DAC channel number, could be 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define DAC_DISABLE_INT(dac, u32Ch) do {\
N                                        if(u32Ch)\
N                                            DAC->CTL1 &= ~DAC_CTL_DACIE_Msk;\
N                                        else\
N                                            DAC->CTL0 &= ~DAC_CTL_DACIE_Msk;\
N                                    }while(0)
X#define DAC_DISABLE_INT(dac, u32Ch) do {                                        if(u32Ch)                                            DAC->CTL1 &= ~DAC_CTL_DACIE_Msk;                                        else                                            DAC->CTL0 &= ~DAC_CTL_DACIE_Msk;                                    }while(0)
N
Nvoid DAC_Open(DAC_T *dac, uint32_t u32Ch, uint32_t u32TrgSrc);
Nvoid DAC_Close(DAC_T *dac, uint32_t u32Ch);
Nint DAC_SetDelayTime(DAC_T *dac, uint32_t u32Delay);
N
N/*@}*/ /* end of group NANO100_DAC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_DAC_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__DAC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11930 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "fmc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\fmc.h" 1
N/**************************************************************************//**
N * @file     fmc.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 15/06/12 2:11p $
N * @brief    Nano100B Series Flash Memory Controller Driver Header File
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_FMC_Driver FMC Driver
N  @{
N*/
N
N
N/** @addtogroup NANO100_FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM Base Address          */
N#define FMC_APROM_END           0x0001EC00UL    /*!< APROM End Address           */
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM Base Address          */
N#define FMC_LDROM_END           0x00101000UL    /*!< LDROM End Address           */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< User Configuration Address  */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 bytes) */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4 Kbytes)       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ         0x00            /*!< ISP Command: Read flash word         */
N#define FMC_ISPCMD_PROGRAM      0x21            /*!< ISP Command: Write flash word        */
N#define FMC_ISPCMD_PAGE_ERASE   0x22            /*!< ISP Command: Page Erase Flash        */
N#define FMC_ISPCMD_READ_CID     0x0B            /*!< ISP Command: Read Company ID         */
N#define FMC_ISPCMD_READ_PID     0x0C            /*!< ISP Command: Read Product ID         */
N#define FMC_ISPCMD_READ_UID     0x04            /*!< ISP Command: Read Unique ID          */
N#define FMC_ISPCMD_VECMAP       0x2E            /*!< ISP Command: Vector Page Remap       */
N
N#define IS_BOOT_FROM_APROM      0               /*!< Is booting from APROM                */
N#define IS_BOOT_FROM_LDROM      1               /*!< Is booting from LDROM                */
N
N
N/*@}*/ /* end of group NANO100_FMC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Macros                                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N  * @brief This macro selects booting from APROM.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_SET_APROM_BOOT()        (FMC->ISPCON &= ~FMC_ISPCON_BS_Msk)
N
N/**
N  * @brief This macro selects booting from LDROM.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_SET_LDROM_BOOT()        (FMC->ISPCON |= FMC_ISPCON_BS_Msk)
N
N/**
N  * @brief This macro enables APROM update function.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_ENABLE_AP_UPDATE()      (FMC->ISPCON |=  FMC_ISPCON_APUEN_Msk)
N
N/**
N  * @brief This macro disables APROM update function.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_DISABLE_AP_UPDATE()     (FMC->ISPCON &= ~FMC_ISPCON_APUEN_Msk)
N
N/**
N  * @brief This macro enables User Configuration update function.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_ENABLE_CFG_UPDATE()     (FMC->ISPCON |=  FMC_ISPCON_CFGUEN_Msk)
N
N/**
N  * @brief This macro disables User Configuration update function.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_DISABLE_CFG_UPDATE()    (FMC->ISPCON &= ~FMC_ISPCON_CFGUEN_Msk)
N
N/**
N  * @brief This macro enables LDROM update function.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_ENABLE_LD_UPDATE()      (FMC->ISPCON |=  FMC_ISPCON_LDUEN_Msk)
N
N/**
N  * @brief This macro disables LDROM update function.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_DISABLE_LD_UPDATE()     (FMC->ISPCON &= ~FMC_ISPCON_LDUEN_Msk)
N
N/**
N  * @brief This macro enables ISP function.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_ENABLE_ISP()            (FMC->ISPCON |=  FMC_ISPCON_ISPEN_Msk)
N
N/**
N  * @brief This macro disables ISP function.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_DISABLE_ISP()           (FMC->ISPCON &= ~FMC_ISPCON_ISPEN_Msk)
N
N/**
N  * @brief This macro gets ISP fail flag value.
N  * @param None
N  * @return ISP fail flag value.
N  * \hideinitializer
N  */
N#define FMC_GET_FAIL_FLAG()         ((FMC->ISPCON & FMC_ISPCON_ISPFF_Msk) ? 1 : 0)
N
N/**
N  * @brief This macro clears ISP fail flag.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define FMC_CLR_FAIL_FLAG()         (FMC->ISPCON |= FMC_ISPCON_ISPFF_Msk)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Functions                                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N
Nextern void FMC_Close(void);
Nextern int32_t FMC_Erase(uint32_t u32PageAddr);
Nextern int32_t FMC_GetBootSource(void);
Nextern void FMC_Open(void);
Nextern uint32_t FMC_Read(uint32_t u32Addr);
Nextern uint32_t FMC_ReadCID(void);
Nextern uint32_t FMC_ReadPID(void);
Nextern uint32_t FMC_ReadUCID(uint32_t u32Index);
Nextern uint32_t FMC_ReadUID(uint32_t u32Index);
Nextern uint32_t FMC_ReadDataFlashBaseAddr(void);
Nextern void FMC_SetVectorPageAddr(uint32_t u32PageAddr);
Nextern uint32_t FMC_GetVectorPageAddr(void);
Nextern void FMC_Write(uint32_t u32Addr, uint32_t u32Data);
Nextern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
N
N
N/*@}*/ /* end of group NANO100_FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_FMC_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif   // __FMC_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11931 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "ebi.h"
L 1 "..\..\..\..\Library\StdDriver\inc\ebi.h" 1
N/**************************************************************************//**
N * @file     ebi.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 14/09/30 4:21p $
N * @brief    Nano100 Series Flash Memory Controller Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __EBI_H__
N#define __EBI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_EBI_Driver EBI Driver
N  @{
N*/
N
N
N/** @addtogroup NANO100_EBI_EXPORTED_CONSTANTS EBI Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Base Address                                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BASE_ADDR           0x60000000      /*!< EBI base address            */
N#define EBI_MAX_SIZE            0x20000         /*!< Maximum size of EBI bank    */
N#define EBI_TIMEOUT_COUNT       0x10000         /*!< Time-out value              */
N
N/* Constants for EBI data bus width */
N#define EBI_BUSWIDTH_8BIT       8               /*!< EBI bus width is 8-bit      */
N#define EBI_BUSWIDTH_16BIT      16              /*!< EBI bus width is 16-bit     */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  EBI MCLK divider                                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_MCLKDIV_1         0               /*!< MCLK divided by 1           */
N#define EBI_MCLKDIV_2         1               /*!< MCLK divided by 2           */
N#define EBI_MCLKDIV_4         2               /*!< MCLK divided by 4           */
N#define EBI_MCLKDIV_8         3               /*!< MCLK divided by 8           */
N#define EBI_MCLKDIV_16        4               /*!< MCLK divided by 16          */
N#define EBI_MCLKDIV_32        5               /*!< MCLK divided by 32          */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  EBI timing setting                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_TIMING_FASTEST      0x0             /*!< EBI timing is the fastest   */
N#define EBI_TIMING_VERYFAST     0x1             /*!< EBI timing is the very fast */
N#define EBI_TIMING_FAST         0x2             /*!< EBI timing is the fast      */
N#define EBI_TIMING_NORMAL       0x3             /*!< EBI timing is the normal    */
N#define EBI_TIMING_SLOW         0x4             /*!< EBI timing is the slow      */
N#define EBI_TIMING_VERYSLOW     0x5             /*!< EBI timing is the very slow */
N#define EBI_TIMING_SLOWEST      0x6             /*!< EBI timing is the slowest   */
N
N
N/*@}*/ /* end of group NANO100_EBI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_EBI_EXPORTED_FUNCTIONS EBI Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  EBI access macros                                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N  * @brief Read one byte data from EBI.
N  * @param[in] Addr EBI offset address.
N  * @return Byte data read from EBI.
N  * \hideinitializer
N  */
N#define EBI_READ_DATA8(Addr)            *((volatile unsigned char *)(EBI_BASE_ADDR+Addr))
N
N/**
N  * @brief Write one byte data to EBI.
N  * @param[in] Addr EBI offset address.
N  * @param[in] Data Byte data to be written.
N  * @return None
N  * \hideinitializer
N  */
N#define EBI_WRITE_DATA8(Addr, Data)     *((volatile unsigned char *)(EBI_BASE_ADDR+Addr))=Data
N
N/**
N  * @brief Read a half-word data from EBI.
N  * @param[in] Addr EBI offset address.
N  * @return Half-word data read from EBI.
N  * \hideinitializer
N  */
N#define EBI_READ_DATA16(Addr)           *((volatile unsigned short *)(EBI_BASE_ADDR+Addr))
N
N/**
N  * @brief Write a half-word data to EBI.
N  * @param[in] Addr EBI offset address.
N  * @param[in] Data Half-word data to be written.
N  * @return None
N  * \hideinitializer
N  */
N#define EBI_WRITE_DATA16(Addr, Data)    *((volatile unsigned short *)(EBI_BASE_ADDR+Addr))=Data
N
N/**
N  * @brief Read a word data from EBI.
N  * @param[in] Addr EBI offset address.
N  * @return Word data read from EBI.
N  * \hideinitializer
N  */
N#define EBI_READ_DATA32(Addr)           *((volatile unsigned int *)(EBI_BASE_ADDR+Addr))
N
N/**
N  * @brief Write a word data to EBI.
N  * @param[in] Addr EBI offset address.
N  * @param[in] Data Word data to be written.
N  * @return None
N  * \hideinitializer
N  */
N#define EBI_WRITE_DATA32(Addr, Data)    *((volatile unsigned int *)(EBI_BASE_ADDR+Addr))=Data
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Functions                                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N
Nvoid EBI_Open(uint32_t u32Bank, uint32_t u32DataWidth, uint32_t u32TimingClass, uint32_t u32BusMode, uint32_t u32CSActiveLevel);
Nvoid EBI_Close(uint8_t u32Bank);
Nvoid EBI_SetBusTiming(uint32_t u32Bank, uint32_t u32TimingConfig, uint32_t u32MclkDiv);
N
N
N/*@}*/ /* end of group NANO100_EBI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_EBI_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif   // __EBI_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11932 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "gpio.h"
L 1 "..\..\..\..\Library\StdDriver\inc\gpio.h" 1
N/**************************************************************************//**
N * @file     gpio.h
N * @version  V1.00
N * $Revision: 7 $
N * $Date: 14/12/01 10:30a $
N * @brief    Nano100 series GPIO driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup NANO100_GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N#define GPIO_PIN_MAX    16   /*!< Specify Maximum Pins of Each GPIO Port */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_PMD_INPUT              0x0UL                  /*!< Input Mode */
N#define GPIO_PMD_OUTPUT             0x1UL                  /*!< Output Mode */
N#define GPIO_PMD_OPEN_DRAIN         0x2UL                  /*!< Open-Drain Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING             0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING            0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE          0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH               0x01010000UL /*!< Interrupt enable by Level-High */
N#define GPIO_INT_LOW                0x01000001UL /*!< Interrupt enable by Level-Level */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IMD_EDGE               0UL               /*!< IMD Setting for Edge Trigger Mode */
N#define GPIO_IMD_LEVEL              1UL               /*!< IMD Setting for Edge Level Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_ICLK_ON           0x00000020UL /*!< DBNCECON setting for all IO pins edge detection circuit is always active after reset */
N#define GPIO_ICLK_OFF          0x00000000UL /*!< DBNCECON setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */
N
N#define GPIO_DBCLKSRC_IRC10K   0x00000010UL /*!< DBNCECON setting for de-bounce counter clock source is the internal 10 kHz */
N#define GPIO_DBCLKSRC_HCLK     0x00000000UL /*!< DBNCECON setting for de-bounce counter clock source is the internal HCLK */
N
N#define GPIO_DBCLKSEL_1        0x00000000UL /*!< DBNCECON setting for sampling cycle = 1 clocks */
N#define GPIO_DBCLKSEL_2        0x00000001UL /*!< DBNCECON setting for sampling cycle = 2 clocks */
N#define GPIO_DBCLKSEL_4        0x00000002UL /*!< DBNCECON setting for sampling cycle = 4 clocks */
N#define GPIO_DBCLKSEL_8        0x00000003UL /*!< DBNCECON setting for sampling cycle = 8 clocks */
N#define GPIO_DBCLKSEL_16       0x00000004UL /*!< DBNCECON setting for sampling cycle = 16 clocks */
N#define GPIO_DBCLKSEL_32       0x00000005UL /*!< DBNCECON setting for sampling cycle = 32 clocks */
N#define GPIO_DBCLKSEL_64       0x00000006UL /*!< DBNCECON setting for sampling cycle = 64 clocks */
N#define GPIO_DBCLKSEL_128      0x00000007UL /*!< DBNCECON setting for sampling cycle = 128 clocks */
N#define GPIO_DBCLKSEL_256      0x00000008UL /*!< DBNCECON setting for sampling cycle = 256 clocks */
N#define GPIO_DBCLKSEL_512      0x00000009UL /*!< DBNCECON setting for sampling cycle = 512 clocks */
N#define GPIO_DBCLKSEL_1024     0x0000000AUL /*!< DBNCECON setting for sampling cycle = 1024 clocks */
N#define GPIO_DBCLKSEL_2048     0x0000000BUL /*!< DBNCECON setting for sampling cycle = 2048 clocks */
N#define GPIO_DBCLKSEL_4096     0x0000000CUL /*!< DBNCECON setting for sampling cycle = 4096 clocks */
N#define GPIO_DBCLKSEL_8192     0x0000000DUL /*!< DBNCECON setting for sampling cycle = 8192 clocks */
N#define GPIO_DBCLKSEL_16384    0x0000000EUL /*!< DBNCECON setting for sampling cycle = 16384 clocks */
N#define GPIO_DBCLKSEL_32768    0x0000000FUL /*!< DBNCECON setting for sampling cycle = 32768 clocks */
N
N/** Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N *  Example 1:
N *
N *      PA0 = 1;
N *
N *  It is used to set PA0 to high;
N *
N *  Example 2:
N *
N *      if (PA0)
N *          PA0 = 0;
N *
N *  If PA0 pin status is high, then set PA0 data output to low.
N */
N#define GPIO_PIN_ADDR(port, pin)    (*((volatile uint32_t *)((GPIO_PIN_DATA_BASE+(0x40*(port))) + ((pin)<<2))))
N#define PA0             GPIO_PIN_ADDR(0, 0)  /*!< Specify PA0 Pin Data Input/Output */
N#define PA1             GPIO_PIN_ADDR(0, 1)  /*!< Specify PA1 Pin Data Input/Output */
N#define PA2             GPIO_PIN_ADDR(0, 2)  /*!< Specify PA2 Pin Data Input/Output */
N#define PA3             GPIO_PIN_ADDR(0, 3)  /*!< Specify PA3 Pin Data Input/Output */
N#define PA4             GPIO_PIN_ADDR(0, 4)  /*!< Specify PA4 Pin Data Input/Output */
N#define PA5             GPIO_PIN_ADDR(0, 5)  /*!< Specify PA5 Pin Data Input/Output */
N#define PA6             GPIO_PIN_ADDR(0, 6)  /*!< Specify PA6 Pin Data Input/Output */
N#define PA7             GPIO_PIN_ADDR(0, 7)  /*!< Specify PA7 Pin Data Input/Output */
N#define PA8             GPIO_PIN_ADDR(0, 8)  /*!< Specify PA8 Pin Data Input/Output */
N#define PA9             GPIO_PIN_ADDR(0, 9)  /*!< Specify PA9 Pin Data Input/Output */
N#define PA10            GPIO_PIN_ADDR(0, 10) /*!< Specify PA10 Pin Data Input/Output */
N#define PA11            GPIO_PIN_ADDR(0, 11) /*!< Specify PA11 Pin Data Input/Output */
N#define PA12            GPIO_PIN_ADDR(0, 12) /*!< Specify PA12 Pin Data Input/Output */
N#define PA13            GPIO_PIN_ADDR(0, 13) /*!< Specify PA13 Pin Data Input/Output */
N#define PA14            GPIO_PIN_ADDR(0, 14) /*!< Specify PA14 Pin Data Input/Output */
N#define PA15            GPIO_PIN_ADDR(0, 15) /*!< Specify PA15 Pin Data Input/Output */
N
N#define PB0             GPIO_PIN_ADDR(1, 0)  /*!< Specify PB0 Pin Data Input/Output */
N#define PB1             GPIO_PIN_ADDR(1, 1)  /*!< Specify PB1 Pin Data Input/Output */
N#define PB2             GPIO_PIN_ADDR(1, 2)  /*!< Specify PB2 Pin Data Input/Output */
N#define PB3             GPIO_PIN_ADDR(1, 3)  /*!< Specify PB3 Pin Data Input/Output */
N#define PB4             GPIO_PIN_ADDR(1, 4)  /*!< Specify PB4 Pin Data Input/Output */
N#define PB5             GPIO_PIN_ADDR(1, 5)  /*!< Specify PB5 Pin Data Input/Output */
N#define PB6             GPIO_PIN_ADDR(1, 6)  /*!< Specify PB6 Pin Data Input/Output */
N#define PB7             GPIO_PIN_ADDR(1, 7)  /*!< Specify PB7 Pin Data Input/Output */
N#define PB8             GPIO_PIN_ADDR(1, 8)  /*!< Specify PB8 Pin Data Input/Output */
N#define PB9             GPIO_PIN_ADDR(1, 9)  /*!< Specify PB9 Pin Data Input/Output */
N#define PB10            GPIO_PIN_ADDR(1, 10) /*!< Specify PB10 Pin Data Input/Output */
N#define PB11            GPIO_PIN_ADDR(1, 11) /*!< Specify PB11 Pin Data Input/Output */
N#define PB12            GPIO_PIN_ADDR(1, 12) /*!< Specify PB12 Pin Data Input/Output */
N#define PB13            GPIO_PIN_ADDR(1, 13) /*!< Specify PB13 Pin Data Input/Output */
N#define PB14            GPIO_PIN_ADDR(1, 14) /*!< Specify PB14 Pin Data Input/Output */
N#define PB15            GPIO_PIN_ADDR(1, 15) /*!< Specify PB15 Pin Data Input/Output */
N
N#define PC0             GPIO_PIN_ADDR(2, 0)  /*!< Specify PC0 Pin Data Input/Output */
N#define PC1             GPIO_PIN_ADDR(2, 1)  /*!< Specify PC1 Pin Data Input/Output */
N#define PC2             GPIO_PIN_ADDR(2, 2)  /*!< Specify PC2 Pin Data Input/Output */
N#define PC3             GPIO_PIN_ADDR(2, 3)  /*!< Specify PC3 Pin Data Input/Output */
N#define PC4             GPIO_PIN_ADDR(2, 4)  /*!< Specify PC4 Pin Data Input/Output */
N#define PC5             GPIO_PIN_ADDR(2, 5)  /*!< Specify PC5 Pin Data Input/Output */
N#define PC6             GPIO_PIN_ADDR(2, 6)  /*!< Specify PC6 Pin Data Input/Output */
N#define PC7             GPIO_PIN_ADDR(2, 7)  /*!< Specify PC7 Pin Data Input/Output */
N#define PC8             GPIO_PIN_ADDR(2, 8)  /*!< Specify PC8 Pin Data Input/Output */
N#define PC9             GPIO_PIN_ADDR(2, 9)  /*!< Specify PC9 Pin Data Input/Output */
N#define PC10            GPIO_PIN_ADDR(2, 10) /*!< Specify PC10 Pin Data Input/Output */
N#define PC11            GPIO_PIN_ADDR(2, 11) /*!< Specify PC11 Pin Data Input/Output */
N#define PC12            GPIO_PIN_ADDR(2, 12) /*!< Specify PC12 Pin Data Input/Output */
N#define PC13            GPIO_PIN_ADDR(2, 13) /*!< Specify PC13 Pin Data Input/Output */
N#define PC14            GPIO_PIN_ADDR(2, 14) /*!< Specify PC14 Pin Data Input/Output */
N#define PC15            GPIO_PIN_ADDR(2, 15) /*!< Specify PC15 Pin Data Input/Output */
N
N#define PD0             GPIO_PIN_ADDR(3, 0)  /*!< Specify PD0 Pin Data Input/Output */
N#define PD1             GPIO_PIN_ADDR(3, 1)  /*!< Specify PD1 Pin Data Input/Output */
N#define PD2             GPIO_PIN_ADDR(3, 2)  /*!< Specify PD2 Pin Data Input/Output */
N#define PD3             GPIO_PIN_ADDR(3, 3)  /*!< Specify PD3 Pin Data Input/Output */
N#define PD4             GPIO_PIN_ADDR(3, 4)  /*!< Specify PD4 Pin Data Input/Output */
N#define PD5             GPIO_PIN_ADDR(3, 5)  /*!< Specify PD5 Pin Data Input/Output */
N#define PD6             GPIO_PIN_ADDR(3, 6)  /*!< Specify PD6 Pin Data Input/Output */
N#define PD7             GPIO_PIN_ADDR(3, 7)  /*!< Specify PD7 Pin Data Input/Output */
N#define PD8             GPIO_PIN_ADDR(3, 8)  /*!< Specify PD8 Pin Data Input/Output */
N#define PD9             GPIO_PIN_ADDR(3, 9)  /*!< Specify PD9 Pin Data Input/Output */
N#define PD10            GPIO_PIN_ADDR(3, 10) /*!< Specify PD10 Pin Data Input/Output */
N#define PD11            GPIO_PIN_ADDR(3, 11) /*!< Specify PD11 Pin Data Input/Output */
N#define PD12            GPIO_PIN_ADDR(3, 12) /*!< Specify PD12 Pin Data Input/Output */
N#define PD13            GPIO_PIN_ADDR(3, 13) /*!< Specify PD13 Pin Data Input/Output */
N#define PD14            GPIO_PIN_ADDR(3, 14) /*!< Specify PD14 Pin Data Input/Output */
N#define PD15            GPIO_PIN_ADDR(3, 15) /*!< Specify PD15 Pin Data Input/Output */
N
N#define PE0             GPIO_PIN_ADDR(4, 0)  /*!< Specify PE0 Pin Data Input/Output */
N#define PE1             GPIO_PIN_ADDR(4, 1)  /*!< Specify PE1 Pin Data Input/Output */
N#define PE2             GPIO_PIN_ADDR(4, 2)  /*!< Specify PE2 Pin Data Input/Output */
N#define PE3             GPIO_PIN_ADDR(4, 3)  /*!< Specify PE3 Pin Data Input/Output */
N#define PE4             GPIO_PIN_ADDR(4, 4)  /*!< Specify PE4 Pin Data Input/Output */
N#define PE5             GPIO_PIN_ADDR(4, 5)  /*!< Specify PE5 Pin Data Input/Output */
N#define PE6             GPIO_PIN_ADDR(4, 6)  /*!< Specify PE6 Pin Data Input/Output */
N#define PE7             GPIO_PIN_ADDR(4, 7)  /*!< Specify PE7 Pin Data Input/Output */
N#define PE8             GPIO_PIN_ADDR(4, 8)  /*!< Specify PE8 Pin Data Input/Output */
N#define PE9             GPIO_PIN_ADDR(4, 9)  /*!< Specify PE9 Pin Data Input/Output */
N#define PE10            GPIO_PIN_ADDR(4, 10) /*!< Specify PE10 Pin Data Input/Output */
N#define PE11            GPIO_PIN_ADDR(4, 11) /*!< Specify PE11 Pin Data Input/Output */
N#define PE12            GPIO_PIN_ADDR(4, 12) /*!< Specify PE12 Pin Data Input/Output */
N#define PE13            GPIO_PIN_ADDR(4, 13) /*!< Specify PE13 Pin Data Input/Output */
N#define PE14            GPIO_PIN_ADDR(4, 14) /*!< Specify PE14 Pin Data Input/Output */
N#define PE15            GPIO_PIN_ADDR(4, 15) /*!< Specify PE15 Pin Data Input/Output */
N
N#define PF0             GPIO_PIN_ADDR(5, 0)  /*!< Specify PF0 Pin Data Input/Output */
N#define PF1             GPIO_PIN_ADDR(5, 1)  /*!< Specify PF1 Pin Data Input/Output */
N#define PF2             GPIO_PIN_ADDR(5, 2)  /*!< Specify PF2 Pin Data Input/Output */
N#define PF3             GPIO_PIN_ADDR(5, 3)  /*!< Specify PF3 Pin Data Input/Output */
N#define PF4             GPIO_PIN_ADDR(5, 4)  /*!< Specify PF4 Pin Data Input/Output */
N#define PF5             GPIO_PIN_ADDR(5, 5)  /*!< Specify PF5 Pin Data Input/Output */
N
N/*@}*/ /* end of group NANO100_GPIO_EXPORTED_CONSTANTS */
N
N/** @addtogroup NANO100_GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(gpio, u32PinMask)   ((gpio)->ISRC = u32PinMask)
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(gpio, u32PinMask)   ((gpio)->DBEN &= ~u32PinMask)
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(gpio, u32PinMask)    ((gpio)->DBEN |= u32PinMask)
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(gpio, u32PinMask)   ((gpio)->OFFD |= (u32PinMask << 16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(gpio, u32PinMask)    ((gpio)->OFFD &= ~(u32PinMask << 16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(gpio, u32PinMask)   ((gpio)->DMASK &= ~u32PinMask)
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(gpio, u32PinMask)    ((gpio)->DMASK |= u32PinMask)
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(gpio, u32PinMask)   ((gpio)->ISRC & u32PinMask)
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   u32ClkSrc   The de-bounce counter clock source. It could be \ref GPIO_DBCLKSRC_HCLK or \ref GPIO_DBCLKSRC_IRC10K
N * @param[in]   u32ClkSel   The de-bounce sampling cycle selection. It could be \n
N *                          \ref GPIO_DBCLKSEL_1, \ref GPIO_DBCLKSEL_2, \ref GPIO_DBCLKSEL_4, \ref GPIO_DBCLKSEL_8, \n
N *                          \ref GPIO_DBCLKSEL_16, \ref GPIO_DBCLKSEL_32, \ref GPIO_DBCLKSEL_64, \ref GPIO_DBCLKSEL_128, \n
N *                          \ref GPIO_DBCLKSEL_256, \ref GPIO_DBCLKSEL_512, \ref GPIO_DBCLKSEL_1024, \ref GPIO_DBCLKSEL_2048, \n
N *                          \ref GPIO_DBCLKSEL_4096, \ref GPIO_DBCLKSEL_8192, \ref GPIO_DBCLKSEL_16384, \ref GPIO_DBCLKSEL_32768
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: \ref GPIO_SET_DEBOUNCE_TIME(\ref GPIO_DBCLKSRC_IRC10K, \ref GPIO_DBCLKSEL_4) \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (2^4)*(1/(10*1000)) s = 16*0.0001 s = 1600 us,
N *              and system will sampling interrupt input once per 1600 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(u32ClkSrc, u32ClkSel)  (GPIO->DBNCECON = (GP_DBNCECON_DBCLK_ON_Msk | u32ClkSrc | u32ClkSel))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N *
N * @retval      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(gpio)   ((gpio)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32Data     GPIO port data
N *
N * @retval      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(gpio, u32Data)   ((gpio)->DOUT = (u32Data))
N
N/**
N * @brief       Disable Pin Pull-up resistor Function
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @return      None
N *
N * @details     Disable the Pull-up resistor function of specified GPIO pin.
N */
N#define GPIO_DISABLE_PULL_UP(gpio, u32PinMask)   ((gpio)->PUEN &= ~u32PinMask)
N
N/**
N * @brief       Enable Pin Pull-up resistor Function
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port
N *
N * @return      None
N *
N * @details     Enable the Pull-up resistor function of specified GPIO pin.
N */
N#define GPIO_ENABLE_PULL_UP(gpio, u32PinMask)    ((gpio)->PUEN |= u32PinMask)
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin       Pxy
N *
N * @retval      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin)   ((u32Pin) ^= 1)
N
N/**
N * @brief       Enable External GPIO interrupt 0
N *
N * @param[in]   gpio            GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32Pin          The pin of specified GPIO port
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              \ref GPIO_INT_RISING, \ref GPIO_INT_FALLING, \ref GPIO_INT_BOTH_EDGE, \ref GPIO_INT_HIGH, \ref GPIO_INT_LOW
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT0    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO interrupt 0
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 15
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT0   GPIO_DisableInt
N
N
N/**
N * @brief       Enable External GPIO interrupt 1
N *
N * @param[in]   gpio            GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32Pin          The pin of specified GPIO port
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              \ref GPIO_INT_RISING, \ref GPIO_INT_FALLING, \ref GPIO_INT_BOTH_EDGE, \ref GPIO_INT_HIGH, \ref GPIO_INT_LOW
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT1    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO interrupt 1
N *
N * @param[in]   gpio        GPIO port. It could be \ref PA, \ref PB, \ref PC, \ref PD, \ref PE or \ref PF
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 15
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT1   GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *gpio, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *gpio, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *gpio, uint32_t u32Pin);
N
N
N
N/*@}*/ /* end of group NANO100_GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_GPIO_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11933 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "i2c.h"
L 1 "..\..\..\..\Library\StdDriver\inc\i2c.h" 1
N/****************************************************************************//**
N * @file     i2c.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 15/06/05 5:06p $
N * @brief    Nano100 series I2C driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_I2C_Driver I2C Driver
N  @{
N*/
N
N/** @addtogroup NANO100_I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N#define I2C_STA 0x08    /*!< I2C START bit value */
N#define I2C_STO 0x04    /*!< I2C STOP bit value*/
N#define I2C_SI  0x10    /*!< I2C SI bit value */
N#define I2C_AA  0x02    /*!< I2C ACK bit value */
N
N#define I2C_GCMODE_ENABLE   1    /*!< Enable I2C GC Mode */
N#define I2C_GCMODE_DISABLE  0    /*!< Disable I2C GC Mode */
N
N/*@}*/ /* end of group NANO100_I2C_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro sets the I2C control register at one time.
N  * @param[in] i2c is the base address of I2C module.
N  * @param[in] u8Ctrl is the register value of I2C control register.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ( (i2c)->CON = ((i2c)->CON & ~0x1e) | u8Ctrl )
N
N/**
N  * @brief This macro only set START bit to the control register of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_START(i2c) ( (i2c)->CON = ((i2c)->CON & ~I2C_CON_I2C_STS_Msk) | I2C_CON_START_Msk )
N
N/**
N  * @brief This macro only set STOP bit to the control register of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  * \hideinitializer
N  */
Nstatic __INLINE void I2C_STOP(I2C_T *i2c)
Xstatic __inline void I2C_STOP(I2C_T *i2c)
N{
N    i2c->CON |= (I2C_CON_I2C_STS_Msk | I2C_CON_STOP_Msk);
X    i2c->CON |= ((0x1ul << (4)) | (0x1ul << (2)));
N    while(i2c->CON & I2C_CON_STOP_Msk);
X    while(i2c->CON & (0x1ul << (2)));
N}
N
N/**
N  * @brief This macro will return when I2C module is ready.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  * \hideinitializer
N  */
Nstatic __INLINE void I2C_WAIT_READY(I2C_T *i2c)
Xstatic __inline void I2C_WAIT_READY(I2C_T *i2c)
N{
N    while(!(i2c->INTSTS & I2C_INTSTS_INTSTS_Msk));
X    while(!(i2c->INTSTS & (0x1ul << (0))));
N    i2c->INTSTS |= I2C_INTSTS_INTSTS_Msk;
X    i2c->INTSTS |= (0x1ul << (0));
N}
N
N/**
N  * @brief This macro returns the data stored in data register of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @return Data.
N  * \hideinitializer
N  */
N#define I2C_GET_DATA(i2c) ( (i2c)->DATA )
N
N/**
N  * @brief This macro writes the data to data register of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @param[in] u8Data is the data which will be write to data register of I2C module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_SET_DATA(i2c, u8Data) ( (i2c)->DATA = u8Data )
N
N/**
N  * @brief This macro returns the status of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @return Status.
N  * \hideinitializer
N  */
N#define I2C_GET_STATUS(i2c) ( (i2c)->STATUS )
N
N/**
N  * @brief This macro returns timeout flag.
N  * @param[in] i2c is the base address of I2C module.
N  * @return Status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  * \hideinitializer
N  */
N#define I2C_GET_TIMEOUT_FLAG(i2c) ( ((i2c)->INTSTS & I2C_INTSTS_TIF_Msk) == I2C_INTSTS_TIF_Msk ? 1:0  )
N
N/**
N  * @brief This macro clears timeout flag.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_CLEAR_TIMEOUT_FLAG(i2c) ( (i2c)->INTSTS |= I2C_INTSTS_TIF_Msk )
N
N/**
N  * @brief This macro returns wakeup flag.
N  * @param[in] i2c is the base address of I2C module.
N  * @return Status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  * \hideinitializer
N  */
N#define I2C_GET_WAKEUP_FLAG(i2c) ( ((i2c)->WKUPSTS & I2C_WKUPSTS_WKUPIF_Msk) == I2C_WKUPSTS_WKUPIF_Msk ? 1:0  )
N
N/**
N  * @brief This macro clears wakeup flag.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2C_CLEAR_WAKEUP_FLAG(i2c) ( (i2c)->WKUPSTS |= I2C_WKUPSTS_WKUPIF_Msk )
N
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nvoid I2C_ClearIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
N
N/*@}*/ /* end of group NANO100_I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_I2C_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__I2C_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11934 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "crc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\crc.h" 1
N/**************************************************************************//**
N * @file     crc.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 15/06/10 4:50p $
N * @brief    Nano100 series CRC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __CRC_H__
N#define __CRC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_CRC_Driver CRC Driver
N  @{
N*/
N
N/** @addtogroup NANO100_CRC_EXPORTED_CONSTANTS CRC Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CRC Polynomial Mode Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CCITT           0x00000000UL            /*!<CRC Polynomial Mode - CCITT */
N#define CRC_8               0x40000000UL            /*!<CRC Polynomial Mode - CRC8 */
N#define CRC_16              0x80000000UL            /*!<CRC Polynomial Mode - CRC16 */
N#define CRC_32              0xC0000000UL            /*!<CRC Polynomial Mode - CRC32 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Checksum, Write data Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CHECKSUM_COM    0x08000000UL            /*!<CRC Checksum Complement */
N#define CRC_CHECKSUM_RVS    0x02000000UL            /*!<CRC Checksum Reverse */
N#define CRC_WDATA_COM       0x04000000UL            /*!<CRC Write Data Complement */
N#define CRC_WDATA_RVS       0x01000000UL            /*!<CRC Write Data Reverse */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CPU Write Data Length Constant Definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CPU_WDATA_8     0x00000000UL            /*!<CRC 8-bit CPU Write Data */
N#define CRC_CPU_WDATA_16    0x10000000UL            /*!<CRC 16-bit CPU Write Data */
N#define CRC_CPU_WDATA_32    0x20000000UL            /*!<CRC 32-bit CPU Write Data */
N
N
N/*@}*/ /* end of group NANO100_CRC_EXPORTED_CONSTANTS */
N
N/** @addtogroup NANO100_CRC_EXPORTED_FUNCTIONS CRC Exported Functions
N  @{
N*/
N
N/**
N * @brief       Enable CRC Interrupt
N *
N * @param[in]   u32Mask     Interrupt mask
N *
N * @return      None
N *
N * @details     This macro enable the interrupts.
N */
N#define CRC_ENABLE_INT(u32Mask)   (PDMACRC->DMAIER |= (u32Mask))
N
N/**
N * @brief       Disable CRC Interrupt
N *
N * @param[in]   u32Mask     Interrupt mask
N *
N * @return      None
N *
N * @details     This macro disable the interrupts.
N */
N#define CRC_DISABLE_INT(u32Mask)   (PDMACRC->DMAIER &= ~(u32Mask))
N
N/**
N * @brief       Get CRC Interrupt Flag
N *
N * @param[in]   None
N *
N * @return      Interrupt Flag
N *
N * @details     This macro gets the interrupt flag.
N */
N#define CRC_GET_INT_FLAG()          ((uint32_t)(PDMACRC->DMAISR))
N
N/**
N * @brief       Clear CRC Interrupt Flag
N *
N * @param[in]   u32Mask     Interrupt mask
N *
N * @return      None
N *
N * @details     This macro clear the interrupt flag.
N */
N#define CRC_CLR_INT_FLAG(u32Mask)   (PDMACRC->DMAISR |= (u32Mask))
N
N/**
N * @brief       Set CRC seed value
N *
N * @param[in]   u32Seed     Seed value
N *
N * @return      None
N *
N * @details     This macro set seed value.
N */
N#define CRC_SET_SEED(u32Seed)   { PDMACRC->SEED = (u32Seed); PDMACRC->CTL |= DMA_CRC_CTL_CRC_RST_Msk; }
N
N/**
N * @brief       Get CRC Seed value
N *
N * @param[in]   None
N *
N * @return      Seed Value
N *
N * @details     This macro gets the seed value.
N */
N#define CRC_GET_SEED()   ((uint32_t)(PDMACRC->SEED))
N
N/**
N * @brief       CRC write data
N *
N * @param[in]   u32Data     write data
N *
N * @return      None
N *
N * @details     This macro write CRC data.
N */
N#define CRC_WRITE_DATA(u32Data)   (PDMACRC->WDATA = (u32Data))
N
N
N/*********************************************************************/
Nvoid CRC_Open(uint32_t u32Mode, uint32_t u32Attribute, uint32_t u32Seed, uint32_t u32DataLen);
Nvoid CRC_StartDMATransfer(uint32_t u32SrcAddr, uint32_t u32ByteCount);
Nuint32_t CRC_GetChecksum(void);
N
N
N/*@}*/ /* end of group NANO100_CRC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_CRC_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CRC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11935 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "pdma.h"
L 1 "..\..\..\..\Library\StdDriver\inc\pdma.h" 1
N/**************************************************************************//**
N * @file     pdma.h
N * @version  V1.00
N * $Revision: 9 $
N * $Date: 15/06/10 4:52p $
N * @brief    Nano100 series PDMA driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PDMA_H__
N#define __PDMA_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_PDMA_Driver PDMA Driver
N  @{
N*/
N
N/** @addtogroup NANO100_PDMA_EXPORTED_CONSTANTS PDMA Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Data Width Constant Definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_WIDTH_8        0x00080000UL            /*!<DMA Transfer Width 8-bit */
N#define PDMA_WIDTH_16       0x00100000UL            /*!<DMA Transfer Width 16-bit */
N#define PDMA_WIDTH_32       0x00000000UL            /*!<DMA Transfer Width 32-bit */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Address Attribute Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SAR_INC        0x00000000UL            /*!<DMA SAR increment */
N#define PDMA_SAR_FIX        0x00000020UL            /*!<DMA SAR fix address */
N#define PDMA_SAR_WRA        0x00000030UL            /*!<DMA SAR wrap around */
N#define PDMA_DAR_INC        0x00000000UL            /*!<DMA DAR increment */
N#define PDMA_DAR_FIX        0x00000080UL            /*!<DMA DAR fix address */
N#define PDMA_DAR_WRA        0x000000C0UL            /*!<DMA DAR wrap around */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Peripheral Transfer Mode Constant Definitions                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SPI0_TX        0x00000000UL            /*!<DMA Connect to SPI0 TX */
N#define PDMA_SPI1_TX        0x00000001UL            /*!<DMA Connect to SPI1 TX */
N#define PDMA_UART0_TX       0x00000002UL            /*!<DMA Connect to UART0 TX */
N#define PDMA_UART1_TX       0x00000003UL            /*!<DMA Connect to UART1 TX */
N#define PDMA_USB_TX         0x00000004UL            /*!<DMA Connect to USB TX */
N#define PDMA_I2S_TX         0x00000005UL            /*!<DMA Connect to I2S TX */
N#define PDMA_DAC0_TX        0x00000006UL            /*!<DMA Connect to DAC0 TX */
N#define PDMA_DAC1_TX        0x00000007UL            /*!<DMA Connect to DAC1 TX */
N#define PDMA_SPI2_TX        0x00000008UL            /*!<DMA Connect to SPI2 TX */
N#define PDMA_TMR0           0x00000009UL            /*!<DMA Connect to TMR0 */
N#define PDMA_TMR1           0x0000000AUL            /*!<DMA Connect to TMR1 */
N#define PDMA_TMR2           0x0000000BUL            /*!<DMA Connect to TMR2 */
N#define PDMA_TMR3           0x0000000CUL            /*!<DMA Connect to TMR3 */
N
N#define PDMA_SPI0_RX        0x00000010UL            /*!<DMA Connect to SPI0 RX */
N#define PDMA_SPI1_RX        0x00000011UL            /*!<DMA Connect to SPI1 RX */
N#define PDMA_UART0_RX       0x00000012UL            /*!<DMA Connect to UART0 RX */
N#define PDMA_UART1_RX       0x00000013UL            /*!<DMA Connect to UART1 RX */
N#define PDMA_USB_RX         0x00000014UL            /*!<DMA Connect to USB RX */
N#define PDMA_I2S_RX         0x00000015UL            /*!<DMA Connect to I2S RX */
N#define PDMA_ADC            0x00000016UL            /*!<DMA Connect to I2S1 RX */
N#define PDMA_SPI2_RX        0x00000018UL            /*!<DMA Connect to SPI2 RX */
N#define PDMA_PWM0_CH0       0x00000019UL            /*!<DMA Connect to PWM0 CH0 */
N#define PDMA_PWM0_CH2       0x0000001AUL            /*!<DMA Connect to PWM0 CH2 */
N#define PDMA_PWM1_CH0       0x0000001BUL            /*!<DMA Connect to PWM1 CH0 */
N#define PDMA_PWM1_CH2       0x0000001CUL            /*!<DMA Connect to PWM1 CH2 */
N#define PDMA_MEM            0x0000001FUL            /*!<DMA Connect to Memory */
N
N
N
N/*@}*/ /* end of group NANO100_PDMA_EXPORTED_CONSTANTS */
N
N/** @addtogroup NANO100_PDMA_EXPORTED_FUNCTIONS PDMA Exported Functions
N  @{
N*/
N
N/**
N * @brief       Get PDMA Interrupt Status
N *
N * @param[in]   None
N *
N * @return      None
N *
N * @details     This macro gets the interrupt status.
N * \hideinitializer
N */
N#define PDMA_GET_INT_STATUS()   ((uint32_t)(PDMAGCR->GCRISR))
N
N/**
N * @brief       Get PDMA Channel Interrupt Status
N *
N * @param[in]   u32Ch   Selected DMA channel
N *
N * @return      Interrupt Status
N *
N * @details     This macro gets the channel interrupt status.
N * \hideinitializer
N */
N#define PDMA_GET_CH_INT_STS(u32Ch)   (*((__IO uint32_t *)((uint32_t)&PDMA1->ISR + (uint32_t)((u32Ch-1)*0x100))))
N
N/**
N * @brief       Clear PDMA Channel Interrupt Flag
N *
N * @param[in]   u32Ch   Selected DMA channel
N * @param[in]   u32Mask Interrupt Mask
N *
N * @return      None
N *
N * @details     This macro clear the channel interrupt flag.
N * \hideinitializer
N */
N#define PDMA_CLR_CH_INT_FLAG(u32Ch, u32Mask)   (*((__IO uint32_t *)((uint32_t)&PDMA1->ISR + (uint32_t)((u32Ch-1)*0x100))) = (u32Mask))
N
N/**
N * @brief       Check Channel Status
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      0 = idle
N * @return      1 = busy
N *
N * @details     Check the selected channel is busy or not.
N * \hideinitializer
N */
N#define PDMA_IS_CH_BUSY(u32Ch)    ((*((__IO uint32_t *)((uint32_t)&PDMA1->CSR +(uint32_t)((u32Ch-1)*0x100)))&PDMA_CSR_TRIG_EN_Msk)? 1 : 0)
N
N/**
N * @brief       Set Source Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel source address.
N * \hideinitializer
N */
N#define PDMA_SET_SRC_ADDR(u32Ch, u32Addr) (*((__IO uint32_t *)((uint32_t)&PDMA1->SAR + (uint32_t)((u32Ch-1)*0x100))) = (u32Addr))
N
N/**
N * @brief       Set Destination Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel destination address.
N * \hideinitializer
N */
N#define PDMA_SET_DST_ADDR(u32Ch, u32Addr) (*((__IO uint32_t *)((uint32_t)&PDMA1->DAR + (uint32_t)((u32Ch-1)*0x100))) = (u32Addr))
N
N/**
N * @brief       Set Transfer Count
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Count  Transfer Count
N *
N * @return      None
N *
N * @details     This macro set the selected channel transfer count.
N * \hideinitializer
N */
N#define PDMA_SET_TRANS_CNT(u32Ch, u32Count) \
Ndo{\
N    if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA1->CSR + (uint32_t)((u32Ch-1)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_32)  \
N        *((__IO uint32_t *)((uint32_t)&PDMA1->BCR + (uint32_t)((u32Ch-1)*0x100))) = ((u32Count) << 2);  \
N    else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA1->CSR + (uint32_t)((u32Ch-1)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_8)  \
N        *((__IO uint32_t *)((uint32_t)&PDMA1->BCR + (uint32_t)((u32Ch-1)*0x100))) = (u32Count); \
N    else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA1->CSR + (uint32_t)((u32Ch-1)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_16) \
N        *((__IO uint32_t *)((uint32_t)&PDMA1->BCR + (uint32_t)((u32Ch-1)*0x100))) = ((u32Count) << 1);  \
N}while(0)
X#define PDMA_SET_TRANS_CNT(u32Ch, u32Count) do{    if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA1->CSR + (uint32_t)((u32Ch-1)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_32)          *((__IO uint32_t *)((uint32_t)&PDMA1->BCR + (uint32_t)((u32Ch-1)*0x100))) = ((u32Count) << 2);      else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA1->CSR + (uint32_t)((u32Ch-1)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_8)          *((__IO uint32_t *)((uint32_t)&PDMA1->BCR + (uint32_t)((u32Ch-1)*0x100))) = (u32Count);     else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA1->CSR + (uint32_t)((u32Ch-1)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_16)         *((__IO uint32_t *)((uint32_t)&PDMA1->BCR + (uint32_t)((u32Ch-1)*0x100))) = ((u32Count) << 1);  }while(0)
N
N/**
N * @brief       Stop the channel
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      None
N *
N * @details     This macro stop the selected channel.
N * \hideinitializer
N */
N#define PDMA_STOP(u32Ch) (*((__IO uint32_t *)((uint32_t)&PDMA1->CSR + (uint32_t)((u32Ch-1)*0x100))) &= ~PDMA_CSR_PDMACEN_Msk)
N
Nvoid PDMA_Open(uint32_t u32Mask);
Nvoid PDMA_Close(void);
Nvoid PDMA_SetTransferCnt(uint32_t u32Ch, uint32_t u32Width, uint32_t u32TransCount);
Nvoid PDMA_SetTransferAddr(uint32_t u32Ch, uint32_t u32SrcAddr, uint32_t u32SrcCtrl, uint32_t u32DstAddr, uint32_t u32DstCtrl);
Nvoid PDMA_SetTransferMode(uint32_t u32Ch, uint32_t u32Periphral, uint32_t u32ScatterEn, uint32_t u32DescAddr);
Nvoid PDMA_SetTimeOut(uint32_t u32Ch, uint32_t u32OnOff, uint32_t u32TimeOutCnt);
Nvoid PDMA_Trigger(uint32_t u32Ch);
Nvoid PDMA_EnableInt(uint32_t u32Ch, uint32_t u32Mask);
Nvoid PDMA_DisableInt(uint32_t u32Ch, uint32_t u32Mask);
N
N/*@}*/ /* end of group NANO100_PDMA_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_PDMA_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PDMA_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11936 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "pwm.h"
L 1 "..\..\..\..\Library\StdDriver\inc\pwm.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V1.00
N * $Revision: 12 $
N * $Date: 15/06/30 2:52p $
N * @brief    NANO100 series PWM driver header file
N *
N * @note
N * Copyright (C) 2013-2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup NANO100_PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                      (4)         /*!< PWM channel number  \hideinitializer */
N#define PWM_CH0                              (0UL)       /*!< PWM channel 0  \hideinitializer */
N#define PWM_CH1                              (1UL)       /*!< PWM channel 1  \hideinitializer */
N#define PWM_CH2                              (2UL)       /*!< PWM channel 2  \hideinitializer */
N#define PWM_CH3                              (3UL)       /*!< PWM channel 3  \hideinitializer */
N#define PWM_CH_0_MASK                        (1UL)       /*!< PWM channel 0 mask  \hideinitializer */
N#define PWM_CH_1_MASK                        (2UL)       /*!< PWM channel 1 mask  \hideinitializer */
N#define PWM_CH_2_MASK                        (4UL)       /*!< PWM channel 2 mask  \hideinitializer */
N#define PWM_CH_3_MASK                        (8UL)       /*!< PWM channel 3 mask  \hideinitializer */
N#define PWM_CLK_DIV_1                        (4UL)       /*!< PWM clock divide by 1  \hideinitializer */
N#define PWM_CLK_DIV_2                        (0UL)       /*!< PWM clock divide by 2  \hideinitializer */
N#define PWM_CLK_DIV_4                        (1UL)       /*!< PWM clock divide by 4  \hideinitializer */
N#define PWM_CLK_DIV_8                        (2UL)       /*!< PWM clock divide by 8  \hideinitializer */
N#define PWM_CLK_DIV_16                       (3UL)       /*!< PWM clock divide by 16  \hideinitializer */
N#define PWM_EDGE_ALIGNED                     (0UL)       /*!< PWM working in edge aligned type  \hideinitializer */
N#define PWM_CENTER_ALIGNED                   (1UL)       /*!< PWM working in center aligned type  \hideinitializer */
N#define PWM_RISING_LATCH_INT_ENABLE          (1UL)       /*!< PWM rising latch interrupt enable  \hideinitializer */
N#define PWM_FALLING_LATCH_INT_ENABLE         (2UL)       /*!< PWM falling latch interrupt enable  \hideinitializer */
N#define PWM_RISING_FALLING_LATCH_INT_ENABLE  (3UL)       /*!< PWM rising latch interrupt enable  \hideinitializer */
N#define PWM_RISING_LATCH_INT_FLAG            (2UL)       /*!< PWM rising latch condition happened  \hideinitializer */
N#define PWM_FALLING_LATCH_INT_FLAG           (4UL)       /*!< PWM falling latch condition happened  \hideinitializer */
N#define PWM_RISING_FALLING_LATCH_INT_FLAG    (6UL)       /*!< PWM rising latch condition happened  \hideinitializer */
N#define PWM_RISING_LATCH_PDMA_ENABLE         (0x10UL)    /*!< PWM rising latch PDMA enable  \hideinitializer */
N#define PWM_FALLING_LATCH_PDMA_ENABLE        (0x20UL)    /*!< PWM falling latch PDMA enable  \hideinitializer */
N#define PWM_RISING_FALLING_LATCH_PDMA_ENABLE (0x30UL)    /*!< PWM rising and falling latch PDMA enable  \hideinitializer */
N#define PWM_CAP_PDMA_RFORDER_R               (0x1000UL)  /*!< PWM captured data transferred by PDMA is rising latch first  \hideinitializer */
N#define PWM_CAP_PDMA_RFORDER_F               (0UL)       /*!< PWM captured data transferred by PDMA is falling latch first  \hideinitializer */
N
N/*@}*/ /* end of group NANO100_PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief This macro enable output inverter of specified channel(s)
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask)\
Ndo { \
N    uint8_t i; \
N    (pwm)->CTL &= ~(PWM_CTL_CH0INV_Msk | PWM_CTL_CH1INV_Msk | PWM_CTL_CH2INV_Msk | PWM_CTL_CH3INV_Msk);\
N    for (i = 0; i < PWM_CHANNEL_NUM; i++) { \
N        if ( (u32ChannelMask)  & (1 << i)) { \
N            (pwm)->CTL |= (PWM_CTL_CH0INV_Msk << (i * 8)); \
N        } \
N    } \
N  }while(0)
X#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask)do {     uint8_t i;     (pwm)->CTL &= ~(PWM_CTL_CH0INV_Msk | PWM_CTL_CH1INV_Msk | PWM_CTL_CH2INV_Msk | PWM_CTL_CH3INV_Msk);    for (i = 0; i < PWM_CHANNEL_NUM; i++) {         if ( (u32ChannelMask)  & (1 << i)) {             (pwm)->CTL |= (PWM_CTL_CH0INV_Msk << (i * 8));         }     }   }while(0)
N
N
N/**
N * @brief This macro get captured rising data
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return None
N  * \hideinitializer
N */
N#define PWM_GET_CAPTURE_RISING_DATA(pwm, u32ChannelNum) (*(__IO uint32_t *) (&pwm->CRL0 + 2 * u32ChannelNum))
N
N/**
N * @brief This macro get captured falling data
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return None
N  * \hideinitializer
N */
N#define PWM_GET_CAPTURE_FALLING_DATA(pwm, u32ChannelNum) (*(__IO uint32_t *) (&pwm->CFL0 + 2 * u32ChannelNum))
N
N/**
N * @brief This macro set the prescaler of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFF
N * @return None
N * @note Every even channel N, and channel (N + 1) share a prescaler. So if channel 0 prescaler changed,
N *       channel 1 will also be affected.
N * \hideinitializer
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) \
N    (pwm->PRES = (pwm->PRES & ~(PWM_PRES_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
X#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler)     (pwm->PRES = (pwm->PRES & ~(PWM_PRES_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
N
N/**
N * @brief This macro set the divider of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Divider Clock divider of specified channel. Valid values are
N *              - \ref PWM_CLK_DIV_1
N *              - \ref PWM_CLK_DIV_2
N *              - \ref PWM_CLK_DIV_4
N *              - \ref PWM_CLK_DIV_8
N *              - \ref PWM_CLK_DIV_16
N * @return None
N * \hideinitializer
N */
N#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider) \
N    (pwm->CLKSEL = (pwm->CLKSEL & ~(PWM_CLKSEL_CLKSEL0_Msk << (4 * u32ChannelNum))) | (u32Divider << (4 * u32ChannelNum)))
X#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider)     (pwm->CLKSEL = (pwm->CLKSEL & ~(PWM_CLKSEL_CLKSEL0_Msk << (4 * u32ChannelNum))) | (u32Divider << (4 * u32ChannelNum)))
N
N/**
N * @brief This macro set the duty of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32CMR Duty of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next PWM period
N * \hideinitializer
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) \
Ndo { \
N    *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) &= ~PWM_DUTY_CM_Msk; \
N    *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) |= (u32CMR << PWM_DUTY_CM_Pos); \
N}while(0)
X#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) do {     *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) &= ~PWM_DUTY_CM_Msk;     *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) |= (u32CMR << PWM_DUTY_CM_Pos); }while(0)
N
N/**
N * @brief This macro set the period of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next PWM period
N * @note PWM counter will stop if period length set to 0
N * \hideinitializer
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR) \
Ndo { \
N    *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) &= ~PWM_DUTY_CN_Msk; \
N    *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) |= u32CNR; \
N} while(0)
X#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR) do {     *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) &= ~PWM_DUTY_CN_Msk;     *(__IO uint32_t *) (&pwm->DUTY0 + 3 * u32ChannelNum) |= u32CNR; } while(0)
N
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
N                                 uint32_t u32ChannelNum,
N                                 uint32_t u32Frequency,
N                                 uint32_t u32DutyCycle);
Nuint32_t PWM_ConfigCaptureChannel (PWM_T *pwm,
N                                   uint32_t u32ChannelNum,
N                                   uint32_t u32UnitTimeNsec,
N                                   uint32_t u32CaptureEdge);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nuint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnablePDMA(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32RisingFirst, uint32_t u32Mode);
Nvoid PWM_DisablePDMA(PWM_T *pwm, uint32_t u32ChannelNum);
N
N/*@}*/ /* end of group NANO100_PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_PWM_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2013-2014 Nuvoton Technology Corp. ***/
L 11937 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "rtc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\rtc.h" 1
N/**************************************************************************//**
N * @file     rtc.h
N * @version  V1.00
N * $Revision: 7 $
N * $Date: 15/06/26 1:34p $
N * @brief    Nano100 series RTC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __RTC_H__
N#define __RTC_H__
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_RTC_Driver RTC Driver
N  @{
N*/
N
N
N/** @addtogroup NANO100_RTC_EXPORTED_CONSTANTS RTC Exported Constants
N  @{
N*/
N
N
N#define RTC_INIT_KEY         0xA5EB1357  /*!< RTC Access Key     */
N#define RTC_WRITE_KEY        0xA965         /*!< RTC Access Key  */
N
N#define RTC_WAIT_COUNT       0xFFFFFFFF     /*!< Initial Time Out Value  */
N
N#define RTC_YEAR2000         2000            /*!< RTC Reference */
N#define RTC_FCR_REFERENCE    32761           /*!< RTC Reference */
N
N#define RTC_CLOCK_12         0                /*!< RTC 12 Hour */
N#define RTC_CLOCK_24         1                /*!< RTC 24 Hour */
N
N#define RTC_AM               1                /*!< RTC AM */
N#define RTC_PM               2                /*!< RTC PM */
N
N#define RTC_TICK_1_SEC       ((uint32_t) 0x00000000)   /*!< Time tick is 1 second */
N#define RTC_TICK_1_2_SEC     ((uint32_t) 0x00000001)   /*!< Time tick is 1/2 second */
N#define RTC_TICK_1_4_SEC     ((uint32_t) 0x00000002)   /*!< Time tick is 1/4 second */
N#define RTC_TICK_1_8_SEC     ((uint32_t) 0x00000003)   /*!< Time tick is 1/8 second */
N#define RTC_TICK_1_16_SEC    ((uint32_t) 0x00000004)   /*!< Time tick is 1/16 second */
N#define RTC_TICK_1_32_SEC    ((uint32_t) 0x00000005)   /*!< Time tick is 1/32 second */
N#define RTC_TICK_1_64_SEC    ((uint32_t) 0x00000006)   /*!< Time tick is 1/64 second */
N#define RTC_TICK_1_128_SEC   ((uint32_t) 0x00000007)   /*!< Time tick is 1/128 second */
N
N#define RTC_SUNDAY       ((uint32_t) 0x00000000) /*!< Day of week is sunday */
N#define RTC_MONDAY       ((uint32_t) 0x00000001) /*!< Day of week is monday */
N#define RTC_TUESDAY      ((uint32_t) 0x00000002) /*!< Day of week is tuesday */
N#define RTC_WEDNESDAY    ((uint32_t) 0x00000003) /*!< Day of week is wednesday */
N#define RTC_THURSDAY     ((uint32_t) 0x00000004) /*!< Day of week is thursday */
N#define RTC_FRIDAY       ((uint32_t) 0x00000005) /*!< Day of week is friday */
N#define RTC_SATURDAY     ((uint32_t) 0x00000006) /*!< Day of week is saturday */
N
N
N#define RTC_SNOOPER_RISING   0      /*!< Snooper Active Rising Edge */
N#define RTC_SNOOPER_FALLING  1      /*!< Snooper Active Falling Edge */
N
N
N/*@}*/ /* end of group NANO100_RTC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_RTC_EXPORTED_STRUCTS RTC Exported Structs
N  @{
N*/
N
N/**
N  * @brief  RTC define Time Data Struct
N  */
Ntypedef struct
N{
N    uint32_t u32Year;          /*!<  Year value */
N    uint32_t u32Month;         /*!<  Month value */
N    uint32_t u32Day;           /*!<  Day value */
N    uint32_t u32DayOfWeek;     /*!<  Day of week value */
N    uint32_t u32Hour;          /*!<  Hour value */
N    uint32_t u32Minute;        /*!<  Minute value */
N    uint32_t u32Second;        /*!<  Second value */
N    uint32_t u32TimeScale;     /*!<  12-Hour, 24-Hour */
N    uint32_t u32AmPm;          /*!<  Only Time Scale select 12-hr used */
N} S_RTC_TIME_DATA_T;
N
N/*@}*/ /* end of group NANO100_RTC_EXPORTED_STRUCTS */
N
N
N/** @addtogroup NANO100_RTC_EXPORTED_FUNCTIONS RTC Exported Functions
N  @{
N*/
N
N
N/**
N *  @brief    Read spare register
N *
N *  @param[in]    u32RegNum    The spare register number(0~23)
N *
N *  @return   Spare register content.
N *
N */
N#define RTC_READ_SPARE_REGISTER(u32RegNum)    (RTC->SPR[u32RegNum])
N
N/**
N *  @brief    Write spare register
N *
N *  @param[in]    u32RegNum    The spare register number(0~23)
N *  @param[in]    u32RegValue  The spare register value
N *
N *  @return   None
N *
N */
N#define RTC_WRITE_SPARE_REGISTER(u32RegNum, u32RegValue)    (RTC->SPR[u32RegNum] = u32RegValue)
N
N/**
N *  @brief    According to current time, return this year is leap year or not
N *
N *  @param    None
N *
N *  @return   0 = This year is not a leap year. \n
N *            1 = This year is a leap year.
N *
N */
N#define RTC_IS_LEAP_YEAR()    ((RTC->LIR & (RTC_LIR_LIR_Msk))?1:0)
N
N/**
N *  @brief    Clear alarm interrupt status.
N *
N *  @param    None
N *
N *  @return   None
N *
N */
N#define RTC_CLEAR_ALARM_INT_FLAG()    (RTC->RIIR = RTC_RIIR_AIF_Msk)
N
N/**
N *  @brief    Clear tick interrupt status.
N *
N *  @param    None
N *
N *  @return    None
N *
N */
N#define RTC_CLEAR_TICK_INT_FLAG()    (RTC->RIIR = RTC_RIIR_TIF_Msk)
N
N/**
N *  @brief    Clear tamper detect pin status.
N *
N *  @param[in]    u32PinNum    tamper detect pin number.
N *
N *  @return   None
N *
N */
N#define RTC_CLEAR_TAMPER_FLAG(u32PinNum)    (RTC->RIIR = RTC_RIIR_SNOOPIF_Msk)
N
N/**
N *  @brief    Get alarm interrupt status.
N *
N *  @param    None
N *
N *  @return   Alarm interrupt status
N *
N */
N#define RTC_GET_ALARM_INT_FLAG()    ((RTC->RIIR & RTC_RIIR_AIF_Msk) >> RTC_RIIR_AIF_Pos)
N
N/**
N *  @brief    Get alarm interrupt status.
N *
N *  @param    None
N *
N *  @return   Alarm interrupt status
N *
N */
N#define RTC_GET_TICK_INT_FLAG()    ((RTC->RIIR & RTC_RIIR_TIF_Msk) >> RTC_RIIR_TIF_Pos)
N
N/**
N *  @brief    Get tamper detect pin status.
N *
N *  @param    None
N *
N *  @return   1: Snooper Pin Event Detected \n
N *            0: Snooper Pin Event Never Detected
N *
N */
N#define RTC_GET_TAMPER_FLAG()    ( (RTC->RIIR & RTC_RIIR_SNOOPIF_Msk) >> RTC_RIIR_SNOOPIF_Pos)
N
N/**
N *  @brief    Enable Timer tick wakeup function.
N *
N *  @param    None
N *
N *  @return   None
N *
N */
N#define RTC_ENABLE_TICK_WAKEUP() (RTC->TTR |= RTC_TTR_TWKE_Msk);
N
N/**
N *  @brief    Disable Timer tick wakeup function.
N *
N *  @param    None
N *
N *  @return   None
N *
N */
N#define RTC_DISABLE_TICK_WAKEUP() (RTC->TTR &= ~RTC_TTR_TWKE_Msk);
N
N
Nvoid RTC_Open(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_Close(void);
Nvoid RTC_32KCalibration(int32_t i32FrequencyX100);
Nvoid RTC_SetTickPeriod(uint32_t u32TickSelection);
Nvoid RTC_EnableInt(uint32_t u32IntFlagMask);
Nvoid RTC_DisableInt(uint32_t u32IntFlagMask);
Nuint32_t RTC_GetDayOfWeek(void);
Nvoid RTC_DisableTamperDetection(void);
Nvoid RTC_EnableTamperDetection(uint32_t u32PinCondition);
Nvoid RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nvoid RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day);
Nvoid RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nvoid RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek);
Nvoid RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt);
N
N
N
N/*@}*/ /* end of group NANO100_RTC_EXPORTED_FUNCTIONS */
N
N
N/*@}*/ /* end of group NANO100_RTC_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif /* __RTC_H__ */
N
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
N
N
L 11938 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "sc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\sc.h" 1
N/**************************************************************************//**
N * @file     sc.h
N * @version  V1.00
N * $Revision: 7 $
N * $Date: 15/07/31 7:26p $
N * @brief    Nano100 series Smartcard (SC) driver header file
N *
N * @note
N * Copyright (C) 2013~2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SC_H__
N#define __SC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_SC_Driver SC Driver
N  @{
N*/
N
N/** @addtogroup NANO100_SC_EXPORTED_CONSTANTS SC Exported Constants
N  @{
N*/
N#define SC_INTERFACE_NUM        3                /*!< Smartcard interface numbers */
N#define SC_PIN_STATE_HIGH       1                /*!< Smartcard pin status high   */
N#define SC_PIN_STATE_LOW        0                /*!< Smartcard pin status low    */
N#define SC_PIN_STATE_IGNORE     0xFFFFFFFF       /*!< Ignore pin status           */
N#define SC_CLK_ON               1                /*!< Smartcard clock on          */
N#define SC_CLK_OFF              0                /*!< Smartcard clock off         */
N
N#define SC_TMR_MODE_0                   (0ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 0, down count                                                      */
N#define SC_TMR_MODE_1                   (1ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 1, down count, start after detect start bit                        */
N#define SC_TMR_MODE_2                   (2ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 2, down count, start after receive start bit                       */
N#define SC_TMR_MODE_3                   (3ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 3, down count, use for activation, only timer 0 support this mode  */
N#define SC_TMR_MODE_4                   (4ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 4, down count with reload after timeout                            */
N#define SC_TMR_MODE_5                   (5ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 5, down count, start after detect start bit, reload after timeout  */
N#define SC_TMR_MODE_6                   (6ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 6, down count, start after receive start bit, reload after timeout */
N#define SC_TMR_MODE_7                   (7ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 7, down count, start and reload after detect start bit             */
N#define SC_TMR_MODE_8                   (8ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 8, up count                                                        */
N#define SC_TMR_MODE_F                   (0xF << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 15, down count, reload after detect start bit                      */
N
N
N/*@}*/ /* end of group NANO100_SC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_SC_EXPORTED_FUNCTIONS SC Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro enable smartcard interrupt
N  * @param[in] sc Base address of smartcard module
N  * @param[in] u32Mask Interrupt mask to be enabled. A combination of
N  *             - \ref SC_IER_ACON_ERR_IE_Msk
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_INIT_IE_Msk
N  *             - \ref SC_IER_CD_IE_Msk
N  *             - \ref SC_IER_BGT_IE_Msk
N  *             - \ref SC_IER_TMR2_IE_Msk
N  *             - \ref SC_IER_TMR1_IE_Msk
N  *             - \ref SC_IER_TMR0_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define SC_ENABLE_INT(sc, u32Mask) ((sc)->IER |= (u32Mask))
N
N/**
N  * @brief This macro disable smartcard interrupt
N  * @param[in] sc Base address of smartcard module
N  * @param[in] u32Mask Interrupt mask to be disabled. A combination of
N  *             - \ref SC_IER_ACON_ERR_IE_Msk
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_INIT_IE_Msk
N  *             - \ref SC_IER_CD_IE_Msk
N  *             - \ref SC_IER_BGT_IE_Msk
N  *             - \ref SC_IER_TMR2_IE_Msk
N  *             - \ref SC_IER_TMR1_IE_Msk
N  *             - \ref SC_IER_TMR0_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define SC_DISABLE_INT(sc, u32Mask) ((sc)->IER &= ~(u32Mask))
N
N/**
N  * @brief This macro set VCC pin state of smartcard interface
N  * @param[in] sc Base address of smartcard module
N  * @param[in] u32State Pin state of VCC pin, valid parameters are \ref SC_PIN_STATE_HIGH and \ref SC_PIN_STATE_LOW
N  * @return None
N  * \hideinitializer
N  */
N#define SC_SET_VCC_PIN(sc, u32State) \
N    do {\
N        uint32_t reg = (sc)->PINCSR;\
N        if(((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == 0) ||\
N            ((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)))\
N            reg &= ~SC_PINCSR_POW_EN_Msk;\
N        else\
N            reg |= SC_PINCSR_POW_EN_Msk;\
N        if(u32State)\
N            (sc)->PINCSR = reg | SC_PINCSR_POW_EN_Msk;\
N        else\
N            (sc)->PINCSR = reg & ~SC_PINCSR_POW_EN_Msk;\
N    }while(0)
X#define SC_SET_VCC_PIN(sc, u32State)     do {        uint32_t reg = (sc)->PINCSR;        if(((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == 0) ||            ((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)))            reg &= ~SC_PINCSR_POW_EN_Msk;        else            reg |= SC_PINCSR_POW_EN_Msk;        if(u32State)            (sc)->PINCSR = reg | SC_PINCSR_POW_EN_Msk;        else            (sc)->PINCSR = reg & ~SC_PINCSR_POW_EN_Msk;    }while(0)
N
N
N/**
N  * @brief This macro turns CLK output on or off
N  * @param[in] sc Base address of smartcard module
N  * @param[in] u32OnOff Clock on or off for selected smartcard module, valid values are \ref SC_CLK_ON and \ref SC_CLK_OFF
N  * @return None
N  * \hideinitializer
N  */
N#define SC_SET_CLK_PIN(sc, u32OnOff)\
N    do {\
N        uint32_t reg = (sc)->PINCSR;\
N        if(((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == 0) ||\
N            ((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)))\
N            reg &= ~SC_PINCSR_POW_EN_Msk;\
N        else\
N            reg |= SC_PINCSR_POW_EN_Msk;\
N        if(u32OnOff)\
N            (sc)->PINCSR = reg | SC_PINCSR_CLK_KEEP_Msk;\
N        else\
N            (sc)->PINCSR = reg & ~SC_PINCSR_CLK_KEEP_Msk;\
N    }while(0)
X#define SC_SET_CLK_PIN(sc, u32OnOff)    do {        uint32_t reg = (sc)->PINCSR;        if(((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == 0) ||            ((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)))            reg &= ~SC_PINCSR_POW_EN_Msk;        else            reg |= SC_PINCSR_POW_EN_Msk;        if(u32OnOff)            (sc)->PINCSR = reg | SC_PINCSR_CLK_KEEP_Msk;        else            (sc)->PINCSR = reg & ~SC_PINCSR_CLK_KEEP_Msk;    }while(0)
N
N/**
N  * @brief This macro set I/O pin state of smartcard interface
N  * @param[in] sc Base address of smartcard module
N  * @param[in] u32State Pin state of I/O pin, valid parameters are \ref SC_PIN_STATE_HIGH and \ref SC_PIN_STATE_LOW
N  * @return None
N  * \hideinitializer
N  */
N#define SC_SET_IO_PIN(sc, u32State)\
N    do {\
N        uint32_t reg = (sc)->PINCSR;\
N        if(((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == 0) ||\
N            ((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)))\
N            reg &= ~SC_PINCSR_POW_EN_Msk;\
N        else\
N            reg |= SC_PINCSR_POW_EN_Msk;\
N        if(u32State)\
N            (sc)->PINCSR = reg | SC_PINCSR_SC_DATA_O_Msk;\
N        else\
N            (sc)->PINCSR = reg & ~SC_PINCSR_SC_DATA_O_Msk;\
N    }while(0)
X#define SC_SET_IO_PIN(sc, u32State)    do {        uint32_t reg = (sc)->PINCSR;        if(((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == 0) ||            ((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)))            reg &= ~SC_PINCSR_POW_EN_Msk;        else            reg |= SC_PINCSR_POW_EN_Msk;        if(u32State)            (sc)->PINCSR = reg | SC_PINCSR_SC_DATA_O_Msk;        else            (sc)->PINCSR = reg & ~SC_PINCSR_SC_DATA_O_Msk;    }while(0)
N
N/**
N  * @brief This macro set RST pin state of smartcard interface
N  * @param[in] sc Base address of smartcard module
N  * @param[in] u32State Pin state of RST pin, valid parameters are \ref SC_PIN_STATE_HIGH and \ref SC_PIN_STATE_LOW
N  * @return None
N  * \hideinitializer
N  */
N#define SC_SET_RST_PIN(sc, u32State)\
N    do {\
N        uint32_t reg = (sc)->PINCSR;\
N        if(((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == 0) ||\
N            ((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)))\
N            reg &= ~SC_PINCSR_POW_EN_Msk;\
N        else\
N            reg |= SC_PINCSR_POW_EN_Msk;\
N        if(u32State)\
N            (sc)->PINCSR = reg | SC_PINCSR_SC_RST_Msk;\
N        else\
N            (sc)->PINCSR = reg & ~SC_PINCSR_SC_RST_Msk;\
N    }while(0)
X#define SC_SET_RST_PIN(sc, u32State)    do {        uint32_t reg = (sc)->PINCSR;        if(((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == 0) ||            ((reg & (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)) == (SC_PINCSR_POW_EN_Msk | SC_PINCSR_POW_INV_Msk)))            reg &= ~SC_PINCSR_POW_EN_Msk;        else            reg |= SC_PINCSR_POW_EN_Msk;        if(u32State)            (sc)->PINCSR = reg | SC_PINCSR_SC_RST_Msk;        else            (sc)->PINCSR = reg & ~SC_PINCSR_SC_RST_Msk;    }while(0)
N
N/**
N  * @brief This macro read one byte from smartcard module receive FIFO
N  * @param[in] sc Base address of smartcard module
N  * @return[in] One byte read from receive FIFO
N  * \hideinitializer
N  */
N#define SC_READ(sc) ((char)((sc)->RBR))
N
N/**
N  * @brief This macro write one byte to smartcard module transmit FIFO
N  * @param[in] sc Base address of smartcard module
N  * @param[in] u8Data Data to write to transmit FIFO
N  * @return None
N  * \hideinitializer
N  */
N#define SC_WRITE(sc, u8Data) ((sc)->THR = (u8Data))
N
N/**
N  * @brief This macro set smartcard stop bit length
N  * @param[in] sc Base address of smartcard module
N  * @param[in] u32Len Stop bit length, ether 1 or 2.
N  * @return None
N  * @details Stop bit length must be 1 for T = 1 protocol and 2 for T = 0 protocol.
N  * \hideinitializer
N  */
N#define SC_SET_STOP_BIT_LEN(sc, u32Len) ((sc)->CTL = ((sc)->CTL & ~SC_CTL_SLEN_Msk) | (u32Len == 1 ? SC_CTL_SLEN_Msk : 0))
N
N/**
N  * @brief  Enable/Disable Tx error retry, and set Tx error retry count
N  * @param[in]  sc Base address of smartcard module
N  * @param[in]  u32Count The number of times of Tx error retry count, between 0~8. 0 means disable Tx error retry
N  * @return None
N  */
N__STATIC_INLINE void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
N{
N    // Retry count must set while enable bit disabled, so disable it first
N    sc->CTL &= ~(SC_CTL_TX_ERETRY_Msk | SC_CTL_TX_ERETRY_EN_Msk);
X    sc->CTL &= ~((0x7ul << (20)) | (0x1ul << (23)));
N
N    if(u32Count != 0)
N    {
N        sc->CTL |= ((u32Count - 1) << SC_CTL_TX_ERETRY_Pos) | SC_CTL_TX_ERETRY_EN_Msk;
X        sc->CTL |= ((u32Count - 1) << (20)) | (0x1ul << (23));
N    }
N}
N
N/**
N  * @brief  Enable/Disable Rx error retry, and set Rx error retry count
N  * @param[in]  sc Base address of smartcard module
N  * @param[in]  u32Count The number of times of Rx error retry count, between 0~8. 0 means disable Rx error retry
N  * @return None
N  */
N__STATIC_INLINE void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
N{
N    // Retry count must set while enable bit disabled, so disable it first
N    sc->CTL &= ~(SC_CTL_RX_ERETRY_Msk | SC_CTL_RX_ERETRY_EN_Msk);
X    sc->CTL &= ~((0x7ul << (16)) | (0x1ul << (19)));
N
N    if(u32Count != 0)
N    {
N        sc->CTL |= ((u32Count - 1) << SC_CTL_RX_ERETRY_Pos) | SC_CTL_RX_ERETRY_EN_Msk;
X        sc->CTL |= ((u32Count - 1) << (16)) | (0x1ul << (19));
N    }
N}
N
N
Nuint32_t SC_IsCardInserted(SC_T *sc);
Nvoid SC_ClearFIFO(SC_T *sc);
Nvoid SC_Close(SC_T *sc);
Nvoid SC_Open(SC_T *sc, uint32_t u32CardDet, uint32_t u32PWR);
Nvoid SC_ResetReader(SC_T *sc);
Nvoid SC_SetBlockGuardTime(SC_T *sc, uint32_t u32BGT);
Nvoid SC_SetCharGuardTime(SC_T *sc, uint32_t u32CGT);
Nvoid SC_StopAllTimer(SC_T *sc);
Nvoid SC_StartTimer(SC_T *sc, uint32_t u32TimerNum, uint32_t u32Mode, uint32_t u32ETUCount);
Nvoid SC_StopTimer(SC_T *sc, uint32_t u32TimerNum);
N
N
N/*@}*/ /* end of group NANO100_SC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_SC_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SC_H__
N
N/*** (C) COPYRIGHT 2013~2014 Nuvoton Technology Corp. ***/
L 11939 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "scuart.h"
L 1 "..\..\..\..\Library\StdDriver\inc\scuart.h" 1
N/**************************************************************************//**
N * @file     sc.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 14/05/20 7:57p $
N * @brief    Nano100 series Smartcard UART mode (SCUART) driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SCUART_H__
N#define __SCUART_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_SCUART_Driver SCUART Driver
N  @{
N*/
N
N/** @addtogroup NANO100_SCUART_EXPORTED_CONSTANTS SCUART Exported Constants
N  @{
N*/
N#define SCUART_CHAR_LEN_5     (0x3ul << SC_UACTL_DATA_LEN_Pos)  /*!< Set SCUART word length to 5 bits */
N#define SCUART_CHAR_LEN_6     (0x2ul << SC_UACTL_DATA_LEN_Pos)  /*!< Set SCUART word length to 6 bits */
N#define SCUART_CHAR_LEN_7     (0x1ul << SC_UACTL_DATA_LEN_Pos)  /*!< Set SCUART word length to 7 bits */
N#define SCUART_CHAR_LEN_8     (0)                               /*!< Set SCUART word length to 8 bits */
N
N#define SCUART_PARITY_NONE    (SC_UACTL_PBDIS_Msk)              /*!< Set SCUART transfer with no parity   */
N#define SCUART_PARITY_ODD     (SC_UACTL_OPE_Msk)                /*!< Set SCUART transfer with odd parity  */
N#define SCUART_PARITY_EVEN    (0)                               /*!< Set SCUART transfer with even parity */
N
N#define SCUART_STOP_BIT_1     (SC_CTL_SLEN_Msk)                 /*!< Set SCUART transfer with one stop bit  */
N#define SCUART_STOP_BIT_2     (0)                               /*!< Set SCUART transfer with two stop bits */
N
N
N/*@}*/ /* end of group NANO100_SCUART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_SCUART_EXPORTED_FUNCTIONS SCUART Exported Functions
N  @{
N*/
N
N/* TX Macros */
N/**
N  * @brief Write Data to Tx data register
N  * @param[in] sc The base address of smartcard module.
N  * @param[in] u8Data Data byte to transmit
N  * @return None
N  * \hideinitializer
N  */
N#define SCUART_WRITE(sc, u8Data) ((sc)->THR = (u8Data))
N
N/**
N  * @brief Get TX FIFO empty flag status from register
N  * @param[in] sc The base address of smartcard module
N  * @return Transmit FIFO empty status
N  * @retval 0 Transmit FIFO is not empty
N  * @retval SC_TRSR_TX_EMPTY_F_Msk Transmit FIFO is empty
N  * \hideinitializer
N  */
N#define SCUART_GET_TX_EMPTY(sc) ((sc)->TRSR & SC_TRSR_TX_EMPTY_F_Msk)
N
N/**
N  * @brief Get TX FIFO full flag status from register
N  * @param[in] sc The base address of smartcard module
N  * @return Transmit FIFO full status
N  * @retval 0 Transmit FIFO is not full
N  * @retval SC_TRSR_TX_FULL_F_Msk Transmit FIFO is full
N  * \hideinitializer
N  */
N#define SCUART_GET_TX_FULL(sc) ((sc)->TRSR & SC_TRSR_TX_FULL_F_Msk)
N
N/**
N  * @brief Wait specified smartcard port transmission complete
N  * @param[in] sc The base address of smartcard module
N  * @return None
N  * @note This Macro blocks until transmit complete.
N  * \hideinitializer
N  */
N#define SCUART_WAIT_TX_EMPTY(sc) while((sc)->TRSR & SC_TRSR_TX_ATV_Msk)
N
N/**
N  * @brief Check specified smartcard port transmit FIFO is full or not
N  * @param[in] sc The base address of smartcard module
N  * @return Transmit FIFO full status
N  * @retval 0 Transmit FIFO is not full
N  * @retval 1 Transmit FIFO is full
N  * \hideinitializer
N  */
N#define SCUART_IS_TX_FULL(sc) ((sc)->TRSR & SC_TRSR_TX_FULL_F_Msk ? 1 : 0)
N
N/**
N  * @brief Check specified smartcard port transmission is over
N  * @param[in] sc The base address of smartcard module
N  * @return Transmit complete status
N  * @retval 0 Transmit is not complete
N  * @retval 1 Transmit complete
N  * \hideinitializer
N  */
N#define SCUART_IS_TX_EMPTY(sc) ((sc)->TRSR & SC_TRSR_TX_ATV_Msk ? 0 : 1)
N
N
N/* RX Macros */
N
N/**
N  * @brief Read Rx data register
N  * @param[in] sc The base address of smartcard module
N  * @return The oldest data byte in RX FIFO
N  * \hideinitializer
N  */
N#define SCUART_READ(sc) ((sc)->RBR)
N
N/**
N  * @brief Get RX FIFO empty flag status from register
N  * @param[in] sc The base address of smartcard module
N  * @return Receive FIFO empty status
N  * @retval 0 Receive FIFO is not empty
N  * @retval SC_TRSR_RX_EMPTY_F_Msk Receive FIFO is empty
N  * \hideinitializer
N  */
N#define SCUART_GET_RX_EMPTY(sc) ((sc)->TRSR & SC_TRSR_RX_EMPTY_F_Msk)
N
N
N/**
N  * @brief Get RX FIFO full flag status from register
N  * @param[in] sc The base address of smartcard module
N  * @return Receive FIFO full status
N  * @retval 0 Receive FIFO is not full
N  * @retval SC_TRSR_TX_FULL_F_Msk Receive FIFO is full
N  * \hideinitializer
N  */
N#define SCUART_GET_RX_FULL(sc) ((sc)->TRSR & SC_TRSR_RX_FULL_F_Msk)
N
N/**
N  * @brief Check if receive data number in FIFO reach FIFO trigger level or not
N  * @param[in] sc The base address of smartcard module
N  * @return Receive FIFO data status
N  * @retval 0 The number of bytes in receive FIFO is less than trigger level
N  * @retval 1 The number of bytes in receive FIFO equals or larger than trigger level
N  * @note If receive trigger level is \b not 1 byte, this macro return 0 does not necessary indicates there is no data in FIFO
N  * \hideinitializer
N  */
N#define SCUART_IS_RX_READY(sc) ((sc)->ISR & SC_ISR_RDA_IS_Msk ? 1 : 0)
N
N/**
N  * @brief Check specified smartcard port receive FIFO is full or not
N  * @param[in] sc The base address of smartcard module
N  * @return Receive FIFO full status
N  * @retval 0 Receive FIFO is not full
N  * @retval 1 Receive FIFO is full
N  * \hideinitializer
N  */
N#define SCUART_IS_RX_FULL(sc) ((sc)->TRSR & SC_TRSR_RX_FULL_F_Msk ? 1 : 0)
N
N/* Interrupt Macros */
N
N/**
N  * @brief Enable specified interrupts
N  * @param[in] sc The base address of smartcard module
N  * @param[in] u32Mask Interrupt masks to enable, a combination of following bits
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return    None
N  * \hideinitializer
N  */
N#define SCUART_ENABLE_INT(sc, u32Mask) ((sc)->IER |= (u32Mask))
N
N/**
N  * @brief Disable specified interrupts
N  * @param[in] sc The base address of smartcard module
N  * @param[in] u32Mask Interrupt masks to disable, a combination of following bits
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return    None
N  * \hideinitializer
N  */
N#define SCUART_DISABLE_INT(sc, u32Mask) ((sc)->IER &= ~(u32Mask))
N
N/**
N  * @brief Get specified interrupt flag/status
N  * @param[in] sc The base address of smartcard module
N  * @param[in] u32Type Interrupt flag/status to check, could be one of following value
N  *             - \ref SC_ISR_RTMR_IS_Msk
N  *             - \ref SC_ISR_TERR_IS_Msk
N  *             - \ref SC_ISR_TBE_IS_Msk
N  *             - \ref SC_ISR_RDA_IS_Msk
N  * @return The status of specified interrupt
N  * @retval 0 Specified interrupt does not happened
N  * @retval 1 Specified interrupt happened
N  * \hideinitializer
N  */
N#define SCUART_GET_INT_FLAG(sc, u32Type) ((sc)->ISR & u32Type ? 1 : 0)
N
N/**
N  * @brief Clear specified interrupt flag/status
N  * @param[in] sc The base address of smartcard module
N  * @param[in] u32Type Interrupt flag/status to clear, could be the combination of following values
N  *             - \ref SC_ISR_RTMR_IS_Msk
N  *             - \ref SC_ISR_TERR_IS_Msk
N  *             - \ref SC_ISR_TBE_IS_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define SCUART_CLR_INT_FLAG(sc, u32Type) ((sc)->ISR = u32Type)
N
N/**
N  * @brief Get receive error flag/status
N  * @param[in] sc The base address of smartcard module
N  * @return Current receive error status, could one of following errors:
N  * @retval SC_TRSR_RX_EPA_F_Msk Parity error
N  * @retval SC_TRSR_RX_EFR_F_Msk Frame error
N  * @retval SC_TRSR_RX_EBR_F_Msk Break error
N  * \hideinitializer
N  */
N#define SCUART_GET_ERR_FLAG(sc) ((sc)->TRSR & (SC_TRSR_RX_EPA_F_Msk | SC_TRSR_RX_EFR_F_Msk | SC_TRSR_RX_EBR_F_Msk))
N
N/**
N  * @brief Clear specified receive error flag/status
N  * @param[in] sc The base address of smartcard module
N  * @param[in] u32Mask Receive error flag/status to clear, combination following values
N  *             - \ref SC_TRSR_RX_EPA_F_Msk
N  *             - \ref SC_TRSR_RX_EFR_F_Msk
N  *             - \ref SC_TRSR_RX_EBR_F_Msk
N  * @return None
N  * \hideinitializer
N  */
N#define SCUART_CLR_ERR_FLAG(sc, u32Mask) ((sc)->TRSR = u32Mask)
N
Nvoid SCUART_Close(SC_T* sc);
Nuint32_t SCUART_Open(SC_T* sc, uint32_t u32baudrate);
Nuint32_t SCUART_Read(SC_T* sc, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nuint32_t SCUART_SetLineConfig(SC_T* sc, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t  u32StopBits);
Nvoid SCUART_SetTimeoutCnt(SC_T* sc, uint32_t u32TOC);
Nvoid SCUART_Write(SC_T* sc,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N/*@}*/ /* end of group NANO100_SCUART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_SCUART_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SCUART_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11940 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "spi.h"
L 1 "..\..\..\..\Library\StdDriver\inc\spi.h" 1
N/****************************************************************************//**
N * @file     spi.h
N * @version  V1.00
N * $Revision: 8 $
N * $Date: 15/06/08 5:03p $
N * @brief    NANO100 series SPI driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_SPI_Driver SPI Driver
N  @{
N*/
N
N
N/** @addtogroup NANO100_SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CTL_TX_NEG_Msk)                            /*!< CLKP=0; RX_NEG=0; TX_NEG=1 */
N#define SPI_MODE_1        (SPI_CTL_RX_NEG_Msk)                            /*!< CLKP=0; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_2        (SPI_CTL_CLKP_Msk | SPI_CTL_RX_NEG_Msk)         /*!< CLKP=1; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_3        (SPI_CTL_CLKP_Msk | SPI_CTL_TX_NEG_Msk)         /*!< CLKP=1; RX_NEG=0; TX_NEG=1 */
N
N#define SPI_SLAVE        (SPI_CTL_SLAVE_Msk)                              /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                           /*!< Set as master */
N
N#define SPI_SS0                (0x1)                                      /*!< Set SS0 */
N#define SPI_SS0_ACTIVE_HIGH    (SPI_SSR_SS_LVL_Msk)                       /*!< SS0 active high */
N#define SPI_SS0_ACTIVE_LOW     (0x0)                                      /*!< SS0 active low */
N
N#define SPI_SS1                (0x2)                                      /*!< Set SS1 */
N#define SPI_SS1_ACTIVE_HIGH    (SPI_SSR_SS_LVL_Msk)                       /*!< SS1 active high */
N#define SPI_SS1_ACTIVE_LOW     (0x0)                                      /*!< SS1 active low */
N
N#define SPI_IE_MASK                        (0x01)                         /*!< Interrupt enable mask */
N#define SPI_SSTA_INTEN_MASK                (0x04)                         /*!< Slave 3-Wire mode start interrupt enable mask */
N#define SPI_FIFO_TX_INTEN_MASK             (0x08)                         /*!< FIFO TX interrupt mask */
N#define SPI_FIFO_RX_INTEN_MASK             (0x10)                         /*!< FIFO RX interrupt mask */
N#define SPI_FIFO_RXOVR_INTEN_MASK          (0x20)                         /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_TIMEOUT_INTEN_MASK        (0x40)                         /*!< FIFO timeout interrupt mask */
N
N
N/*@}*/ /* end of group NANO100_SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief  Abort the current transfer in slave 3-wire mode.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_ABORT_3WIRE_TRANSFER(spi) ( (spi)->SSR |= SPI_SSR_SLV_ABORT_Msk )
N
N/**
N  * @brief  Clear the slave 3-wire mode start interrupt flag.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_CLR_3WIRE_START_INT_FLAG(spi) ( (spi)->STATUS = SPI_STATUS_SLV_START_INTSTS_Msk )
N
N/**
N  * @brief  Clear the unit transfer interrupt flag.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_CLR_UNIT_TRANS_INT_FLAG(spi) ( (spi)->STATUS = SPI_STATUS_INTSTS_Msk )
N
N/**
N  * @brief  Disable slave 3-wire mode.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_DISABLE_3WIRE_MODE(spi) ( (spi)->SSR &= ~SPI_SSR_NOSLVSEL_Msk )
N
N/**
N  * @brief  Enable slave 3-wire mode.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_ENABLE_3WIRE_MODE(spi) ( (spi)->SSR |= SPI_SSR_NOSLVSEL_Msk )
N
N/**
N  * @brief  Get the count of available data in RX FIFO.
N  * @param[in]  spi is the base address of SPI module.
N  * @return The count of available data in RX FIFO.
N  * \hideinitializer
N  */
N#define SPI_GET_RX_FIFO_COUNT(spi) ( (((spi)->STATUS & SPI_STATUS_RX_FIFO_CNT_Msk) >> SPI_STATUS_RX_FIFO_CNT_Pos) & 0xf )
N
N/**
N  * @brief  Get the Rx FIFO empty flag.
N  * @param[in]  spi is the base address of SPI module.
N  * @return Rx FIFO flag
N  * @retval 0 Rx FIFO is not empty
N  * @retval 1 Rx FIFO is empty
N  * \hideinitializer
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi) ( ((spi)->STATUS & SPI_STATUS_RX_EMPTY_Msk) == SPI_STATUS_RX_EMPTY_Msk ? 1:0)
N
N/**
N  * @brief  Get the Tx FIFO empty flag.
N  * @param[in]  spi is the base address of SPI module.
N  * @return Tx FIFO flag
N  * @retval 0 Tx FIFO is not empty
N  * @retval 1 Tx FIFO is empty
N  * \hideinitializer
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi) ( ((spi)->STATUS & SPI_STATUS_TX_EMPTY_Msk) == SPI_STATUS_TX_EMPTY_Msk ? 1:0)
N
N/**
N  * @brief  Get the Tx FIFO full flag.
N  * @param[in]  spi is the base address of SPI module.
N  * @return Tx FIFO flag
N  * @retval 0 Tx FIFO is not full
N  * @retval 1 Tx FIFO is full
N  * \hideinitializer
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi) ( ((spi)->STATUS & SPI_STATUS_TX_FULL_Msk) == SPI_STATUS_TX_FULL_Msk ? 1:0)
N
N/**
N  * @brief  Get the datum read from RX0 FIFO.
N  * @param[in]  spi is the base address of SPI module.
N  * @return Data in Rx0 register.
N  * \hideinitializer
N  */
N#define SPI_READ_RX0(spi) ( (spi)->RX0 )
N
N/**
N  * @brief  Get the datum read from RX1 FIFO.
N  * @param[in]  spi is the base address of SPI module.
N  * @return Data in Rx1 register.
N  */
N#define SPI_READ_RX1(spi) ( (spi)->RX1 )
N
N/**
N  * @brief  Write datum to TX0 register.
N  * @param[in]  spi is the base address of SPI module.
N  * @param[in]  u32TxData is the datum which user attempt to transfer through SPI bus.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_WRITE_TX0(spi, u32TxData) ( (spi)->TX0 = u32TxData )
N
N/**
N  * @brief  Write datum to TX1 register.
N  * @param[in]  spi is the base address of SPI module.
N  * @param[in]  u32TxData is the datum which user attempt to transfer through SPI bus.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_WRITE_TX1(spi, u32TxData) ( (spi)->TX1 = u32TxData )
N
N/**
N  * @brief      Set SPIn_SS0 pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0 pin to high state. Only available in Master mode.
N  * \hideinitializer
N  */
N#define SPI_SET_SS0_HIGH(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS0)))
N
N/**
N  * @brief      Set SPIn_SS0 pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0 pin to low state. Only available in Master mode.
N  * \hideinitializer
N  */
N#define SPI_SET_SS0_LOW(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS0)) | SPI_SS0)
N
N/**
N  * @brief      Set SPIn_SS1 pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS1 pin to high state. Only available in Master mode.
N  * \hideinitializer
N  */
N#define SPI_SET_SS1_HIGH(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS1)))
N
N/**
N  * @brief      Set SPIn_SS1 pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS1 pin to low state. Only available in Master mode.
N  * \hideinitializer
N  */
N#define SPI_SET_SS1_LOW(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS1)) | SPI_SS1)
N
N/**
N  * @brief      Set SPIn_SS0, SPIn_SS1 pin to high or low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  ss0 0 = Set SPIn_SS0 to low. 1 = Set SPIn_SS0 to high.
N  * @param[in]  ss1 0 = Set SPIn_SS1 to low. 1 = Set SPIn_SS1 to high.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0/SPIn_SS1 pin to specified high/low state.
N  *             Only available in Master mode.
N  */
N#define SPI_SET_SS_LEVEL(spi, ss0, ss1)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SSR_SSR_Msk)) | (((ss1)^1) << 1) | ((ss0)^1))
N
N/**
N  * @brief Enable byte reorder function.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_ENABLE_BYTE_REORDER(spi) ( (spi)->CTL |= SPI_CTL_REORDER_Msk )
N
N/**
N  * @brief  Disable byte reorder function.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_DISABLE_BYTE_REORDER(spi) ( (spi)->CTL &= ~SPI_CTL_REORDER_Msk )
N
N/**
N  * @brief  Set the length of suspend interval.
N  * @param[in]  spi is the base address of SPI module.
N  * @param[in]  u32SuspCycle decides the length of suspend interval.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle) ( (spi)->CTL = ((spi)->CTL & ~SPI_CTL_SP_CYCLE_Msk) | (u32SuspCycle << SPI_CTL_SP_CYCLE_Pos) )
N
N/**
N  * @brief  Set the SPI transfer sequence with LSB first.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_SET_LSB_FIRST(spi) ( (spi)->CTL |= SPI_CTL_LSB_Msk )
N
N/**
N  * @brief  Set the SPI transfer sequence with MSB first.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_SET_MSB_FIRST(spi) ( (spi)->CTL &= ~SPI_CTL_LSB_Msk )
N
N/**
N  * @brief  Set the data width of a SPI transaction.
N  * @param[in]  spi is the base address of SPI module.
N  * @param[in]  u32Width is the data width (from 8-32 bits).
N  * @return none
N  * \hideinitializer
N  */
Nstatic __INLINE void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
Xstatic __inline void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
N{
N    if(u32Width == 32)
N        u32Width = 0;
N
N    spi->CTL = (spi->CTL & ~SPI_CTL_TX_BIT_LEN_Msk) | (u32Width << SPI_CTL_TX_BIT_LEN_Pos);
X    spi->CTL = (spi->CTL & ~(0x1ful << (3))) | (u32Width << (3));
N}
N
N/**
N  * @brief  Get the SPI busy state.
N  * @param[in]  spi is the base address of SPI module.
N  * @return SPI busy status
N  * @retval 0 SPI module is not busy
N  * @retval 1 SPI module is busy
N  * \hideinitializer
N  */
N#define SPI_IS_BUSY(spi) ( ((spi)->CTL & SPI_CTL_GO_BUSY_Msk) == SPI_CTL_GO_BUSY_Msk ? 1:0)
N
N/**
N  * @brief  Set the GO_BUSY bit to trigger SPI transfer.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_TRIGGER(spi) ( (spi)->CTL |= SPI_CTL_GO_BUSY_Msk )
N
N/**
N  * @brief  Disable SPI Dual IO function.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_DISABLE_DUAL_MODE(spi) ( (spi)->CTL &= ~SPI_CTL_DUAL_IO_EN_Msk )
N
N/**
N  * @brief  Enable Dual IO function and set SPI Dual IO direction to input.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_ENABLE_DUAL_INPUT_MODE(spi) ( (spi)->CTL = ((spi)->CTL & ~SPI_CTL_DUAL_IO_DIR_Msk) | SPI_CTL_DUAL_IO_EN_Msk )
N
N/**
N  * @brief  Enable Dual IO function and set SPI Dual IO direction to output.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_ENABLE_DUAL_OUTPUT_MODE(spi) ( (spi)->CTL |= (SPI_CTL_DUAL_IO_DIR_Msk | SPI_CTL_DUAL_IO_EN_Msk) )
N
N/**
N  * @brief  Trigger RX PDMA transfer.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_TRIGGER_RX_PDMA(spi) ( (spi)->DMA |= SPI_DMA_RX_DMA_EN_Msk )
N
N/**
N  * @brief  Trigger TX PDMA transfer.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_TRIGGER_TX_PDMA(spi) ( (spi)->DMA |= SPI_DMA_TX_DMA_EN_Msk )
N
N/**
N  * @brief  Enable 2-bit transfer mode.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_ENABLE_2BIT_MODE(spi) ( (spi)->CTL |= SPI_CTL_TWOB_Msk )
N
N/**
N  * @brief  Disable 2-bit transfer mode.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  * \hideinitializer
N  */
N#define  SPI_DISABLE_2BIT_MODE(spi) ( (spi)->CTL &= ~SPI_CTL_TWOB_Msk )
N
N/**
N  * @brief  Get the status register value.
N  * @param[in]  spi is the base address of SPI module.
N  * @return status value.
N  * \hideinitializer
N  */
N#define SPI_GET_STATUS(spi) ( (spi)->STATUS )
N
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nvoid SPI_DisableFIFO(SPI_T *spi);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_EnableWakeup(SPI_T *spi);
Nvoid SPI_DisableWakeup(SPI_T *spi);
N/*@}*/ /* end of group NANO100_SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_SPI_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SPI_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11941 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "timer.h"
L 1 "..\..\..\..\Library\StdDriver\inc\timer.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V1.00
N * $Revision: 6 $
N * $Date: 14/08/29 7:56p $
N * @brief    Nano100 series TIMER driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup NANO100_TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N
N#define TIMER_ONESHOT_MODE                      (0UL)                               /*!< Timer working in one shot mode   */
N#define TIMER_PERIODIC_MODE                     (1UL << TIMER_CTL_MODE_SEL_Pos)     /*!< Timer working in periodic mode   */
N#define TIMER_TOGGLE_MODE                       (2UL << TIMER_CTL_MODE_SEL_Pos)     /*!< Timer working in toggle mode     */
N#define TIMER_CONTINUOUS_MODE                   (3UL << TIMER_CTL_MODE_SEL_Pos)     /*!< Timer working in continuous mode */
N
N#define TIMER_CAPTURE_FREE_COUNTING_MODE        (0UL)                               /*!< Free counting mode    */
N#define TIMER_CAPTURE_TRIGGER_COUNTING_MODE     (TIMER_CTL_TCAP_CNT_MODE_Msk)       /*!< Trigger counting mode */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE        (TIMER_CTL_TCAP_MODE_Msk)           /*!< Counter reset mode    */
N
N#define TIMER_CAPTURE_FALLING_EDGE              (0UL)                               /*!< Falling edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_EDGE               (1UL << TIMER_CTL_TCAP_EDGE_Pos)    /*!< Rising edge trigger timer capture  */
N#define TIMER_CAPTURE_FALLING_THEN_RISING_EDGE  (2UL << TIMER_CTL_TCAP_EDGE_Pos)    /*!< Falling edge then rising edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_THEN_FALLING_EDGE  (3UL << TIMER_CTL_TCAP_EDGE_Pos)    /*!< Rising edge then falling edge trigger timer capture */
N
N#define TIMER_COUNTER_RISING_EDGE               (TIMER_CTL_EVENT_EDGE_Msk)          /*!< Counter increase on rising edge  */
N#define TIMER_COUNTER_FALLING_EDGE              (0UL)                               /*!< Counter increase on falling edge */
N
N#define TIMER_TIMEOUT_TRIGGER                   (0UL)                               /*!< Timer timeout trigger other modules */
N#define TIMER_CAPTURE_TRIGGER                   (TIMER_CTL_CAP_TRG_EN_Msk)          /*!< Timer capture trigger other modules */
N
N/*@}*/ /* end of group NANO100_TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to set new Timer compared value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer compare value. Valid values are between 2 to 0xFFFFFF
N  * @return None
N  * \hideinitializer
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value) ((timer)->CMPR = (u32Value))
N
N/**
N  * @brief This macro is used to set new Timer prescale value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer prescale value. Valid values are between 0 to 0xFF
N  * @return None
N  * @note Clock input is divided by (prescale + 1) before it is fed into timer
N  * \hideinitializer
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value) ((timer)->PRECNT = (u32Value))
N
N/**
N  * @brief This macro is used to check if specify Timer is inactive or active
N  * @return timer is activate or inactivate
N  * @retval 0 Timer 24-bit up counter is inactive
N  * @retval 1 Timer 24-bit up counter is active
N  * \hideinitializer
N  */
N#define TIMER_IS_ACTIVE(timer) ((timer)->CTL & TIMER_CTL_TMR_ACT_Msk ? 1 : 0)
N
N
N/**
N  * @brief This function is used to start Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_TMR_EN_Msk;
X    timer->CTL |= (0x1ul << (0));
N}
N
N/**
N  * @brief This function is used to stop Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_TMR_EN_Msk;
X    timer->CTL &= ~(0x1ul << (0));
N}
N
N/**
N  * @brief This function is used to enable the Timer wake-up function
N  * @param[in] timer The base address of Timer module
N  * @return None
N  * @note  To wake the system from power down mode, timer clock source must be ether LXT or LIRC
N  */
N__STATIC_INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_WAKE_EN_Msk;
X    timer->CTL |= (0x1ul << (2));
N}
N
N/**
N  * @brief This function is used to disable the Timer wake-up function
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_WAKE_EN_Msk;
X    timer->CTL &= ~(0x1ul << (2));
N}
N
N
N/**
N  * @brief This function is used to enable the capture pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_TCAP_DEB_EN_Msk;
X    timer->CTL |= (0x1ul << (22));
N}
N
N/**
N  * @brief This function is used to disable the capture pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_TCAP_DEB_EN_Msk;
X    timer->CTL &= ~(0x1ul << (22));
N}
N
N
N/**
N  * @brief This function is used to enable the counter pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_EVNT_DEB_EN_Msk;
X    timer->CTL |= (0x1ul << (14));
N}
N
N/**
N  * @brief This function is used to disable the counter pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_EVNT_DEB_EN_Msk;
X    timer->CTL &= ~(0x1ul << (14));
N}
N
N/**
N  * @brief This function is used to enable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->IER |= TIMER_IER_TMR_IE_Msk;
X    timer->IER |= (0x1ul << (0));
N}
N
N/**
N  * @brief This function is used to disable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->IER &= ~TIMER_IER_TMR_IE_Msk;
X    timer->IER &= ~(0x1ul << (0));
N}
N
N/**
N  * @brief This function is used to enable the Timer capture trigger interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->IER |= TIMER_IER_TCAP_IE_Msk;
X    timer->IER |= (0x1ul << (1));
N}
N
N/**
N  * @brief This function is used to disable the Timer capture trigger interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->IER &= ~TIMER_IER_TCAP_IE_Msk;
X    timer->IER &= ~(0x1ul << (1));
N}
N
N/**
N  * @brief This function indicates Timer time-out interrupt occurred or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer time-out interrupt occurred or not
N  * @retval 0 Timer time-out interrupt did not occur
N  * @retval 1 Timer time-out interrupt occurred
N  */
N__STATIC_INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return(timer->ISR & TIMER_ISR_TMR_IS_Msk ? 1 : 0);
X    return(timer->ISR & (0x1ul << (0)) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer time-out interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->ISR = TIMER_ISR_TMR_IS_Msk;
X    timer->ISR = (0x1ul << (0));
N}
N
N/**
N  * @brief This function indicates Timer capture interrupt occurred or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer capture interrupt occurred or not
N  * @retval 0 Timer capture interrupt did not occur
N  * @retval 1 Timer capture interrupt occurred
N  */
N__STATIC_INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return(timer->ISR & TIMER_ISR_TCAP_IS_Msk ? 1 : 0);
X    return(timer->ISR & (0x1ul << (1)) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer capture interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->ISR = TIMER_ISR_TCAP_IS_Msk;
X    timer->ISR = (0x1ul << (1));
N}
N
N/**
N  * @brief This function indicates Timer has waked up system or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer has waked up system or not
N  * @retval 0 Timer did not wake up system
N  * @retval 1 Timer wake up system
N  */
N__STATIC_INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return (timer->ISR & TIMER_ISR_TMR_WAKE_STS_Msk ? 1 : 0);
X    return (timer->ISR & (0x1ul << (4)) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer wakeup interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->ISR = TIMER_ISR_TMR_WAKE_STS_Msk;
X    timer->ISR = (0x1ul << (4));
N}
N
N/**
N  * @brief This function gets the Timer capture data.
N  * @param[in] timer The base address of Timer module
N  * @return Timer capture data value
N  */
N__STATIC_INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->TCAP;
N}
N
N/**
N  * @brief This function reports the current timer counter value.
N  * @param[in] timer The base address of Timer module
N  * @return Timer counter value
N  */
N__STATIC_INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->DR;
N}
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
Nvoid TIMER_EnableFreqCounter(TIMER_T *timer,
N                             uint32_t u32DropCount,
N                             uint32_t u32Timeout,
N                             uint32_t u32EnableInt);
Nvoid TIMER_DisableFreqCounter(TIMER_T *timer);
Nvoid TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src);
Nvoid TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask);
N
N/*@}*/ /* end of group NANO100_TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_TIMER_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11942 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "uart.h"
L 1 "..\..\..\..\Library\StdDriver\inc\uart.h" 1
N/**************************************************************************//**
N * @file     uart.h
N * @version  V1.00
N * $Revision: 9 $
N * $Date: 15/06/26 1:36p $
N * @brief    Nano100 Series uart control header file.
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __UART_H__
N#define __UART_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup NANO100_UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5        (0) /*!< UART_TLCTL setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6        (1) /*!< UART_TLCTL setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7        (2) /*!< UART_TLCTL setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8        (3) /*!< UART_TLCTL setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_TLCTL_PBE_Pos) /*!< UART_TLCTL setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_TLCTL_PBE_Pos) /*!< UART_TLCTL setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_TLCTL_PBE_Pos) /*!< UART_TLCTL setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_TLCTL_PBE_Pos) /*!< UART_TLCTL setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_TLCTL_PBE_Pos) /*!< UART_TLCTL setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_TLCTL_NSB_Pos) /*!< UART_TLCTL setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_TLCTL_NSB_Pos) /*!< UART_TLCTL setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_TLCTL_NSB_Pos) /*!< UART_TLCTL setting for two stop bit when 6, 7, 8-bit word length */
N
N#define UART_TLCTL_RFITL_1BYTE        (0x0 << UART_TLCTL_RFITL_Pos)   /*!< UART_TLCTL setting to set RX FIFO Trigger Level to 1 bit */
N#define UART_TLCTL_RFITL_4BYTES       (0x1 << UART_TLCTL_RFITL_Pos)   /*!< UART_TLCTL setting to set RX FIFO Trigger Level to 4 bits */
N#define UART_TLCTL_RFITL_8BYTES       (0x2 << UART_TLCTL_RFITL_Pos)   /*!< UART_TLCTL setting to set RX FIFO Trigger Level to 8 bits */
N#define UART_TLCTL_RFITL_14BYTES      (0x3 << UART_TLCTL_RFITL_Pos)   /*!< UART_TLCTL setting to set RX FIFO Trigger Level to 14 bits */
N
N#define UART_TLCTL_RTS_TRI_LEV_1BYTE        (0x0 << UART_TLCTL_RTS_TRI_LEV_Pos)  /*!< UART_TLCTL setting to set RTS Trigger Level to 1 bit */
N#define UART_TLCTL_RTS_TRI_LEV_4BYTES       (0x1 << UART_TLCTL_RTS_TRI_LEV_Pos)  /*!< UART_TLCTL setting to set RTS Trigger Level to 4 bits */
N#define UART_TLCTL_RTS_TRI_LEV_8BYTES       (0x2 << UART_TLCTL_RTS_TRI_LEV_Pos)  /*!< UART_TLCTL setting to set RTS Trigger Level to 8 bits */
N#define UART_TLCTL_RTS_TRI_LEV_14BYTES      (0x3 << UART_TLCTL_RTS_TRI_LEV_Pos)  /*!< UART_TLCTL setting to set RTS Trigger Level to 14 bits */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_HIGH_LEV_TRG    (0x1 << UART_MCSR_LEV_RTS_Pos) /*!< Set RTS is High Level Trigger   */
N#define UART_RTS_IS_LOW_LEV_TRG     (0x0 << UART_MCSR_LEV_RTS_Pos) /*!< Set RTS is Low Level Trigger    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART    (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UART_FUN_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_LIN     (0x1 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UART_FUN_SEL setting to set LIN Function             */
N#define UART_FUNC_SEL_IrDA    (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UART_FUN_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485   (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UART_FUN_SEL setting to set RS485 Function           */
N
N
N/*@}*/ /* end of group NANO100_UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    None
N *
N *    @return    UART baudrate mode0 register setting value
N *
N */
N#define UART_BAUD_MODE0        (0)
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    None
N *
N *    @return    UART baudrate mode1 register setting value
N *
N */
N#define UART_BAUD_MODE1        (UART_BAUD_DIV_16_EN_Msk)
N
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return    UART baudrate mode1 divider
N *
N */
N#define UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate*8)) / u32BaudRate >> 4)-1)
N
N/**
N *    @brief    Calculate UART baudrate mode2 divider
N *
N *    @param[in]    u32SrcFreq    UART clock frequency
N *    @param[in]    u32BaudRate    Baudrate of UART module
N *
N *    @return    UART baudrate mode0 divider
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate/2)) / u32BaudRate)-1)
N
N
N/**
N *    @brief    Write Data to Tx data register
N *
N *    @param[in]    uart        The base address of UART module.
N *    @param[in]    u8Data  Data byte to transmit
N *
N *    @return    None
N */
N#define UART_WRITE(uart, u8Data)    (uart->THR = (u8Data))
N
N/**
N *    @brief    Read Rx data register
N *
N *    @param[in]    uart        The base address of UART module.
N *
N *    @return    The oldest data byte in RX FIFO
N */
N#define UART_READ(uart)    (uart->RBR)
N
N
N/**
N *    @brief    Get Tx empty register value.
N *
N *    @param[in]    uart        The base address of UART module
N *
N *    @return    Tx empty register value.
N */
N#define UART_GET_TX_EMPTY(uart)    (uart->FSR & UART_FSR_TX_EMPTY_F_Msk)
N
N
N/**
N *    @brief    Get Rx empty register value.
N *
N *    @param[in]    uart        The base address of UART module
N *
N *    @return    Rx empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    (uart->FSR & UART_FSR_RX_EMPTY_F_Msk)
N
N/**
N *    @brief    Check specified uart port transmission is over.
N *
N *    @param[in]    uart        The base address of UART module
N *
N *    @return    TE_Flag.
N */
N#define UART_IS_TX_EMPTY(uart)    ((uart->FSR & UART_FSR_TE_F_Msk) >> UART_FSR_TE_F_Pos)
N
N
N/**
N *    @brief    Wait specified uart port transmission is over
N *
N *    @param[in]    uart        The base address of UART module
N *
N *    @return    None
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!(((uart->FSR) & UART_FSR_TX_EMPTY_F_Msk) >> UART_FSR_TX_EMPTY_F_Pos))
N
N/**
N *    @brief    Check RDA_IF is set or not
N *
N *    @param[in]    uart        The base address of UART module
N *
N *    @return
N *            0 : The number of bytes in the RX FIFO is less than the RFITL
N *            1 : The number of bytes in the RX FIFO equals or larger than RFITL
N */
N#define UART_IS_RX_READY(uart)    ((uart->ISR & UART_ISR_RDA_IS_Msk)>>UART_ISR_RDA_IS_Pos)
N
N
N/**
N *    @brief    Check TX FIFO is full or not
N *
N *    @param[in]    uart        The base address of UART module
N *
N *    @return
N *            1 = TX FIFO is full
N *            0 = TX FIFO is not full
N */
N#define UART_IS_TX_FULL(uart)    ((uart->FSR & UART_FSR_TX_FULL_F_Msk)>>UART_FSR_TX_FULL_F_Pos)
N
N/**
N *    @brief    Check RX FIFO is full or not
N *
N *    @param[in]    uart        The base address of UART module
N *
N *    @return
N *            1 = RX FIFO is full
N *            0 = RX FIFO is not full
N *
N */
N#define UART_IS_RX_FULL(uart)    ((uart->FSR & UART_FSR_RX_FULL_F_Msk)>>UART_FSR_RX_FULL_F_Pos)
N
N
N/**
N *    @brief    Get Tx full register value
N *
N *    @param[in]    uart        The base address of UART module
N *
N *    @return    Tx full register value
N */
N#define UART_GET_TX_FULL(uart)    (uart->FSR & UART_FSR_TX_FULL_F_Msk)
N
N
N/**
N *    @brief    Get Rx full register value
N *
N *    @param[in]    uart        The base address of UART module
N *
N *    @return    Rx full register value
N */
N#define UART_GET_RX_FULL(uart)    (uart->FSR & UART_FSR_RX_FULL_F_Msk)
N
N
N/**
N *    @brief    Enable specified interrupt
N *
N *    @param[in]    uart        The base address of UART module
N *    @param[in]    u32eIntSel    Interrupt type select
N *                        - \ref UART_IER_LIN_IE_Msk : LIN interrupt
N *                        - \ref UART_IER_ABAUD_IE_Msk : Auto baudrate interrupt
N *                        - \ref UART_IER_WAKE_IE_Msk : Wakeup interrupt
N *                        - \ref UART_IER_BUF_ERR_IE_Msk : Buffer Error interrupt
N *                        - \ref UART_IER_RTO_IE_Msk : Rx time-out interrupt
N *                        - \ref UART_IER_MODEM_IE_Msk : Modem interrupt
N *                        - \ref UART_IER_RLS_IE_Msk : Rx Line status interrupt
N *                        - \ref UART_IER_THRE_IE_Msk : Tx empty interrupt
N *                        - \ref UART_IER_RDA_IE_Msk : Rx ready interrupt
N *
N *    @return    None
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    (uart->IER |= (u32eIntSel))
N
N
N/**
N *    @brief    Disable specified interrupt
N *
N *    @param[in]    uart        The base address of UART module
N *    @param[in]    u32eIntSel    Interrupt type select
N *                        - \ref UART_IER_LIN_IE_Msk : LIN interrupt
N *                        - \ref UART_IER_ABAUD_IE_Msk : Auto baudrate interrupt
N *                        - \ref UART_IER_WAKE_IE_Msk : Wakeup interrupt
N *                        - \ref UART_IER_BUF_ERR_IE_Msk : Buffer Error interrupt
N *                        - \ref UART_IER_RTO_IE_Msk : Rx time-out interrupt
N *                        - \ref UART_IER_MODEM_IE_Msk : Modem interrupt
N *                        - \ref UART_IER_RLS_IE_Msk : Rx Line status interrupt
N *                        - \ref UART_IER_THRE_IE_Msk : Tx empty interrupt
N *                        - \ref UART_IER_RDA_IE_Msk : Rx ready interrupt
N *    @return    None
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    (uart->IER &= ~ (u32eIntSel))
N
N
N/**
N *    @brief    Get specified interrupt flag/status
N *
N *    @param[in]    uart            The base address of UART module
N *    @param[in]    u32eIntTypeFlag    Interrupt Type Flag,should be
N *                        - \ref UART_ISR_LIN_IS_Msk : LIN interrupt flag
N *                        - \ref UART_ISR_ABAUD_IS_Msk : Auto baudrate interrupt flag
N *                        - \ref UART_ISR_WAKE_IS_Msk : Wakeup interrupt flag
N *                        - \ref UART_ISR_BUF_ERR_IS_Msk : Buffer Error interrupt flag
N *                        - \ref UART_ISR_RTO_IS_Msk : Rx time-out interrupt flag
N *                        - \ref UART_ISR_MODEM_IS_Msk : Modem interrupt flag
N *                        - \ref UART_ISR_RLS_IS_Msk : Rx Line status interrupt flag
N *                        - \ref UART_ISR_THRE_IS_Msk : Tx empty interrupt flag
N *                        - \ref UART_ISR_RDA_IS_Msk : Rx ready interrupt flag
N *
N *    @return
N *            0 = The specified interrupt is not happened.
N *            1 = The specified interrupt is happened.
N */
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    ((uart->ISR & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief    Set RTS pin is low
N *
N *    @param[in]    uart        The base address of UART module
N *    @return    None
N */
N__INLINE void UART_CLEAR_RTS(UART_T* uart)
X__inline void UART_CLEAR_RTS(UART_T* uart)
N{
N    uart->MCSR |= UART_MCSR_LEV_RTS_Msk;
X    uart->MCSR |= (0x1ul << (0));
N}
N
N/**
N *    @brief    Set RTS pin is high
N *
N *    @param[in]    uart        The base address of UART module
N *    @return    None
N */
N__INLINE void UART_SET_RTS(UART_T* uart)
X__inline void UART_SET_RTS(UART_T* uart)
N{
N    uart->MCSR &= ~UART_MCSR_LEV_RTS_Msk;
X    uart->MCSR &= ~(0x1ul << (0));
N}
N
N/**
N *  @brief  Clear RS-485 Address Byte Detection Flag
N *
N *  @param[in]  uart    The base address of UART module
N *  @return None
N */
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    (uart->TRSR  |= UART_TRSR_RS485_ADDET_F_Msk)
N
N
N/**
N *    @brief    Get RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart        The base address of UART module
N *    @return    RS-485 Address Byte Detection Flag
N */
N#define UART_RS485_GET_ADDR_FLAG(uart)    ((uart->TRSR  & UART_TRSR_RS485_ADDET_F_Msk) >> UART_TRSR_RS485_ADDET_F_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart, uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart );
Nvoid UART_DisableFlowCtrl(UART_T* uart );
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_EnableFlowCtrl(UART_T* uart );
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nvoid UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength);
Nuint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group NANO100_UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_UART_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
N
N
N
N
N
N
N
L 11943 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "usbd.h"
L 1 "..\..\..\..\Library\StdDriver\inc\usbd.h" 1
N/**************************************************************************//**
N * @file     usbd.h
N * @brief    NANO100 series USB driver header file
N * @version  2.0.0
N * @date     20, September, 2014
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __USBD_H__
N#define __USBD_H__
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_USBD_Driver USBD Driver
N  @{
N*/
N
N/** @addtogroup NANO100_USBD_EXPORTED_STRUCTS USBD Exported Structs
N  @{
N*/
Ntypedef struct s_usbd_info
N{
N    uint8_t *gu8DevDesc;                /*!< Device descriptor */
N    uint8_t *gu8ConfigDesc;             /*!< Config descriptor */
N    uint8_t **gu8StringDesc;            /*!< Pointer for USB String Descriptor pointers */
N    uint8_t **gu8HidReportDesc;         /*!< Pointer for HID Report descriptor */
N    uint32_t *gu32HidReportSize;        /*!< Pointer for HID Report descriptor Size */
N    uint32_t *gu32ConfigHidDescIdx;     /*!< Pointer for HID Descriptor start index */
N} S_USBD_INFO_T;
N
N/// @cond HIDDEN_SYMBOLS
Nextern S_USBD_INFO_T gsInfo;
N/// @endcond /* HIDDEN_SYMBOLS */
N
N/*@}*/ /* end of group NANO100_USBD_EXPORTED_STRUCTS */
N
N/** @addtogroup NANO100_USBD_EXPORTED_CONSTANTS USBD Exported Constants
N  @{
N*/
N#define USBD_BUF_BASE   (USBD_BASE+0x100)
N
N#define USBD_MAX_EP     8
N
N#define EP0     0       /*!< Endpoint 0 */
N#define EP1     1       /*!< Endpoint 1 */
N#define EP2     2       /*!< Endpoint 2 */
N#define EP3     3       /*!< Endpoint 3 */
N#define EP4     4       /*!< Endpoint 4 */
N#define EP5     5       /*!< Endpoint 5 */
N#define EP6     6       /*!< Endpoint 6 */
N#define EP7     7       /*!< Endpoint 7 */
N
N/// @cond HIDDEN_SYMBOLS
Nextern volatile uint32_t g_usbd_UsbConfig;
N
N/*!<USB Request Type */
N#define REQ_STANDARD        0x00
N#define REQ_CLASS           0x20
N#define REQ_VENDOR          0x40
N
N/*!<USB Standard Request */
N#define GET_STATUS          0x00
N#define CLEAR_FEATURE       0x01
N#define SET_FEATURE         0x03
N#define SET_ADDRESS         0x05
N#define GET_DESCRIPTOR      0x06
N#define SET_DESCRIPTOR      0x07
N#define GET_CONFIGURATION   0x08
N#define SET_CONFIGURATION   0x09
N#define GET_INTERFACE       0x0A
N#define SET_INTERFACE       0x0B
N#define SYNC_FRAME          0x0C
N
N/*!<USB Descriptor Type */
N#define DESC_DEVICE         0x01
N#define DESC_CONFIG         0x02
N#define DESC_STRING         0x03
N#define DESC_INTERFACE      0x04
N#define DESC_ENDPOINT       0x05
N#define DESC_QUALIFIER      0x06
N#define DESC_OTHERSPEED     0x07
N
N/*!<USB HID Descriptor Type */
N#define DESC_HID            0x21
N#define DESC_HID_RPT        0x22
N
N/*!<USB Descriptor Length */
N#define LEN_DEVICE          18
N#define LEN_CONFIG          9
N#define LEN_INTERFACE       9
N#define LEN_ENDPOINT        7
N#define LEN_HID             9
N#define LEN_CCID            0x36
N
N/*!<USB Endpoint Type */
N#define EP_ISO              0x01
N#define EP_BULK             0x02
N#define EP_INT              0x03
N
N#define EP_INPUT            0x80
N#define EP_OUTPUT           0x00
N
N/*!<USB Feature Selector */
N#define FEATURE_DEVICE_REMOTE_WAKEUP    0x01
N#define FEATURE_ENDPOINT_HALT           0x00
N
N/// @endcond
N
N#define USBD_WAKEUP_EN          USBD_CTL_WAKEUP_EN_Msk      /*!< USB Wake-up Enable */
N#define USBD_DRVSE0             USBD_CTL_DRVSE0_Msk         /*!< Drive SE0 */
N
N#define USBD_DPPU_EN            USBD_CTL_DPPU_EN_Msk        /*!< USB D+ Pull-up Enable */
N#define USBD_PWRDN              USBD_CTL_PWRDB_Msk          /*!< PHY Turn-On */
N#define USBD_PHY_EN             USBD_CTL_PHY_EN_Msk         /*!< PHY Enable */
N#define USBD_USB_EN             USBD_CTL_USB_EN_Msk         /*!< USB Enable */
N
N#define USBD_INT_BUS            USBD_INTEN_BUSEVT_IE_Msk    /*!< USB Bus Event Interrupt */
N#define USBD_INT_USB            USBD_INTEN_USBEVT_IE_Msk    /*!< USB usb Event Interrupt */
N#define USBD_INT_FLDET          USBD_INTEN_FLDET_IE_Msk     /*!< USB Float Detect Interrupt */
N#define USBD_INT_WAKEUP         USBD_INTEN_WAKEUP_IE_Msk    /*!< USB Wake-up Interrupt */
N
N#define USBD_INTSTS_WAKEUP      USBD_INTSTS_WKEUP_STS_Msk   /*!< USB Wakeup Interrupt Status */
N#define USBD_INTSTS_FLDET       USBD_INTSTS_FLD_STS_Msk     /*!< USB Float Detect Interrupt Status */
N#define USBD_INTSTS_BUS         USBD_INTSTS_BUS_STS_Msk     /*!< USB Bus Event Interrupt Status */
N#define USBD_INTSTS_USB         USBD_INTSTS_USB_STS_Msk     /*!< USB usb Event Interrupt Status */
N#define USBD_INTSTS_SETUP       USBD_INTSTS_SETUP_Msk       /*!< USB Setup Event */
N#define USBD_INTSTS_EP0         USBD_INTSTS_EPEVT0_Msk      /*!< USB Endpoint 0 Event */
N#define USBD_INTSTS_EP1         USBD_INTSTS_EPEVT1_Msk      /*!< USB Endpoint 1 Event */
N#define USBD_INTSTS_EP2         USBD_INTSTS_EPEVT2_Msk      /*!< USB Endpoint 2 Event */
N#define USBD_INTSTS_EP3         USBD_INTSTS_EPEVT3_Msk      /*!< USB Endpoint 3 Event */
N#define USBD_INTSTS_EP4         USBD_INTSTS_EPEVT4_Msk      /*!< USB Endpoint 4 Event */
N#define USBD_INTSTS_EP5         USBD_INTSTS_EPEVT5_Msk      /*!< USB Endpoint 5 Event */
N#define USBD_INTSTS_EP6         USBD_INTSTS_EPEVT6_Msk      /*!< USB Endpoint 6 Event */
N#define USBD_INTSTS_EP7         USBD_INTSTS_EPEVT7_Msk      /*!< USB Endpoint 7 Event */
N
N#define USBD_STATE_USBRST       USBD_BUSSTS_USBRST_Msk      /*!< USB Bus Reset */
N#define USBD_STATE_SUSPEND      USBD_BUSSTS_SUSPEND_Msk     /*!< USB Bus Suspend */
N#define USBD_STATE_RESUME       USBD_BUSSTS_RESUME_Msk      /*!< USB Bus Resume */
N#define USBD_STATE_TIMEOUT      USBD_BUSSTS_TIMEOUT_Msk     /*!< USB Bus Timeout */
N
N#define USBD_CFG_SSTALL         USBD_CFG_SSTALL_Msk         /*!< Set Stall */
N#define USBD_CFG_CSTALL         USBD_CFG_CSTALL_Msk         /*!< Clear Stall */
N
N#define USBD_CFG_EPMODE_DISABLE (0ul << USBD_CFG_EPMODE_Pos)/*!< Endpoint Disable */
N#define USBD_CFG_EPMODE_OUT     (1ul << USBD_CFG_EPMODE_Pos)/*!< Out Endpoint */
N#define USBD_CFG_EPMODE_IN      (2ul << USBD_CFG_EPMODE_Pos)/*!< In Endpoint */
N#define USBD_CFG_TYPE_ISO       (1ul << USBD_CFG_ISOCH_Pos) /*!< Isochronous */
N
N
N/*@}*/ /* end of group NANO100_USBD_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_USBD_EXPORTED_FUNCTIONS USBD Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Compare two input numbers and return maximum one.
N  *
N  * @param[in]  a   First number to be compared.
N  * @param[in]  b   Second number to be compared.
N  *
N  * @return     Maximum value between a and b.
N  *
N  * @details    If a > b, then return a. Otherwise, return b.
N  */
N#define Maximum(a,b)                ((a)>(b) ? (a) : (b))
N
N
N/**
N  * @brief      Compare two input numbers and return minimum one
N  *
N  * @param[in]  a   First number to be compared
N  * @param[in]  b   Second number to be compared
N  *
N  * @return     Minimum value between a and b
N  *
N  * @details    If a < b, then return a. Otherwise, return b.
N  */
N#define Minimum(a,b)                ((a)<(b) ? (a) : (b))
N
N/**
N  * @brief      Enable USBD engine
N  * @param      None
N  * @retval     None
N  */
N#define USBD_ENABLE_USB()           ((uint32_t)(USBD->CTL |= 0xF))
N
N/**
N  * @brief      Disable USBD engine
N  * @param      None
N  * @retval     None
N  */
N#define USBD_DISABLE_USB()          ((uint32_t)(USBD->CTL &= ~USBD_USB_EN))
N
N/**
N  * @brief      Enable USBD PHY
N  * @param      None
N  * @retval     None
N  */
N#define USBD_ENABLE_PHY()           ((uint32_t)(USBD->CTL |= USBD_PHY_EN))
N
N/**
N  * @brief      Disable USBD PHY
N  * @param      None
N  * @retval     None
N  */
N#define USBD_DISABLE_PHY()          ((uint32_t)(USBD->CTL &= ~USBD_PHY_EN))
N
N/**
N  * @brief      Force USB PHY Transceiver to Drive SE0
N  * @param      None
N  * @retval     None
N  */
N#define USBD_SET_SE0()              ((uint32_t)(USBD->CTL |= USBD_DRVSE0))
N
N/**
N  * @brief      Release SE0
N  * @param      None
N  * @retval     None
N  */
N#define USBD_CLR_SE0()              ((uint32_t)(USBD->CTL &= ~USBD_DRVSE0))
N
N/**
N  * @brief      Set USBD address
N  * @param[in]  addr    host assign address number
N  * @retval     None
N  */
N#define USBD_SET_ADDR(addr)         (USBD->FADDR = (addr))
N
N/**
N  * @brief      Get USBD address
N  * @param      None
N  * @retval     USBD address
N  */
N#define USBD_GET_ADDR()             ((uint32_t)(USBD->FADDR))
N
N/**
N  * @brief      Enable USBD interrupt
N  * @param[in]  intr    interrupt mask
N  * @retval     None
N  */
N#define USBD_ENABLE_INT(intr)       (USBD->INTEN |= (intr))
N
N/**
N  * @brief      Get USBD interrupt flag
N  * @param      None
N  * @retval     interrupt status
N  */
N#define USBD_GET_INT_FLAG()         ((uint32_t)(USBD->INTSTS))
N
N/**
N  * @brief      Clear USBD interrupt
N  * @param[in]  flag    interrupt flag
N  * @retval     None
N  */
N#define USBD_CLR_INT_FLAG(flag)     (USBD->INTSTS = flag)
N
N/**
N  * @brief      Get USBD Endpoint status
N  * @param      None
N  * @retval     endpoint status
N  */
N#define USBD_GET_EP_FLAG()          ((uint32_t)(USBD->EPSTS))
N
N/**
N  * @brief      Get USBD bus state
N  * @param      None
N  * @retval     bus status
N  */
N#define USBD_GET_BUS_STATE()        ((uint32_t)(USBD->BUSSTS & 0xf))
N
N/**
N  * @brief      check cable connect state
N  * @param      None
N  * @retval     connect / disconnect
N  */
N#define USBD_IS_ATTACHED()          ((uint32_t)(USBD->BUSSTS & USBD_BUSSTS_FLDET_Msk))
N
N/**
N  * @brief      Stop USB endpoint transaction
N  * @param[in]  ep endpoint
N  * @retval     None
N  */
N#define USBD_STOP_TRANSACTION(ep)   (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) |= USBD_CFG_CLRRDY_Msk)
N
N/**
N  * @brief      Set USB data1 token
N  * @param[in]  ep endpoint
N  * @retval     None
N  */
N#define USBD_SET_DATA1(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) |= USBD_CFG_DSQ_SYNC_Msk)
N
N/**
N  * @brief      Set USB data0 token
N  * @param[in]  ep endpoint
N  * @retval     None
N  */
N#define USBD_SET_DATA0(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) &= (~USBD_CFG_DSQ_SYNC_Msk))
N
N/**
N  * @brief      Set USB payload size (IN data)
N  * @param[in]  ep endpoint
N  * @param[in]  size IN transfer length
N  * @retval     None
N  */
N#define USBD_SET_PAYLOAD_LEN(ep, size)  (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))) = (size))
N
N/**
N  * @brief      Get USB payload size (OUT data)
N  * @param[in]  ep endpoint
N  * @retval     received data length
N  */
N#define USBD_GET_PAYLOAD_LEN(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))))
N
N/**
N  * @brief      config endpoint
N  * @param[in]  ep endpoint
N  * @param[in]  config config value
N  * @retval     None
N  */
N#define USBD_CONFIG_EP(ep, config)      (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) = (config))
N
N/**
N  * @brief      Set buffer for USB endpoint
N  * @param[in]  ep endpoint
N  * @param[in]  offset buffer offset
N  * @retval     None
N  */
N#define USBD_SET_EP_BUF_ADDR(ep, offset)    (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))) = (offset))
N
N/**
N  * @brief      Get buffer for USB endpoint
N  * @param[in]  ep endpoint
N  * @retval     buffer offset
N  */
N#define USBD_GET_EP_BUF_ADDR(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))))
N
N/**
N  * @brief       Set USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID.
N  *
N  * @return      None
N  *
N  * @details     Set USB endpoint stall state for the specified endpoint ID. Endpoint will respond STALL token automatically.
N  *
N  */
N#define USBD_SET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) |= USBD_CFG_SSTALL_Msk)
N
N/**
N  * @brief       Clear USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID.
N  *
N  * @return      None
N  *
N  * @details     Clear USB endpoint stall state for the specified endpoint ID. Endpoint will respond ACK/NAK token.
N  */
N#define USBD_CLR_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) &= ~USBD_CFG_SSTALL_Msk)
N
N/**
N  * @brief       Get USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID.
N  *
N  * @retval      0      USB endpoint is not stalled.
N  * @retval      Others USB endpoint is stalled.
N  *
N  * @details     Get USB endpoint stall state of the specified endpoint ID.
N  *
N  */
N#define USBD_GET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) & USBD_CFG_SSTALL_Msk)
N
N/**
N  * @brief      To support byte access between USB SRAM and system SRAM
N  *
N  * @param[in]  dest Destination pointer.
N  *
N  * @param[in]  src  Source pointer.
N  *
N  * @param[in]  size Byte count.
N  *
N  * @return     None
N  *
N  * @details    This function will copy the number of data specified by size and src parameters to the address specified by dest parameter.
N  *
N  */
Nstatic __INLINE void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
Xstatic __inline void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
N{
N    while (size--) *dest++ = *src++;
N}
N
N
N/**
N * @brief       Set USB endpoint stall state
N *
N  * @param[in]   epnum  USB endpoint number
N * @return      None
N *
N * @details     Set USB endpoint stall state, endpoint will return STALL token.
N */
Nstatic __INLINE void USBD_SetStall(uint8_t epnum)
Xstatic __inline void USBD_SetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for (i=0; i<USBD_MAX_EP; i++)
X    for (i=0; i<8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *) (u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *) (u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            *((__IO uint32_t *) (u32CfgAddr)) = (u32Cfg | USBD_CFG_SSTALL);
X            *((volatile uint32_t *) (u32CfgAddr)) = (u32Cfg | (0x1ul << (9)));
N            break;
N        }
N    }
N}
N
N/**
N * @brief       Clear USB endpoint stall state
N *
N  * @param[in]   epnum  USB endpoint number
N * @return      None
N *
N * @details     Clear USB endpoint stall state, endpoint will return ACK/NAK token.
N */
Nstatic __INLINE void USBD_ClearStall(uint8_t epnum)
Xstatic __inline void USBD_ClearStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for (i=0; i<USBD_MAX_EP; i++)
X    for (i=0; i<8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *) (u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *) (u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            *((__IO uint32_t *) (u32CfgAddr)) = (u32Cfg & ~USBD_CFG_SSTALL);
X            *((volatile uint32_t *) (u32CfgAddr)) = (u32Cfg & ~(0x1ul << (9)));
N            break;
N        }
N    }
N}
N
N/**
N * @brief       Get USB endpoint stall state
N *
N  * @param[in]   epnum  USB endpoint number
N * @retval      0 USB endpoint is not stalled.
N * @retval      non-0 USB endpoint is stalled.
N *
N * @details     Get USB endpoint stall state.
N */
Nstatic __INLINE uint32_t USBD_GetStall(uint8_t epnum)
Xstatic __inline uint32_t USBD_GetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for (i=0; i<USBD_MAX_EP; i++)
X    for (i=0; i<8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) (((uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *) (u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *) (u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N            break;
N    }
N    return (u32Cfg & USBD_CFG_SSTALL);
X    return (u32Cfg & (0x1ul << (9)));
N}
N
N
N/*--------------------------------------------------------------------*/
Nextern volatile uint8_t g_usbd_RemoteWakeupEn;
N
Ntypedef void (*VENDOR_REQ)(void); /*!<USB Vendor request callback function */
N
Ntypedef void (*CLASS_REQ)(void); /*!<USB Class request callback function */
N
Ntypedef void (*SET_INTERFACE_REQ)(uint32_t u32AltInterface); /*!<USB Standard request "Set Interface" callback function */
N
N/*--------------------------------------------------------------------*/
Nvoid USBD_Open(S_USBD_INFO_T *param, CLASS_REQ pfnClassReq, SET_INTERFACE_REQ pfnSetInterface);
Nvoid USBD_Start(void);
Nvoid USBD_GetSetupPacket(uint8_t *buf);
Nvoid USBD_ProcessSetupPacket(void);
Nvoid USBD_StandardRequest(void);
Nvoid USBD_PrepareCtrlIn(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlIn(void);
Nvoid USBD_PrepareCtrlOut(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlOut(void);
Nvoid USBD_SwReset(void);
Nvoid USBD_SetVendorRequest(VENDOR_REQ pfnVendorReq);
Nvoid USBD_LockEpStall(uint32_t u32EpBitmap);
N
N
N/*@}*/ /* end of group NANO100_USBD_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_USBD_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N
N#endif //__USBD_H__
N
N/*** (C) COPYRIGHT 2013~2014 Nuvoton Technology Corp. ***/
L 11944 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "wdt.h"
L 1 "..\..\..\..\Library\StdDriver\inc\wdt.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 14/08/29 7:56p $
N * @brief    Nano100 series WDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup NANO100_WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N#define WDT_TIMEOUT_2POW4           (0UL << WDT_CTL_WTIS_Pos) /*!< WDT setting for timeout interval = 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6           (1UL << WDT_CTL_WTIS_Pos) /*!< WDT setting for timeout interval = 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8           (2UL << WDT_CTL_WTIS_Pos) /*!< WDT setting for timeout interval = 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10          (3UL << WDT_CTL_WTIS_Pos) /*!< WDT setting for timeout interval = 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12          (4UL << WDT_CTL_WTIS_Pos) /*!< WDT setting for timeout interval = 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14          (5UL << WDT_CTL_WTIS_Pos) /*!< WDT setting for timeout interval = 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16          (6UL << WDT_CTL_WTIS_Pos) /*!< WDT setting for timeout interval = 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18          (7UL << WDT_CTL_WTIS_Pos) /*!< WDT setting for timeout interval = 2^18 * WDT clocks */
N
N#define WDT_RESET_DELAY_3CLK        (3UL << WDT_CTL_WTRDSEL_Pos)    /*!< WDT setting reset delay to 3 WDT clocks */
N#define WDT_RESET_DELAY_18CLK       (2UL << WDT_CTL_WTRDSEL_Pos)    /*!< WDT setting reset delay to 18 WDT clocks */
N#define WDT_RESET_DELAY_130CLK      (1UL << WDT_CTL_WTRDSEL_Pos)    /*!< WDT setting reset delay to 130 WDT clocks */
N#define WDT_RESET_DELAY_1026CLK     (0UL << WDT_CTL_WTRDSEL_Pos)    /*!< WDT setting reset delay to 1026 WDT clocks */
N
N/*@}*/ /* end of group NANO100_WDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro clear WDT time-out reset system flag.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define WDT_CLEAR_RESET_FLAG()  (WDT->ISR = WDT_ISR_RST_IS_Msk)
N
N/**
N  * @brief This macro clear WDT time-out interrupt flag.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG() (WDT->ISR = WDT_ISR_IS_Msk)
N
N/**
N  * @brief This macro clear WDT time-out wake-up system flag.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->ISR = WDT_ISR_WAKE_IS_Msk)
N
N/**
N  * @brief This macro indicate WDT time-out to reset system or not.
N  * @return WDT reset system or not
N  * @retval 0 WDT did not cause system reset
N  * @retval 1 WDT caused system reset
N  * \hideinitializer
N  */
N#define WDT_GET_RESET_FLAG() (WDT->ISR & WDT_ISR_RST_IS_Msk ? 1 : 0)
N
N/**
N  * @brief This macro indicate WDT time-out interrupt occurred or not.
N  * @return WDT time-out interrupt occurred or not
N  * @retval 0 WDT time-out interrupt did not occur
N  * @retval 1 WDT time-out interrupt occurred
N  * \hideinitializer
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG() (WDT->ISR & WDT_ISR_IS_Msk ? 1 : 0)
N
N/**
N  * @brief This macro indicate WDT time-out waked system up or not
N  * @return WDT time-out waked system up or not
N  * @retval 0 WDT did not wake up system
N  * @retval 1 WDT waked up system
N  * \hideinitializer
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG() (WDT->ISR & WDT_ISR_WAKE_IS_Msk ? 1 : 0)
N
N/**
N  * @brief This macro is used to reset 18-bit WDT counter.
N  * @details If WDT is activated and enabled to reset system, software must reset WDT counter
N  *  before WDT time-out plus reset delay reached. Or WDT generate a reset signal.
N  * \hideinitializer
N  */
N#define WDT_RESET_COUNTER() (WDT->CTL  |= WDT_CTL_WTR_Msk)
N
N/**
N * @brief This function stops WDT counting and disable WDT module
N * @param None
N * @return None
N */
N__STATIC_INLINE void WDT_Close(void)
Xstatic __inline void WDT_Close(void)
N{
N    WDT->CTL = 0;
X    ((WDT_T *) (((uint32_t)0x40000000) + 0x04000))->CTL = 0;
N    return;
N}
N
N/**
N * @brief This function enables the WDT time-out interrupt
N * @param None
N * @return None
N */
N__STATIC_INLINE void WDT_EnableInt(void)
Xstatic __inline void WDT_EnableInt(void)
N{
N    WDT->IER = WDT_IER_IE_Msk;
X    ((WDT_T *) (((uint32_t)0x40000000) + 0x04000))->IER = (0x1ul << (0));
N    return;
N}
N
N/**
N * @brief This function disables the WDT time-out interrupt
N * @param None
N * @return None
N */
N__STATIC_INLINE void WDT_DisableInt(void)
Xstatic __inline void WDT_DisableInt(void)
N{
N    WDT->IER = 0;
X    ((WDT_T *) (((uint32_t)0x40000000) + 0x04000))->IER = 0;
N    return;
N}
N
Nvoid  WDT_Open(uint32_t u32TimeoutInterval,
N               uint32_t u32ResetDelay,
N               uint32_t u32EnableReset,
N               uint32_t u32EnableWakeup);
N
N/*@}*/ /* end of group NANO100_WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_WDT_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11945 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "wwdt.h"
L 1 "..\..\..\..\Library\StdDriver\inc\wwdt.h" 1
N/**************************************************************************//**
N * @file     wwdt.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 14/01/14 5:38p $
N * @brief    Nano100 series WWDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WWDT_H__
N#define __WWDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_WWDT_Driver WWDT Driver
N  @{
N*/
N
N/** @addtogroup NANO100_WWDT_EXPORTED_CONSTANTS WWDT Exported Constants
N  @{
N*/
N#define WWDT_PRESCALER_1          (0UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 1    */
N#define WWDT_PRESCALER_2          (1UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 2    */
N#define WWDT_PRESCALER_4          (2UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 4    */
N#define WWDT_PRESCALER_8          (3UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 8    */
N#define WWDT_PRESCALER_16         (4UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 16   */
N#define WWDT_PRESCALER_32         (5UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 32   */
N#define WWDT_PRESCALER_64         (6UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 64   */
N#define WWDT_PRESCALER_128        (7UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 128  */
N#define WWDT_PRESCALER_192        (8UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 192  */
N#define WWDT_PRESCALER_256        (9UL << WWDT_CR_PERIODSEL_Pos)   /*!< WWDT setting prescaler to 256  */
N#define WWDT_PRESCALER_384        (0xAUL << WWDT_CR_PERIODSEL_Pos) /*!< WWDT setting prescaler to 384  */
N#define WWDT_PRESCALER_512        (0xBUL << WWDT_CR_PERIODSEL_Pos) /*!< WWDT setting prescaler to 512  */
N#define WWDT_PRESCALER_768        (0xCUL << WWDT_CR_PERIODSEL_Pos) /*!< WWDT setting prescaler to 768  */
N#define WWDT_PRESCALER_1024       (0xDUL << WWDT_CR_PERIODSEL_Pos) /*!< WWDT setting prescaler to 1024 */
N#define WWDT_PRESCALER_1536       (0xEUL << WWDT_CR_PERIODSEL_Pos) /*!< WWDT setting prescaler to 1536 */
N#define WWDT_PRESCALER_2048       (0xFUL << WWDT_CR_PERIODSEL_Pos) /*!< WWDT setting prescaler to 2048 */
N
N#define WWDT_RELOAD_WORD          (0x00005AA5)                     /*!< Fill this value to RLD register to reload WWDT counter */
N/*@}*/ /* end of group NANO100_WWDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_WWDT_EXPORTED_FUNCTIONS WWDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro clear WWDT time-out reset system flag.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define WWDT_CLEAR_RESET_FLAG()  (WWDT->STS = WWDT_STS_RF_Msk)
N
N/**
N  * @brief This macro clears WWDT compare match interrupt flag.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define WWDT_CLEAR_INT_FLAG() (WWDT->STS = WWDT_STS_IF_Msk)
N
N/**
N  * @brief This macro is use to get WWDT time-out reset system flag.
N  * @return WWDT reset system or not
N  * @retval 0 WWDT did not cause system reset
N  * @retval 1 WWDT caused system reset
N  * \hideinitializer
N  */
N#define WWDT_GET_RESET_FLAG() (WWDT->STS & WWDT_STS_RF_Msk ? 1 : 0)
N
N/**
N  * @brief This macro is used to indicate WWDT compare match interrupt flag.
N  * @return WWDT compare match interrupt occurred or not
N  * @retval 0 WWDT compare match interrupt did not occur
N  * @retval 1 WWDT compare match interrupt occurred
N  * \hideinitializer
N  */
N#define WWDT_GET_INT_FLAG() (WWDT->STS & WWDT_STS_IF_Msk ? 1 : 0)
N
N/**
N  * @brief This macro to reflects current WWDT counter value
N  * @param None
N  * @return Return current WWDT counter value
N  * \hideinitializer
N  */
N#define WWDT_GET_COUNTER() (WWDT->VAL)
N
N/**
N  * @brief This macro is used to reload the WWDT counter value to 0x3F.
N  * @param None
N  * @return None
N  * @details After WWDT enabled, application must reload WWDT counter while
N  *          current counter is less than compare value and larger than 0,
N  *          otherwise WWDT will cause system reset.
N  * \hideinitializer
N  */
N#define WWDT_RELOAD_COUNTER() (WWDT->RLD  = WWDT_RELOAD_WORD)
N
N
Nvoid WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);
N
N
N/*@}*/ /* end of group NANO100_WWDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NANO100_WWDT_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WWDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11946 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "i2s.h"
L 1 "..\..\..\..\Library\StdDriver\inc\i2s.h" 1
N/**************************************************************************//**
N * @file     i2s.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 15/06/08 4:59p $
N * @brief    Nano100 series I2S driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __I2S_H__
N#define __I2S_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_I2S_Driver I2S Driver
N  @{
N*/
N
N/** @addtogroup NANO100_I2S_EXPORTED_CONSTANTS I2S Exported Constants
N  @{
N*/
N#define I2S_DATABIT_8           (0 << I2S_CTRL_WORDWIDTH_Pos)       /*!< I2S data width is 8-bit */
N#define I2S_DATABIT_16          (1 << I2S_CTRL_WORDWIDTH_Pos)       /*!< I2S data width is 16-bit */
N#define I2S_DATABIT_24          (2 << I2S_CTRL_WORDWIDTH_Pos)       /*!< I2S data width is 24-bit */
N#define I2S_DATABIT_32          (3 << I2S_CTRL_WORDWIDTH_Pos)       /*!< I2S data width is 32-bit */
N
N/* Audio Format */
N#define I2S_MONO                I2S_CTRL_MONO_Msk                   /*!< Mono channel */
N#define I2S_STEREO              0                                  /*!< Stereo channel */
N
N/* I2S Data Format */
N#define I2S_FORMAT_MSB          I2S_CTRL_FORMAT_Msk                 /*!< MSB data format */
N#define I2S_FORMAT_I2S          0                                  /*!< I2S data format */
N
N/* I2S Interface */
N#define I2S_I2S                 0                                  /*!< I2S interface is selected */
N
N/* I2S Operation mode */
N#define I2S_MODE_SLAVE          I2S_CTRL_SLAVE_Msk                  /*!< As slave mode */
N#define I2S_MODE_MASTER         0                                  /*!< As master mode */
N
N/* I2S FIFO Threshold */
N#define I2S_FIFO_TX_LEVEL_WORD_0    0                              /*!< TX threshold is 0 word */
N#define I2S_FIFO_TX_LEVEL_WORD_1    (1 << I2S_CTRL_TXTH_Pos)        /*!< TX threshold is 1 word */
N#define I2S_FIFO_TX_LEVEL_WORD_2    (2 << I2S_CTRL_TXTH_Pos)        /*!< TX threshold is 2 words */
N#define I2S_FIFO_TX_LEVEL_WORD_3    (3 << I2S_CTRL_TXTH_Pos)        /*!< TX threshold is 3 words */
N#define I2S_FIFO_TX_LEVEL_WORD_4    (4 << I2S_CTRL_TXTH_Pos)        /*!< TX threshold is 4 words */
N#define I2S_FIFO_TX_LEVEL_WORD_5    (5 << I2S_CTRL_TXTH_Pos)        /*!< TX threshold is 5 words */
N#define I2S_FIFO_TX_LEVEL_WORD_6    (6 << I2S_CTRL_TXTH_Pos)        /*!< TX threshold is 6 words */
N#define I2S_FIFO_TX_LEVEL_WORD_7    (7 << I2S_CTRL_TXTH_Pos)        /*!< TX threshold is 7 words */
N
N#define I2S_FIFO_RX_LEVEL_WORD_1    0                              /*!< RX threshold is 1 word */
N#define I2S_FIFO_RX_LEVEL_WORD_2    (1 << I2S_CTRL_RXTH_Pos)        /*!< RX threshold is 2 words */
N#define I2S_FIFO_RX_LEVEL_WORD_3    (2 << I2S_CTRL_RXTH_Pos)        /*!< RX threshold is 3 words */
N#define I2S_FIFO_RX_LEVEL_WORD_4    (3 << I2S_CTRL_RXTH_Pos)        /*!< RX threshold is 4 words */
N#define I2S_FIFO_RX_LEVEL_WORD_5    (4 << I2S_CTRL_RXTH_Pos)        /*!< RX threshold is 5 words */
N#define I2S_FIFO_RX_LEVEL_WORD_6    (5 << I2S_CTRL_RXTH_Pos)        /*!< RX threshold is 6 words */
N#define I2S_FIFO_RX_LEVEL_WORD_7    (6 << I2S_CTRL_RXTH_Pos)        /*!< RX threshold is 7 words */
N#define I2S_FIFO_RX_LEVEL_WORD_8    (7 << I2S_CTRL_RXTH_Pos)        /*!< RX threshold is 8 words */
N
N/* I2S Record Channel */
N#define I2S_MONO_RIGHT          0                                  /*!< Record mono right channel */
N#define I2S_MONO_LEFT           I2S_CTRL_RXLCH_Msk                  /*!< Record mono left channel */
N
N/* I2S Channel */
N#define I2S_RIGHT               0                                  /*!< Select right channel */
N#define I2S_LEFT                1                                  /*!< Select left channel */
N
N/*@}*/ /* end of group NANO100_I2S_EXPORTED_CONSTANTS */
N
N/** @addtogroup NANO100_I2S_EXPORTED_FUNCTIONS I2S Exported Functions
N  @{
N*/
N/**
N  * @brief  Enable zero cross detect function.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32ChMask is the mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return none
N  * \hideinitializer
N  */
Nstatic __INLINE void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->CTRL |= I2S_CTRL_RCHZCEN_Msk;
X        i2s->CTRL |= (0x1ul << (16));
N    else
N        i2s->CTRL |= I2S_CTRL_LCHZCEN_Msk;
X        i2s->CTRL |= (0x1ul << (17));
N}
N
N/**
N  * @brief  Disable zero cross detect function.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32ChMask is the mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return none
N  * \hideinitializer
N  */
Nstatic __INLINE void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->CTRL &= ~I2S_CTRL_RCHZCEN_Msk;
X        i2s->CTRL &= ~(0x1ul << (16));
N    else
N        i2s->CTRL &= ~I2S_CTRL_LCHZCEN_Msk;
X        i2s->CTRL &= ~(0x1ul << (17));
N}
N
N/**
N  * @brief  Enable I2S Tx DMA function. I2S requests DMA to transfer data to Tx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_TXDMA(i2s) ( (i2s)->CTRL |= I2S_CTRL_TXDMA_Msk )
N
N/**
N  * @brief  Disable I2S Tx DMA function. I2S requests DMA to transfer data to Tx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_TXDMA(i2s) ( (i2s)->CTRL &= ~I2S_CTRL_TXDMA_Msk )
N
N/**
N  * @brief  Enable I2S Rx DMA function. I2S requests DMA to transfer data from Rx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_RXDMA(i2s) ( (i2s)->CTRL |= I2S_CTRL_RXDMA_Msk )
N
N/**
N  * @brief  Disable I2S Rx DMA function. I2S requests DMA to transfer data from Rx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_RXDMA(i2s) ( (i2s)->CTRL &= ~I2S_CTRL_RXDMA_Msk )
N
N/**
N  * @brief  Enable I2S Tx function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_TX(i2s)  ( (i2s)->CTRL |= I2S_CTRL_TXEN_Msk )
N
N/**
N  * @brief  Disable I2S Tx function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_TX(i2s) ( (i2s)->CTRL &= ~I2S_CTRL_TXEN_Msk )
N
N/**
N  * @brief  Enable I2S Rx function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_RX(i2s) ( (i2s)->CTRL |= I2S_CTRL_RXEN_Msk )
N
N/**
N  * @brief  Disable I2S Rx function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_RX(i2s) ( (i2s)->CTRL &= ~I2S_CTRL_RXEN_Msk )
N
N/**
N  * @brief  Enable Tx Mute function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_ENABLE_TX_MUTE(i2s) ( (i2s)->CTRL |= I2S_CTRL_MUTE_Msk )
N
N/**
N  * @brief  Disable Tx Mute function .
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_DISABLE_TX_MUTE(i2s) ( (i2s)->CTRL &= ~I2S_CTRL_MUTE_Msk )
N
N/**
N  * @brief  Clear Tx FIFO. Internal pointer is reset to FIFO start point.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_CLR_TX_FIFO(i2s) ( (i2s)->CTRL |= I2S_CTRL_CLR_TXFIFO_Msk )
N
N/**
N  * @brief  Clear Rx FIFO. Internal pointer is reset to FIFO start point.
N  * @param[in] i2s is the base address of I2S module.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_CLR_RX_FIFO(i2s) ( (i2s)->CTRL |= I2S_CTRL_CLR_RXFIFO_Msk )
N
N/**
N  * @brief  This function sets the recording source channel when mono mode is used.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32Ch left or right channel. Valid values are:
N  *                - \ref I2S_MONO_LEFT
N  *                - \ref I2S_MONO_RIGHT
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_SET_MONO_RX_CHANNEL(i2s, u32Ch) ( u32Ch == I2S_MONO_LEFT ? ((i2s)->CTRL |= I2S_CTRL_RXLCH_Msk) : ((i2s)->CTRL &= ~I2S_CTRL_RXLCH_Msk) )
N
N/**
N  * @brief  Write data to I2S Tx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32Data The data written to FIFO.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_WRITE_TX_FIFO(i2s, u32Data) ( (i2s)->TXFIFO = u32Data )
N
N/**
N  * @brief  Read Rx FIFO.
N  * @param[in] i2s is the base address of I2S module.
N  * @return Data in Rx FIFO.
N  * \hideinitializer
N  */
N#define I2S_READ_RX_FIFO(i2s) ( (i2s)->RXFIFO )
N
N/**
N  * @brief  This function gets the interrupt flag according to the mask parameter.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32Mask is the mask for the all interrupt flags.
N  * @return The masked bit value of interrupt flag.
N  * \hideinitializer
N  */
N#define I2S_GET_INT_FLAG(i2s, u32Mask) ((i2s)->STATUS & (u32Mask))
N
N/**
N  * @brief  This function clears the interrupt flag according to the mask parameter.
N  * @param[in] i2s is the base address of I2S module.
N  * @param[in] u32Mask is the mask for the all interrupt flags.
N  * @return none
N  * \hideinitializer
N  */
N#define I2S_CLR_INT_FLAG(i2s, u32Mask) ( (i2s)->STATUS |= (u32Mask) )
N
N/**
N  * @brief  Get transmit FIFO level
N  * @param[in] i2s is the base address of I2S module.
N  * @return FIFO level
N  * \hideinitializer
N  */
N#define I2S_GET_TX_FIFO_LEVEL(i2s) ((((i2s)->STATUS & I2S_STATUS_TX_LEVEL_Msk) >> I2S_STATUS_TX_LEVEL_Pos) & 0xF)
N
N/**
N  * @brief  Get receive FIFO level
N  * @param[in] i2s is the base address of I2S module.
N  * @return FIFO level
N  * \hideinitializer
N  */
N#define I2S_GET_RX_FIFO_LEVEL(i2s) ((((i2s)->STATUS & I2S_STATUS_RX_LEVEL_Msk) >> I2S_STATUS_RX_LEVEL_Pos) & 0xF)
N
Nuint32_t I2S_Open(I2S_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat, uint32_t u32AudioInterface);
Nvoid I2S_Close(I2S_T *i2s);
Nvoid I2S_EnableInt(I2S_T *i2s, uint32_t u32Mask);
Nvoid I2S_DisableInt(I2S_T *i2s, uint32_t u32Mask);
Nuint32_t I2S_EnableMCLK(I2S_T *i2s, uint32_t u32BusClock);
Nvoid I2S_DisableMCLK(I2S_T *i2s);
Nvoid I2S_SetFIFO(I2S_T *i2s, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
N
N/*@}*/ /* end of group NANO100_I2S_EXPORTED_FUNCTIONS */
N
N
N/*@}*/ /* end of group NANO100_I2S_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__I2S_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 11947 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N#include "lcd.h"
L 1 "..\..\..\..\Library\StdDriver\inc\lcd.h" 1
N/****************************************************************************//**
N * @file     lcd.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 15/06/26 1:30p $
N * @brief    Nano100 series I2C driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __LCD_H__
N#define __LCD_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N#include <stdint.h>
N//#include <stdbool.h>
N
N
N/** @addtogroup NANO100_Device_Driver NANO100 Device Driver
N  @{
N*/
N
N/** @addtogroup NANO100_LCD_Driver LCD Driver
N  @{
N*/
N
N
N/** @addtogroup NANO100_LCD_EXPORTED_CONSTANTS LCD Exported Constants
N  @{
N*/
N
N/// @cond
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/// @endcond
N
N#define LCD_FREQ_DIV32      ((uint32_t) 0x00000000) /*!< Clock source (32 or 10KHz) divide by 32 */
N#define LCD_FREQ_DIV64      ((uint32_t) 0x00000010) /*!< Clock source (32 or 10KHz) divide by 64 */
N#define LCD_FREQ_DIV96      ((uint32_t) 0x00000020) /*!< Clock source (32 or 10KHz) divide by 96 */
N#define LCD_FREQ_DIV128     ((uint32_t) 0x00000030) /*!< Clock source (32 or 10KHz) divide by 128 */
N#define LCD_FREQ_DIV192     ((uint32_t) 0x00000040) /*!< Clock source (32 or 10KHz) divide by 192 */
N#define LCD_FREQ_DIV256     ((uint32_t) 0x00000050) /*!< Clock source (32 or 10KHz) divide by 256 */
N#define LCD_FREQ_DIV384     ((uint32_t) 0x00000060) /*!< Clock source (32 or 10KHz) divide by 384 */
N#define LCD_FREQ_DIV512     ((uint32_t) 0x00000070) /*!< Clock source (32 or 10KHz) divide by 512 */
N
N#define LCD_MUX_STATIC      ((uint32_t) 0x00000000) /*!< Static multiplexing */
N#define LCD_MUX_ONE_SECOND  ((uint32_t) 0x00000002) /*!< Duplex multiplexing */
N#define LCD_MUX_ONE_THIRD   ((uint32_t) 0x00000004) /*!< Triplex multiplexing */
N#define LCD_MUX_ONE_FOURTH  ((uint32_t) 0x00000006) /*!< Quadruplex multiplexing */
N#define LCD_MUX_ONE_FIFTH   ((uint32_t) 0x00000008) /*!< 1/5 duty */
N#define LCD_MUX_ONE_SIXTH   ((uint32_t) 0x0000000A) /*!< 1/6 duty */
N
N#define LCD_BIAS_STATIC     ((uint32_t) 0x00000000) /*!< Static bias */
N#define LCD_BIAS_HALF       ((uint32_t) 0x00000002) /*!< 1/2 bias */
N#define LCD_BIAS_THIRD      ((uint32_t) 0x00000004) /*!< 1/3 bias */
N
N#define LCD_CPUMP_DIV1      ((uint32_t) 0x00000000) /*!< Clock source (32 or 10KHz) divide by 1 and is used by analog component */
N#define LCD_CPUMP_DIV2      ((uint32_t) 0x00000800) /*!< Clock source (32 or 10KHz) divide by 2 */
N#define LCD_CPUMP_DIV4      ((uint32_t) 0x00001000) /*!< Clock source (32 or 10KHz) divide by 4 */
N#define LCD_CPUMP_DIV8      ((uint32_t) 0x00001800) /*!< Clock source (32 or 10KHz) divide by 8 */
N#define LCD_CPUMP_DIV16     ((uint32_t) 0x00002000) /*!< Clock source (32 or 10KHz) divide by 16 */
N#define LCD_CPUMP_DIV32     ((uint32_t) 0x00002800) /*!< Clock source (32 or 10KHz) divide by 32 */
N#define LCD_CPUMP_DIV64     ((uint32_t) 0x00003000) /*!< Clock source (32 or 10KHz) divide by 64 */
N#define LCD_CPUMP_DIV128    ((uint32_t) 0x00003800) /*!< Clock source (32 or 10KHz) divide by 128 */
N
N#define LCD_CPVOl_2_6V  ((uint32_t) 0x00000000) /*!< Set charge pump voltage to 2.6 V */
N#define LCD_CPVOl_2_7V  ((uint32_t) 0x00000100) /*!< Set charge pump voltage to 2.7 V */
N#define LCD_CPVOl_2_8V  ((uint32_t) 0x00000200) /*!< Set charge pump voltage to 2.8 V */
N#define LCD_CPVOl_2_9V  ((uint32_t) 0x00000300) /*!< Set charge pump voltage to 2.9 V */
N#define LCD_CPVOl_3V    ((uint32_t) 0x00000400) /*!< Set charge pump voltage to 3 V */
N#define LCD_CPVOl_3_1V  ((uint32_t) 0x00000500) /*!< Set charge pump voltage to 3.1 V */
N#define LCD_CPVOl_3_2V  ((uint32_t) 0x00000600) /*!< Set charge pump voltage to 3.2 V */
N#define LCD_CPVOl_3_3V  ((uint32_t) 0x00000700) /*!< Set charge pump voltage to 3.3 V */
N
N#define LCD_FCPRESC_DIV1 ((uint32_t) 0x00000000)    /*!< Set pre-scale divider value to 1 */
N#define LCD_FCPRESC_DIV2 ((uint32_t) 0x00000004)    /*!< Set pre-scale divider value to 2 */
N#define LCD_FCPRESC_DIV4 ((uint32_t) 0x00000008)    /*!< Set pre-scale divider value to 4 */
N#define LCD_FCPRESC_DIV8 ((uint32_t) 0x0000000C)    /*!< Set pre-scale divider value to 8 */
N
N#define LCD_FRAMECOUNT_INT  ((uint32_t) 0x00000001) /*!< Indicate frame count interrupt */
N#define LCD_POWERDOWN_INT   ((uint32_t) 0x00000002) /*!< Indicate power down interrupt */
N#define LCD_ALL_INT         ((uint32_t) 0x00000003) /*!< Indicate frame count & power down interrupt */
N
N#define ERR_LCD_CAL_BLINK_FAIL      0xFFFF0000              /*!< Specifies that overflow to calculate the blinking frequency */
N
N/*@}*/ /* end of group NANO100_LCD_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NANO100_LCD_EXPORTED_STRUCTS LCD Exported Structs
N  @{
N*/
Ntypedef enum
N{
N    LCD_C_TYPE = 0,          /*!< Select LCD C-Type */
N    LCD_EXTERNAL_R_TYPE = 1, /*!< Select LCD External R-Type */
N    LCD_INTERNAL_R_TYPE = 2, /*!< Select LCD Internal R-Type */
N    LCD_EXTERNAL_C_TYPE = 3  /*!< Select LCD External C-Type */
N} LCD_PanelType;
N
N/*@}*/ /* end of group NANO100_LCD_EXPORTED_STRUCTS */
N
N
N/** @addtogroup NANO100_LCD_EXPORTED_FUNCTIONS LCD Exported Functions
N  @{
N*/
N
N/**
N *    @brief    Get LCD Power Down interrupt flag.
N *
N *    @param    None
N *
N *    @return    LCD Power Down interrupt Flag.
N */
N#define LCD_GET_PD_INT_FLAG()        ((LCD->FCSTS & LCD_FCSTS_PDSTS_Msk) >> LCD_FCSTS_PDSTS_Pos)
N
N/**
N *    @brief    Clear LCD Power Down interrupt flag.
N *
N *    @param    None
N *
N *    @return   None.
N */
N#define LCD_CLR_PD_INT_FLAG()        (LCD->FCSTS = LCD_FCSTS_PDSTS_Msk)
N
N/**
N *    @brief    Get LCD Frame Count interrupt flag.
N *
N *    @param    None
N *
N *    @return    LCD Frame Count interrupt Flag.
N */
N#define LCD_GET_FRAME_CNT_INT_FLAG()  ((LCD->FCSTS & LCD_FCSTS_FCSTS_Msk) >> LCD_FCSTS_FCSTS_Pos)
N
N/**
N *    @brief    Clear LCD Frame Count interrupt flag.
N *
N *    @param    None
N *
N *    @return   None.
N */
N#define LCD_CLR_FRAME_CNT_INT_FLAG()   (LCD->FCSTS = LCD_FCSTS_FCSTS_Msk)
N
N/**
N *    @brief    Enable LCD Power Down Display function.
N *
N *    @param    None
N *
N *    @return   None.
N */
N#define LCD_ENABLE_PD_DISPLAY()    (LCD->CTL |= LCD_CTL_PDDISP_EN_Msk)
N
N/**
N *    @brief    Disable LCD Power Down Display function.
N *
N *    @param    None
N *
N *    @return   None.
N */
N#define LCD_DISABLE_PD_DISPLAY()   (LCD->CTL &= ~LCD_CTL_PDDISP_EN_Msk)
N
Nuint32_t LCD_EnableFrameCounter(uint32_t u32Count);
Nvoid LCD_DisableFrameCounter(void);
Nuint32_t LCD_EnableBlink(uint32_t u32ms);
Nvoid LCD_DisableBlink(void);
Nvoid LCD_EnableInt(uint32_t IntSrc);
Nvoid LCD_DisableInt(uint32_t IntSrc);
Nuint32_t LCD_Open(uint32_t u32DrivingType, uint32_t u32ComNum, uint32_t u32BiasLevel, uint32_t u32FramerateDiv, uint32_t u32DrivingVol);
Nvoid LCD_SetPixel(uint32_t u32Com, uint32_t u32Seg, uint32_t u32OnFlag);
Nvoid LCD_SetAllPixels(uint32_t u32OnOff);
Nvoid LCD_Close(void);
N
N/**
N *  @brief Enable LCD controller
N *
N *  @param None
N *
N *  @return None
N *
N */
Nstatic __INLINE void LCD_EnableDisplay(void)
Xstatic __inline void LCD_EnableDisplay(void)
N{
N    /* Enable LCD */
N    LCD->CTL |= LCD_CTL_EN_Msk;
X    ((LCD_T *) (((uint32_t)0x40000000) + 0xB0000))->CTL |= (0x1ul << (0));
N}
N
N/**
N *  @brief Disable LCD controller
N *
N *  @param None
N *
N *  @return None
N *
N */
Nstatic __INLINE void LCD_DisableDisplay(void)
Xstatic __inline void LCD_DisableDisplay(void)
N{
N    /* Enable LCD */
N    LCD->CTL &= ~LCD_CTL_EN_Msk;
X    ((LCD_T *) (((uint32_t)0x40000000) + 0xB0000))->CTL &= ~(0x1ul << (0));
N}
N
N
N
N/*@}*/ /* end of group NANO100_LCD_EXPORTED_FUNCTIONS */
N
N
N/*@}*/ /* end of group NANO100_LCD_Driver */
N
N/*@}*/ /* end of group NANO100_Device_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* __LCD_H__ */
N
N
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
N
L 11948 "..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include\Nano100Series.h" 2
N
N#endif  // __NANO100SERIES_H__
N
N/*** (C) COPYRIGHT 2016 Nuvoton Technology Corp. ***/
N
L 3 "..\targetdev.h" 2
N#include "ISP_USER.h"
L 1 "..\ISP_USER.h" 1
N#ifndef ISP_USER_H
S#define ISP_USER_H
S
S#define FW_VERSION                  0x31
S
S#include "FMC_USER.h"
S
S//#define SUPPORT_WRITECKSUM
S
S#define CMD_UPDATE_APROM            0x000000A0
S#define CMD_UPDATE_CONFIG           0x000000A1
S#define CMD_READ_CONFIG             0x000000A2
S#define CMD_ERASE_ALL               0x000000A3
S#define CMD_SYNC_PACKNO             0x000000A4
S#define CMD_GET_FWVER               0x000000A6
S#define CMD_SET_APPINFO             0x000000A7
S#define CMD_GET_APPINFO             0x000000A8
S#define CMD_RUN_APROM               0x000000AB
S#define CMD_RUN_LDROM               0x000000AC
S#define CMD_RESET                   0x000000AD
S#define CMD_CONNECT                 0x000000AE
S#define CMD_DISCONNECT              0x000000AF
S
S#define CMD_GET_DEVICEID            0x000000B1
S
S#define CMD_UPDATE_DATAFLASH        0x000000C3
S#define CMD_WRITE_CHECKSUM          0x000000C9
S#define CMD_GET_FLASHMODE           0x000000CA
S
S#define CMD_RESEND_PACKET           0x000000FF
S
S#define V6M_AIRCR_VECTKEY_DATA      0x05FA0000UL
S#define V6M_AIRCR_SYSRESETREQ       0x00000004UL
S
S#define DISCONNECTED                0
S#define CONNECTING                  1
S#define CONNECTED                   2
S
S
Sextern void GetDataFlashInfo(uint32_t *addr, uint32_t *size);
Sextern uint32_t GetApromSize(void);
Sextern int ParseCmd(unsigned char *buffer, uint8_t len);
Sextern uint32_t g_apromSize, g_dataFlashAddr, g_dataFlashSize;
S
Sextern __align(4) uint8_t usb_rcvbuf[];
Sextern __align(4) uint8_t usb_sendbuf[];
Sextern __align(4) uint8_t response_buff[64];
N#endif  // #ifndef ISP_USER_H
L 4 "..\targetdev.h" 2
N
N#define DetectPin             PE5
N
L 5 "..\FMC_USER.h" 2
N
N// #define FMC_CONFIG0_ADDR        (FMC_CONFIG_BASE)       /*!< CONFIG 0 Address */
N// #define FMC_CONFIG1_ADDR        (FMC_CONFIG_BASE + 4)   /*!< CONFIG 1 Address */
N
N#define Config0         FMC_CONFIG_BASE
N#define Config1         (FMC_CONFIG_BASE+4)
N
N#define ISPGO           0x01
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define parameter                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FMC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define _FMC_ENABLE_CFG_UPDATE()   (FMC->ISPCTL |=  FMC_ISPCTL_CFGUEN_Msk) /*!< Enable CONFIG Update Function  */
N#define _FMC_DISABLE_CFG_UPDATE()  (FMC->ISPCTL &= ~FMC_ISPCTL_CFGUEN_Msk) /*!< Disable CONFIG Update Function */
N
N
Nextern void EraseAP(unsigned int addr_start, unsigned int addr_end);
Nextern void ReadData(unsigned int addr_start, unsigned int addr_end, unsigned int *data);
Nextern void WriteData(unsigned int addr_start, unsigned int addr_end, unsigned int *data);
Nextern void GetDataFlashInfo(uint32_t *addr, uint32_t *size);
Nint FMC_Write_User(unsigned int u32Addr, unsigned int u32Data);
Nint FMC_Read_User(unsigned int u32Addr, unsigned int *data);
Nint FMC_Erase_User(unsigned int u32Addr);
N
N#endif
N
L 7 "..\ISP_USER.h" 2
N
N//#define SUPPORT_WRITECKSUM
N
N#define CMD_UPDATE_APROM            0x000000A0
N#define CMD_UPDATE_CONFIG           0x000000A1
N#define CMD_READ_CONFIG             0x000000A2
N#define CMD_ERASE_ALL               0x000000A3
N#define CMD_SYNC_PACKNO             0x000000A4
N#define CMD_GET_FWVER               0x000000A6
N#define CMD_SET_APPINFO             0x000000A7
N#define CMD_GET_APPINFO             0x000000A8
N#define CMD_RUN_APROM               0x000000AB
N#define CMD_RUN_LDROM               0x000000AC
N#define CMD_RESET                   0x000000AD
N#define CMD_CONNECT                 0x000000AE
N#define CMD_DISCONNECT              0x000000AF
N
N#define CMD_GET_DEVICEID            0x000000B1
N
N#define CMD_UPDATE_DATAFLASH        0x000000C3
N#define CMD_WRITE_CHECKSUM          0x000000C9
N#define CMD_GET_FLASHMODE           0x000000CA
N
N#define CMD_RESEND_PACKET           0x000000FF
N
N#define V6M_AIRCR_VECTKEY_DATA      0x05FA0000UL
N#define V6M_AIRCR_SYSRESETREQ       0x00000004UL
N
N#define DISCONNECTED                0
N#define CONNECTING                  1
N#define CONNECTED                   2
N
N
Nextern void GetDataFlashInfo(uint32_t *addr, uint32_t *size);
Nextern uint32_t GetApromSize(void);
Nextern int ParseCmd(unsigned char *buffer, uint8_t len);
Nextern uint32_t g_apromSize, g_dataFlashAddr, g_dataFlashSize;
N
Nextern __align(4) uint8_t usb_rcvbuf[];
Nextern __align(4) uint8_t usb_sendbuf[];
Nextern __align(4) uint8_t response_buff[64];
N#endif  // #ifndef ISP_USER_H
L 13 "..\ISP_USER.c" 2
N
N#define DATA_FLASH_VER_BASE        0xFE00
N
N__align(4) uint8_t response_buff[64];
N__align(4) static uint8_t aprom_buf[FMC_FLASH_PAGE_SIZE];
X__align(4) static uint8_t aprom_buf[0x200];
Nuint32_t bUpdateApromCmd;
Nuint32_t g_apromSize, g_dataFlashAddr, g_dataFlashSize;
N
Nstatic uint16_t Checksum(unsigned char *buf, int len)
N{
N    int i;
N    uint16_t c;
N
N    for (c = 0, i = 0 ; i < len; i++) {
N        c += buf[i];
N    }
N
N    return (c);
N}
N
Nstatic uint16_t CalCheckSum(uint32_t start, uint32_t len)
N{
N    int i;
N    register uint16_t lcksum = 0;
N
N    for (i = 0; i < len; i += FMC_FLASH_PAGE_SIZE) {
X    for (i = 0; i < len; i += 0x200) {
N        ReadData(start + i, start + i + FMC_FLASH_PAGE_SIZE, (uint32_t *)aprom_buf);
X        ReadData(start + i, start + i + 0x200, (uint32_t *)aprom_buf);
N
N        if (len - i >= FMC_FLASH_PAGE_SIZE) {
X        if (len - i >= 0x200) {
N            lcksum += Checksum(aprom_buf, FMC_FLASH_PAGE_SIZE);
X            lcksum += Checksum(aprom_buf, 0x200);
N        } else {
N            lcksum += Checksum(aprom_buf, len - i);
N        }
N    }
N
N    return lcksum;
N}
N
N//bAprom == TRUE erase all aprom besides data flash
Nvoid EraseAP(unsigned int addr_start, unsigned int addr_end)
N{
N    unsigned int eraseLoop = addr_start;
N
N    for (; eraseLoop < addr_end; eraseLoop += FMC_FLASH_PAGE_SIZE) {
X    for (; eraseLoop < addr_end; eraseLoop += 0x200) {
N        FMC_Erase_User(eraseLoop);
N    }
N
N    return;
N}
N
Nvoid UpdateConfig(unsigned int *data, unsigned int *res)
N{
N    FMC_ENABLE_CFG_UPDATE();
X    (((FMC_T *) (((uint32_t)0x50000000) + 0x0C000))->ISPCON |= (0x1ul << (4)));
N    FMC_Erase_User(Config0);
X    FMC_Erase_User(0x00300000UL);
N    FMC_Write_User(Config0, *data);
X    FMC_Write_User(0x00300000UL, *data);
N    FMC_Write_User(Config1, *(data + 1));
X    FMC_Write_User((0x00300000UL+4), *(data + 1));
N
N    if (res) {
N        FMC_Read_User(Config0, res);
X        FMC_Read_User(0x00300000UL, res);
N        FMC_Read_User(Config1, res + 1);
X        FMC_Read_User((0x00300000UL+4), res + 1);
N    }
N
N    FMC_DISABLE_CFG_UPDATE();
X    (((FMC_T *) (((uint32_t)0x50000000) + 0x0C000))->ISPCON &= ~(0x1ul << (4)));
N}
N
Nint ParseCmd(unsigned char *buffer, uint8_t len)
N{
N    static uint32_t StartAddress, StartAddress_bak, TotalLen, TotalLen_bak, LastDataLen, g_packno = 1;
N    uint8_t *response;
N    uint16_t lcksum;
N    uint32_t lcmd, srclen, i, regcnf0, security;
N    unsigned char *pSrc;
N    static uint32_t gcmd;
N    response = response_buff;
N    pSrc = buffer;
N    srclen = len;
N    lcmd = inpw(pSrc);
X    lcmd = (*((volatile unsigned int *)(pSrc)));
N    outpw(response + 4, 0);
X    *((volatile unsigned int *)(response + 4)) = 0;
N    pSrc += 8;
N    srclen -= 8;
N    ReadData(Config0, Config0 + 8, (uint32_t *)(response + 8)); //read config
X    ReadData(0x00300000UL, 0x00300000UL + 8, (uint32_t *)(response + 8)); 
N    regcnf0 = *(uint32_t *)(response + 8);
N    security = regcnf0 & 0x2;
N
N    if (lcmd == CMD_SYNC_PACKNO) {
X    if (lcmd == 0x000000A4) {
N        g_packno = inpw(pSrc);
X        g_packno = (*((volatile unsigned int *)(pSrc)));
N    }
N
N    if ((lcmd) && (lcmd != CMD_RESEND_PACKET)) {
X    if ((lcmd) && (lcmd != 0x000000FF)) {
N        gcmd = lcmd;
N    }
N
N    if (lcmd == CMD_GET_FWVER) {
X    if (lcmd == 0x000000A6) {
N        response[8] = FW_VERSION;//version 2.3
X        response[8] = 0x31;
N    } else if (lcmd == CMD_GET_DEVICEID) {
X    } else if (lcmd == 0x000000B1) {
N        outpw(response + 8, SYS->PDID);
X        *((volatile unsigned int *)(response + 8)) = ((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->PDID;
N        goto out;
N    } else if (lcmd == CMD_RUN_APROM || lcmd == CMD_RUN_LDROM || lcmd == CMD_RESET) {
X    } else if (lcmd == 0x000000AB || lcmd == 0x000000AC || lcmd == 0x000000AD) {
N        outpw(&SYS->RST_SRC, 3);//clear bit
X        *((volatile unsigned int *)(&((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->RST_SRC)) = 3;
N
N        /* Set BS */
N        if (lcmd == CMD_RUN_APROM) {
X        if (lcmd == 0x000000AB) {
N			FMC_Write_User(DATA_FLASH_VER_BASE + 24, 0);
X			FMC_Write_User(0xFE00 + 24, 0);
N			FMC_ENABLE_CFG_UPDATE();
X			(((FMC_T *) (((uint32_t)0x50000000) + 0x0C000))->ISPCON |= (0x1ul << (4)));
N
N			FMC_Write_User(Config0, 0xFFFFFFFE);
X			FMC_Write_User(0x00300000UL, 0xFFFFFFFE);
N			
N			FMC_DISABLE_CFG_UPDATE();
X			(((FMC_T *) (((uint32_t)0x50000000) + 0x0C000))->ISPCON &= ~(0x1ul << (4)));
N            i = (FMC->ISPCON & 0xFFFFFFFC);
X            i = (((FMC_T *) (((uint32_t)0x50000000) + 0x0C000))->ISPCON & 0xFFFFFFFC);
N        } else if (lcmd == CMD_RUN_LDROM) {
X        } else if (lcmd == 0x000000AC) {
N            i = (FMC->ISPCON & 0xFFFFFFFC);
X            i = (((FMC_T *) (((uint32_t)0x50000000) + 0x0C000))->ISPCON & 0xFFFFFFFC);
N            i |= 0x00000002;
N        } else {
N            i = (FMC->ISPCON & 0xFFFFFFFE);//ISP disable
X            i = (((FMC_T *) (((uint32_t)0x50000000) + 0x0C000))->ISPCON & 0xFFFFFFFE);
N        }
N
N        outpw(&FMC->ISPCON, i);
X        *((volatile unsigned int *)(&((FMC_T *) (((uint32_t)0x50000000) + 0x0C000))->ISPCON)) = i;
N        outpw(&SCB->AIRCR, (V6M_AIRCR_VECTKEY_DATA | V6M_AIRCR_SYSRESETREQ));
X        *((volatile unsigned int *)(&((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR)) = (0x05FA0000UL | 0x00000004UL);
N
N		SYS->IPRST_CTL1 = SYS_IPRST_CTL1_CHIP_RST_Msk;
X		((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->IPRST_CTL1 = (0x1ul << (0));
N        /* Trap the CPU */
N        while (1);
N    } else if (lcmd == CMD_CONNECT) {
X    } else if (lcmd == 0x000000AE) {
N        g_packno = 1;
N        goto out;
N    } else if (lcmd == CMD_DISCONNECT) {
X    } else if (lcmd == 0x000000AF) {
N        return 0;
N    } else if ((lcmd == CMD_UPDATE_APROM) || (lcmd == CMD_ERASE_ALL)) {
X    } else if ((lcmd == 0x000000A0) || (lcmd == 0x000000A3)) {
N        EraseAP(FMC_APROM_BASE, (g_apromSize < g_dataFlashAddr) ? g_apromSize : g_dataFlashAddr); // erase APROM // g_dataFlashAddr, g_apromSize
X        EraseAP(0x00000000UL, (g_apromSize < g_dataFlashAddr) ? g_apromSize : g_dataFlashAddr); 
N
N        if (lcmd == CMD_ERASE_ALL) { //erase data flash
X        if (lcmd == 0x000000A3) { 
N            EraseAP(g_dataFlashAddr, g_dataFlashAddr + g_dataFlashSize);
N            *(uint32_t *)(response + 8) = regcnf0 | 0x02;
N            UpdateConfig((uint32_t *)(response + 8), NULL);
X            UpdateConfig((uint32_t *)(response + 8), 0);
N        }
N
N        bUpdateApromCmd = TRUE;
X        bUpdateApromCmd = (1);
N    } else if (lcmd == CMD_GET_FLASHMODE) {
X    } else if (lcmd == 0x000000CA) {
N        //return 1: APROM, 2: LDROM
N        outpw(response + 8, (FMC->ISPCON & 0x2) ? 2 : 1);
X        *((volatile unsigned int *)(response + 8)) = (((FMC_T *) (((uint32_t)0x50000000) + 0x0C000))->ISPCON & 0x2) ? 2 : 1;
N    }
N
N    if ((lcmd == CMD_UPDATE_APROM) || (lcmd == CMD_UPDATE_DATAFLASH)) {
X    if ((lcmd == 0x000000A0) || (lcmd == 0x000000C3)) {
N        if (lcmd == CMD_UPDATE_DATAFLASH) {
X        if (lcmd == 0x000000C3) {
N            StartAddress = g_dataFlashAddr;
N
N            if (g_dataFlashSize) { //g_dataFlashAddr
N                EraseAP(g_dataFlashAddr, g_dataFlashAddr + g_dataFlashSize);
N            } else {
N                goto out;
N            }
N        } else {
N            StartAddress = 0;
N        }
N
N        //StartAddress = inpw(pSrc);
N        TotalLen = inpw(pSrc + 4);
X        TotalLen = (*((volatile unsigned int *)(pSrc + 4)));
N        pSrc += 8;
N        srclen -= 8;
N        StartAddress_bak = StartAddress;
N        TotalLen_bak = TotalLen;
N    } else if (lcmd == CMD_UPDATE_CONFIG) {
X    } else if (lcmd == 0x000000A1) {
N        if ((security == 0) && (!bUpdateApromCmd)) { //security lock
N            goto out;
N        }
N
N        UpdateConfig((uint32_t *)(pSrc), (uint32_t *)(response + 8));
N        GetDataFlashInfo(&g_dataFlashAddr, &g_dataFlashSize);
N        goto out;
N    } else if (lcmd == CMD_RESEND_PACKET) { //for APROM&Data flash only
X    } else if (lcmd == 0x000000FF) { 
N        StartAddress -= LastDataLen;
N        TotalLen += LastDataLen;
N
N        if ((StartAddress & 0xFFE00) >= Config0) {
X        if ((StartAddress & 0xFFE00) >= 0x00300000UL) {
N            goto out;
N        }
N
N        ReadData(StartAddress & 0xFFE00, StartAddress, (uint32_t *)aprom_buf);
N        FMC_Erase_User(StartAddress & 0xFFE00);
N        WriteData(StartAddress & 0xFFE00, StartAddress, (uint32_t *)aprom_buf);
N
N        if ((StartAddress % FMC_FLASH_PAGE_SIZE) >= (FMC_FLASH_PAGE_SIZE - LastDataLen)) {
X        if ((StartAddress % 0x200) >= (0x200 - LastDataLen)) {
N            FMC_Erase_User((StartAddress & 0xFFE00) + FMC_FLASH_PAGE_SIZE);
X            FMC_Erase_User((StartAddress & 0xFFE00) + 0x200);
N        }
N
N        goto out;
N    }
N
N    if ((gcmd == CMD_UPDATE_APROM) || (gcmd == CMD_UPDATE_DATAFLASH)) {
X    if ((gcmd == 0x000000A0) || (gcmd == 0x000000C3)) {
N        if (TotalLen < srclen) {
N            srclen = TotalLen;//prevent last package from over writing
N        }
N
N        TotalLen -= srclen;
N        WriteData(StartAddress, StartAddress + srclen, (uint32_t *)pSrc); //WriteData(StartAddress, StartAddress + srclen, (uint32_t*)pSrc);
N        memset(pSrc, 0, srclen);
N        ReadData(StartAddress, StartAddress + srclen, (uint32_t *)pSrc);
N        StartAddress += srclen;
N        LastDataLen =  srclen;
N
N        if (TotalLen == 0) {
N            lcksum = CalCheckSum(StartAddress_bak, TotalLen_bak);
N            outps(response + 8, lcksum);
X            *((volatile unsigned short *)(response + 8)) = lcksum;
N        }
N    }
N
Nout:
N    lcksum = Checksum(buffer, len);
N    outps(response, lcksum);
X    *((volatile unsigned short *)(response)) = lcksum;
N    ++g_packno;
N    outpw(response + 4, g_packno);
X    *((volatile unsigned int *)(response + 4)) = g_packno;
N    g_packno++;
N    return 0;
N}
N
